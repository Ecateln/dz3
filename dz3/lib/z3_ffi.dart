// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

class Z3Lib {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  Z3Lib(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  Z3Lib.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  void __va_start(
    ffi.Pointer<va_list> arg0,
  ) {
    return ___va_start(
      arg0,
    );
  }

  late final ___va_startPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<va_list>)>>(
          '__va_start');
  late final ___va_start =
      ___va_startPtr.asFunction<void Function(ffi.Pointer<va_list>)>();

  void __security_init_cookie() {
    return ___security_init_cookie();
  }

  late final ___security_init_cookiePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          '__security_init_cookie');
  late final ___security_init_cookie =
      ___security_init_cookiePtr.asFunction<void Function()>();

  void __security_check_cookie(
    int _StackCookie,
  ) {
    return ___security_check_cookie(
      _StackCookie,
    );
  }

  late final ___security_check_cookiePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UintPtr)>>(
          '__security_check_cookie');
  late final ___security_check_cookie =
      ___security_check_cookiePtr.asFunction<void Function(int)>();

  void __report_gsfailure(
    int _StackCookie,
  ) {
    return ___report_gsfailure(
      _StackCookie,
    );
  }

  late final ___report_gsfailurePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UintPtr)>>(
          '__report_gsfailure');
  late final ___report_gsfailure =
      ___report_gsfailurePtr.asFunction<void Function(int)>();

  late final ffi.Pointer<ffi.UintPtr> ___security_cookie =
      _lookup<ffi.UintPtr>('__security_cookie');

  int get __security_cookie => ___security_cookie.value;

  set __security_cookie(int value) => ___security_cookie.value = value;

  void _invalid_parameter_noinfo() {
    return __invalid_parameter_noinfo();
  }

  late final __invalid_parameter_noinfoPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          '_invalid_parameter_noinfo');
  late final __invalid_parameter_noinfo =
      __invalid_parameter_noinfoPtr.asFunction<void Function()>();

  void _invalid_parameter_noinfo_noreturn() {
    return __invalid_parameter_noinfo_noreturn();
  }

  late final __invalid_parameter_noinfo_noreturnPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          '_invalid_parameter_noinfo_noreturn');
  late final __invalid_parameter_noinfo_noreturn =
      __invalid_parameter_noinfo_noreturnPtr.asFunction<void Function()>();

  void _invoke_watson(
    ffi.Pointer<ffi.WChar> _Expression,
    ffi.Pointer<ffi.WChar> _FunctionName,
    ffi.Pointer<ffi.WChar> _FileName,
    int _LineNo,
    int _Reserved,
  ) {
    return __invoke_watson(
      _Expression,
      _FunctionName,
      _FileName,
      _LineNo,
      _Reserved,
    );
  }

  late final __invoke_watsonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>,
              ffi.UnsignedInt,
              ffi.UintPtr)>>('_invoke_watson');
  late final __invoke_watson = __invoke_watsonPtr.asFunction<
      void Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
          ffi.Pointer<ffi.WChar>, int, int)>();

  ffi.Pointer<FILE> __acrt_iob_func(
    int _Ix,
  ) {
    return ___acrt_iob_func(
      _Ix,
    );
  }

  late final ___acrt_iob_funcPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<FILE> Function(ffi.UnsignedInt)>>(
          '__acrt_iob_func');
  late final ___acrt_iob_func =
      ___acrt_iob_funcPtr.asFunction<ffi.Pointer<FILE> Function(int)>();

  int fgetwc(
    ffi.Pointer<FILE> _Stream,
  ) {
    return _fgetwc(
      _Stream,
    );
  }

  late final _fgetwcPtr =
      _lookup<ffi.NativeFunction<wint_t Function(ffi.Pointer<FILE>)>>('fgetwc');
  late final _fgetwc = _fgetwcPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int _fgetwchar() {
    return __fgetwchar();
  }

  late final __fgetwcharPtr =
      _lookup<ffi.NativeFunction<wint_t Function()>>('_fgetwchar');
  late final __fgetwchar = __fgetwcharPtr.asFunction<int Function()>();

  int fputwc(
    int _Character,
    ffi.Pointer<FILE> _Stream,
  ) {
    return _fputwc(
      _Character,
      _Stream,
    );
  }

  late final _fputwcPtr = _lookup<
      ffi
      .NativeFunction<wint_t Function(ffi.WChar, ffi.Pointer<FILE>)>>('fputwc');
  late final _fputwc =
      _fputwcPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int _fputwchar(
    int _Character,
  ) {
    return __fputwchar(
      _Character,
    );
  }

  late final __fputwcharPtr =
      _lookup<ffi.NativeFunction<wint_t Function(ffi.WChar)>>('_fputwchar');
  late final __fputwchar = __fputwcharPtr.asFunction<int Function(int)>();

  int getwc(
    ffi.Pointer<FILE> _Stream,
  ) {
    return _getwc(
      _Stream,
    );
  }

  late final _getwcPtr =
      _lookup<ffi.NativeFunction<wint_t Function(ffi.Pointer<FILE>)>>('getwc');
  late final _getwc = _getwcPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int getwchar() {
    return _getwchar();
  }

  late final _getwcharPtr =
      _lookup<ffi.NativeFunction<wint_t Function()>>('getwchar');
  late final _getwchar = _getwcharPtr.asFunction<int Function()>();

  ffi.Pointer<ffi.WChar> fgetws(
    ffi.Pointer<ffi.WChar> _Buffer,
    int _BufferCount,
    ffi.Pointer<FILE> _Stream,
  ) {
    return _fgetws(
      _Buffer,
      _BufferCount,
      _Stream,
    );
  }

  late final _fgetwsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Int, ffi.Pointer<FILE>)>>('fgetws');
  late final _fgetws = _fgetwsPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, int, ffi.Pointer<FILE>)>();

  int fputws(
    ffi.Pointer<ffi.WChar> _Buffer,
    ffi.Pointer<FILE> _Stream,
  ) {
    return _fputws(
      _Buffer,
      _Stream,
    );
  }

  late final _fputwsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<FILE>)>>('fputws');
  late final _fputws = _fputwsPtr
      .asFunction<int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<FILE>)>();

  ffi.Pointer<ffi.WChar> _getws_s(
    ffi.Pointer<ffi.WChar> _Buffer,
    int _BufferCount,
  ) {
    return __getws_s(
      _Buffer,
      _BufferCount,
    );
  }

  late final __getws_sPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Size)>>('_getws_s');
  late final __getws_s = __getws_sPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>, int)>();

  int putwc(
    int _Character,
    ffi.Pointer<FILE> _Stream,
  ) {
    return _putwc(
      _Character,
      _Stream,
    );
  }

  late final _putwcPtr = _lookup<
      ffi
      .NativeFunction<wint_t Function(ffi.WChar, ffi.Pointer<FILE>)>>('putwc');
  late final _putwc =
      _putwcPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int putwchar(
    int _Character,
  ) {
    return _putwchar(
      _Character,
    );
  }

  late final _putwcharPtr =
      _lookup<ffi.NativeFunction<wint_t Function(ffi.WChar)>>('putwchar');
  late final _putwchar = _putwcharPtr.asFunction<int Function(int)>();

  int _putws(
    ffi.Pointer<ffi.WChar> _Buffer,
  ) {
    return __putws(
      _Buffer,
    );
  }

  late final __putwsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.WChar>)>>(
          '_putws');
  late final __putws =
      __putwsPtr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  int ungetwc(
    int _Character,
    ffi.Pointer<FILE> _Stream,
  ) {
    return _ungetwc(
      _Character,
      _Stream,
    );
  }

  late final _ungetwcPtr =
      _lookup<ffi.NativeFunction<wint_t Function(wint_t, ffi.Pointer<FILE>)>>(
          'ungetwc');
  late final _ungetwc =
      _ungetwcPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> _wfdopen(
    int _FileHandle,
    ffi.Pointer<ffi.WChar> _Mode,
  ) {
    return __wfdopen(
      _FileHandle,
      _Mode,
    );
  }

  late final __wfdopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Int, ffi.Pointer<ffi.WChar>)>>('_wfdopen');
  late final __wfdopen = __wfdopenPtr
      .asFunction<ffi.Pointer<FILE> Function(int, ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<FILE> _wfopen(
    ffi.Pointer<ffi.WChar> _FileName,
    ffi.Pointer<ffi.WChar> _Mode,
  ) {
    return __wfopen(
      _FileName,
      _Mode,
    );
  }

  late final __wfopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('_wfopen');
  late final __wfopen = __wfopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int _wfopen_s(
    ffi.Pointer<ffi.Pointer<FILE>> _Stream,
    ffi.Pointer<ffi.WChar> _FileName,
    ffi.Pointer<ffi.WChar> _Mode,
  ) {
    return __wfopen_s(
      _Stream,
      _FileName,
      _Mode,
    );
  }

  late final __wfopen_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.Pointer<FILE>>,
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('_wfopen_s');
  late final __wfopen_s = __wfopen_sPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<FILE>>, ffi.Pointer<ffi.WChar>,
          ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<FILE> _wfreopen(
    ffi.Pointer<ffi.WChar> _FileName,
    ffi.Pointer<ffi.WChar> _Mode,
    ffi.Pointer<FILE> _OldStream,
  ) {
    return __wfreopen(
      _FileName,
      _Mode,
      _OldStream,
    );
  }

  late final __wfreopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>, ffi.Pointer<FILE>)>>('_wfreopen');
  late final __wfreopen = __wfreopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, ffi.Pointer<FILE>)>();

  int _wfreopen_s(
    ffi.Pointer<ffi.Pointer<FILE>> _Stream,
    ffi.Pointer<ffi.WChar> _FileName,
    ffi.Pointer<ffi.WChar> _Mode,
    ffi.Pointer<FILE> _OldStream,
  ) {
    return __wfreopen_s(
      _Stream,
      _FileName,
      _Mode,
      _OldStream,
    );
  }

  late final __wfreopen_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(
              ffi.Pointer<ffi.Pointer<FILE>>,
              ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>,
              ffi.Pointer<FILE>)>>('_wfreopen_s');
  late final __wfreopen_s = __wfreopen_sPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<FILE>>, ffi.Pointer<ffi.WChar>,
          ffi.Pointer<ffi.WChar>, ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> _wfsopen(
    ffi.Pointer<ffi.WChar> _FileName,
    ffi.Pointer<ffi.WChar> _Mode,
    int _ShFlag,
  ) {
    return __wfsopen(
      _FileName,
      _Mode,
      _ShFlag,
    );
  }

  late final __wfsopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>, ffi.Int)>>('_wfsopen');
  late final __wfsopen = __wfsopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  void _wperror(
    ffi.Pointer<ffi.WChar> _ErrorMessage,
  ) {
    return __wperror(
      _ErrorMessage,
    );
  }

  late final __wperrorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.WChar>)>>(
          '_wperror');
  late final __wperror =
      __wperrorPtr.asFunction<void Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<FILE> _wpopen(
    ffi.Pointer<ffi.WChar> _Command,
    ffi.Pointer<ffi.WChar> _Mode,
  ) {
    return __wpopen(
      _Command,
      _Mode,
    );
  }

  late final __wpopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('_wpopen');
  late final __wpopen = __wpopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int _wremove(
    ffi.Pointer<ffi.WChar> _FileName,
  ) {
    return __wremove(
      _FileName,
    );
  }

  late final __wremovePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.WChar>)>>(
          '_wremove');
  late final __wremove =
      __wremovePtr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> _wtempnam(
    ffi.Pointer<ffi.WChar> _Directory,
    ffi.Pointer<ffi.WChar> _FilePrefix,
  ) {
    return __wtempnam(
      _Directory,
      _FilePrefix,
    );
  }

  late final __wtempnamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('_wtempnam');
  late final __wtempnam = __wtempnamPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int _wtmpnam_s(
    ffi.Pointer<ffi.WChar> _Buffer,
    int _BufferCount,
  ) {
    return __wtmpnam_s(
      _Buffer,
      _BufferCount,
    );
  }

  late final __wtmpnam_sPtr = _lookup<
          ffi
          .NativeFunction<errno_t Function(ffi.Pointer<ffi.WChar>, ffi.Size)>>(
      '_wtmpnam_s');
  late final __wtmpnam_s =
      __wtmpnam_sPtr.asFunction<int Function(ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> _wtmpnam(
    ffi.Pointer<ffi.WChar> _Buffer,
  ) {
    return __wtmpnam(
      _Buffer,
    );
  }

  late final __wtmpnamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>>('_wtmpnam');
  late final __wtmpnam = __wtmpnamPtr
      .asFunction<ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  int _fgetwc_nolock(
    ffi.Pointer<FILE> _Stream,
  ) {
    return __fgetwc_nolock(
      _Stream,
    );
  }

  late final __fgetwc_nolockPtr =
      _lookup<ffi.NativeFunction<wint_t Function(ffi.Pointer<FILE>)>>(
          '_fgetwc_nolock');
  late final __fgetwc_nolock =
      __fgetwc_nolockPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int _fputwc_nolock(
    int _Character,
    ffi.Pointer<FILE> _Stream,
  ) {
    return __fputwc_nolock(
      _Character,
      _Stream,
    );
  }

  late final __fputwc_nolockPtr = _lookup<
          ffi.NativeFunction<wint_t Function(ffi.WChar, ffi.Pointer<FILE>)>>(
      '_fputwc_nolock');
  late final __fputwc_nolock =
      __fputwc_nolockPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int _getwc_nolock(
    ffi.Pointer<FILE> _Stream,
  ) {
    return __getwc_nolock(
      _Stream,
    );
  }

  late final __getwc_nolockPtr =
      _lookup<ffi.NativeFunction<wint_t Function(ffi.Pointer<FILE>)>>(
          '_getwc_nolock');
  late final __getwc_nolock =
      __getwc_nolockPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int _putwc_nolock(
    int _Character,
    ffi.Pointer<FILE> _Stream,
  ) {
    return __putwc_nolock(
      _Character,
      _Stream,
    );
  }

  late final __putwc_nolockPtr = _lookup<
          ffi.NativeFunction<wint_t Function(ffi.WChar, ffi.Pointer<FILE>)>>(
      '_putwc_nolock');
  late final __putwc_nolock =
      __putwc_nolockPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int _ungetwc_nolock(
    int _Character,
    ffi.Pointer<FILE> _Stream,
  ) {
    return __ungetwc_nolock(
      _Character,
      _Stream,
    );
  }

  late final __ungetwc_nolockPtr =
      _lookup<ffi.NativeFunction<wint_t Function(wint_t, ffi.Pointer<FILE>)>>(
          '_ungetwc_nolock');
  late final __ungetwc_nolock =
      __ungetwc_nolockPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int __stdio_common_vfwprintf(
    int _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vfwprintf(
      _Options,
      _Stream,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vfwprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedLongLong,
              ffi.Pointer<FILE>,
              ffi.Pointer<ffi.WChar>,
              _locale_t,
              va_list)>>('__stdio_common_vfwprintf');
  late final ___stdio_common_vfwprintf =
      ___stdio_common_vfwprintfPtr.asFunction<
          int Function(int, ffi.Pointer<FILE>, ffi.Pointer<ffi.WChar>,
              _locale_t, va_list)>();

  int __stdio_common_vfwprintf_s(
    int _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vfwprintf_s(
      _Options,
      _Stream,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vfwprintf_sPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedLongLong,
              ffi.Pointer<FILE>,
              ffi.Pointer<ffi.WChar>,
              _locale_t,
              va_list)>>('__stdio_common_vfwprintf_s');
  late final ___stdio_common_vfwprintf_s =
      ___stdio_common_vfwprintf_sPtr.asFunction<
          int Function(int, ffi.Pointer<FILE>, ffi.Pointer<ffi.WChar>,
              _locale_t, va_list)>();

  int __stdio_common_vfwprintf_p(
    int _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vfwprintf_p(
      _Options,
      _Stream,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vfwprintf_pPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedLongLong,
              ffi.Pointer<FILE>,
              ffi.Pointer<ffi.WChar>,
              _locale_t,
              va_list)>>('__stdio_common_vfwprintf_p');
  late final ___stdio_common_vfwprintf_p =
      ___stdio_common_vfwprintf_pPtr.asFunction<
          int Function(int, ffi.Pointer<FILE>, ffi.Pointer<ffi.WChar>,
              _locale_t, va_list)>();

  int __stdio_common_vfwscanf(
    int _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vfwscanf(
      _Options,
      _Stream,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vfwscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedLongLong,
              ffi.Pointer<FILE>,
              ffi.Pointer<ffi.WChar>,
              _locale_t,
              va_list)>>('__stdio_common_vfwscanf');
  late final ___stdio_common_vfwscanf = ___stdio_common_vfwscanfPtr.asFunction<
      int Function(int, ffi.Pointer<FILE>, ffi.Pointer<ffi.WChar>, _locale_t,
          va_list)>();

  int __stdio_common_vswprintf(
    int _Options,
    ffi.Pointer<ffi.WChar> _Buffer,
    int _BufferCount,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vswprintf(
      _Options,
      _Buffer,
      _BufferCount,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vswprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedLongLong,
              ffi.Pointer<ffi.WChar>,
              ffi.Size,
              ffi.Pointer<ffi.WChar>,
              _locale_t,
              va_list)>>('__stdio_common_vswprintf');
  late final ___stdio_common_vswprintf =
      ___stdio_common_vswprintfPtr.asFunction<
          int Function(int, ffi.Pointer<ffi.WChar>, int, ffi.Pointer<ffi.WChar>,
              _locale_t, va_list)>();

  int __stdio_common_vswprintf_s(
    int _Options,
    ffi.Pointer<ffi.WChar> _Buffer,
    int _BufferCount,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vswprintf_s(
      _Options,
      _Buffer,
      _BufferCount,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vswprintf_sPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedLongLong,
              ffi.Pointer<ffi.WChar>,
              ffi.Size,
              ffi.Pointer<ffi.WChar>,
              _locale_t,
              va_list)>>('__stdio_common_vswprintf_s');
  late final ___stdio_common_vswprintf_s =
      ___stdio_common_vswprintf_sPtr.asFunction<
          int Function(int, ffi.Pointer<ffi.WChar>, int, ffi.Pointer<ffi.WChar>,
              _locale_t, va_list)>();

  int __stdio_common_vsnwprintf_s(
    int _Options,
    ffi.Pointer<ffi.WChar> _Buffer,
    int _BufferCount,
    int _MaxCount,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vsnwprintf_s(
      _Options,
      _Buffer,
      _BufferCount,
      _MaxCount,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vsnwprintf_sPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedLongLong,
              ffi.Pointer<ffi.WChar>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<ffi.WChar>,
              _locale_t,
              va_list)>>('__stdio_common_vsnwprintf_s');
  late final ___stdio_common_vsnwprintf_s =
      ___stdio_common_vsnwprintf_sPtr.asFunction<
          int Function(int, ffi.Pointer<ffi.WChar>, int, int,
              ffi.Pointer<ffi.WChar>, _locale_t, va_list)>();

  int __stdio_common_vswprintf_p(
    int _Options,
    ffi.Pointer<ffi.WChar> _Buffer,
    int _BufferCount,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vswprintf_p(
      _Options,
      _Buffer,
      _BufferCount,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vswprintf_pPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedLongLong,
              ffi.Pointer<ffi.WChar>,
              ffi.Size,
              ffi.Pointer<ffi.WChar>,
              _locale_t,
              va_list)>>('__stdio_common_vswprintf_p');
  late final ___stdio_common_vswprintf_p =
      ___stdio_common_vswprintf_pPtr.asFunction<
          int Function(int, ffi.Pointer<ffi.WChar>, int, ffi.Pointer<ffi.WChar>,
              _locale_t, va_list)>();

  int __stdio_common_vswscanf(
    int _Options,
    ffi.Pointer<ffi.WChar> _Buffer,
    int _BufferCount,
    ffi.Pointer<ffi.WChar> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vswscanf(
      _Options,
      _Buffer,
      _BufferCount,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vswscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedLongLong,
              ffi.Pointer<ffi.WChar>,
              ffi.Size,
              ffi.Pointer<ffi.WChar>,
              _locale_t,
              va_list)>>('__stdio_common_vswscanf');
  late final ___stdio_common_vswscanf = ___stdio_common_vswscanfPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.WChar>, int, ffi.Pointer<ffi.WChar>,
          _locale_t, va_list)>();

  int _get_stream_buffer_pointers(
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> _Base,
    ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> _Pointer,
    ffi.Pointer<ffi.Pointer<ffi.Int>> _Count,
  ) {
    return __get_stream_buffer_pointers(
      _Stream,
      _Base,
      _Pointer,
      _Count,
    );
  }

  late final __get_stream_buffer_pointersPtr = _lookup<
          ffi.NativeFunction<
              errno_t Function(
                  ffi.Pointer<FILE>,
                  ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>>,
                  ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>>,
                  ffi.Pointer<ffi.Pointer<ffi.Int>>)>>(
      '_get_stream_buffer_pointers');
  late final __get_stream_buffer_pointers =
      __get_stream_buffer_pointersPtr.asFunction<
          int Function(
              ffi.Pointer<FILE>,
              ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>>,
              ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>>,
              ffi.Pointer<ffi.Pointer<ffi.Int>>)>();

  int clearerr_s(
    ffi.Pointer<FILE> _Stream,
  ) {
    return _clearerr_s(
      _Stream,
    );
  }

  late final _clearerr_sPtr =
      _lookup<ffi.NativeFunction<errno_t Function(ffi.Pointer<FILE>)>>(
          'clearerr_s');
  late final _clearerr_s =
      _clearerr_sPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fopen_s(
    ffi.Pointer<ffi.Pointer<FILE>> _Stream,
    ffi.Pointer<ffi.Char> _FileName,
    ffi.Pointer<ffi.Char> _Mode,
  ) {
    return _fopen_s(
      _Stream,
      _FileName,
      _Mode,
    );
  }

  late final _fopen_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.Pointer<FILE>>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('fopen_s');
  late final _fopen_s = _fopen_sPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<FILE>>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  int fread_s(
    ffi.Pointer<ffi.Void> _Buffer,
    int _BufferSize,
    int _ElementSize,
    int _ElementCount,
    ffi.Pointer<FILE> _Stream,
  ) {
    return _fread_s(
      _Buffer,
      _BufferSize,
      _ElementSize,
      _ElementCount,
      _Stream,
    );
  }

  late final _fread_sPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size, ffi.Size,
              ffi.Pointer<FILE>)>>('fread_s');
  late final _fread_s = _fread_sPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int, int, ffi.Pointer<FILE>)>();

  int freopen_s(
    ffi.Pointer<ffi.Pointer<FILE>> _Stream,
    ffi.Pointer<ffi.Char> _FileName,
    ffi.Pointer<ffi.Char> _Mode,
    ffi.Pointer<FILE> _OldStream,
  ) {
    return _freopen_s(
      _Stream,
      _FileName,
      _Mode,
      _OldStream,
    );
  }

  late final _freopen_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(
              ffi.Pointer<ffi.Pointer<FILE>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<FILE>)>>('freopen_s');
  late final _freopen_s = _freopen_sPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<FILE>>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>();

  ffi.Pointer<ffi.Char> gets_s(
    ffi.Pointer<ffi.Char> _Buffer,
    int _Size,
  ) {
    return _gets_s(
      _Buffer,
      _Size,
    );
  }

  late final _gets_sPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, rsize_t)>>('gets_s');
  late final _gets_s = _gets_sPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  int tmpfile_s(
    ffi.Pointer<ffi.Pointer<FILE>> _Stream,
  ) {
    return _tmpfile_s(
      _Stream,
    );
  }

  late final _tmpfile_sPtr = _lookup<
          ffi.NativeFunction<errno_t Function(ffi.Pointer<ffi.Pointer<FILE>>)>>(
      'tmpfile_s');
  late final _tmpfile_s =
      _tmpfile_sPtr.asFunction<int Function(ffi.Pointer<ffi.Pointer<FILE>>)>();

  int tmpnam_s(
    ffi.Pointer<ffi.Char> _Buffer,
    int _Size,
  ) {
    return _tmpnam_s(
      _Buffer,
      _Size,
    );
  }

  late final _tmpnam_sPtr = _lookup<
          ffi.NativeFunction<errno_t Function(ffi.Pointer<ffi.Char>, rsize_t)>>(
      'tmpnam_s');
  late final _tmpnam_s =
      _tmpnam_sPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  void clearerr(
    ffi.Pointer<FILE> _Stream,
  ) {
    return _clearerr(
      _Stream,
    );
  }

  late final _clearerrPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'clearerr');
  late final _clearerr =
      _clearerrPtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int fclose(
    ffi.Pointer<FILE> _Stream,
  ) {
    return _fclose(
      _Stream,
    );
  }

  late final _fclosePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fclose');
  late final _fclose = _fclosePtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int _fcloseall() {
    return __fcloseall();
  }

  late final __fcloseallPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('_fcloseall');
  late final __fcloseall = __fcloseallPtr.asFunction<int Function()>();

  ffi.Pointer<FILE> _fdopen(
    int _FileHandle,
    ffi.Pointer<ffi.Char> _Mode,
  ) {
    return __fdopen(
      _FileHandle,
      _Mode,
    );
  }

  late final __fdopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Int, ffi.Pointer<ffi.Char>)>>('_fdopen');
  late final __fdopen = __fdopenPtr
      .asFunction<ffi.Pointer<FILE> Function(int, ffi.Pointer<ffi.Char>)>();

  int feof(
    ffi.Pointer<FILE> _Stream,
  ) {
    return _feof(
      _Stream,
    );
  }

  late final _feofPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('feof');
  late final _feof = _feofPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int ferror(
    ffi.Pointer<FILE> _Stream,
  ) {
    return _ferror(
      _Stream,
    );
  }

  late final _ferrorPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'ferror');
  late final _ferror = _ferrorPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fflush(
    ffi.Pointer<FILE> _Stream,
  ) {
    return _fflush(
      _Stream,
    );
  }

  late final _fflushPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fflush');
  late final _fflush = _fflushPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fgetc(
    ffi.Pointer<FILE> _Stream,
  ) {
    return _fgetc(
      _Stream,
    );
  }

  late final _fgetcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('fgetc');
  late final _fgetc = _fgetcPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int _fgetchar() {
    return __fgetchar();
  }

  late final __fgetcharPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('_fgetchar');
  late final __fgetchar = __fgetcharPtr.asFunction<int Function()>();

  int fgetpos(
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<fpos_t> _Position,
  ) {
    return _fgetpos(
      _Stream,
      _Position,
    );
  }

  late final _fgetposPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>>('fgetpos');
  late final _fgetpos = _fgetposPtr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>();

  ffi.Pointer<ffi.Char> fgets(
    ffi.Pointer<ffi.Char> _Buffer,
    int _MaxCount,
    ffi.Pointer<FILE> _Stream,
  ) {
    return _fgets(
      _Buffer,
      _MaxCount,
      _Stream,
    );
  }

  late final _fgetsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int, ffi.Pointer<FILE>)>>('fgets');
  late final _fgets = _fgetsPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<FILE>)>();

  int _fileno(
    ffi.Pointer<FILE> _Stream,
  ) {
    return __fileno(
      _Stream,
    );
  }

  late final __filenoPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          '_fileno');
  late final __fileno =
      __filenoPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int _flushall() {
    return __flushall();
  }

  late final __flushallPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('_flushall');
  late final __flushall = __flushallPtr.asFunction<int Function()>();

  ffi.Pointer<FILE> fopen(
    ffi.Pointer<ffi.Char> _FileName,
    ffi.Pointer<ffi.Char> _Mode,
  ) {
    return _fopen(
      _FileName,
      _Mode,
    );
  }

  late final _fopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('fopen');
  late final _fopen = _fopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int fputc(
    int _Character,
    ffi.Pointer<FILE> _Stream,
  ) {
    return _fputc(
      _Character,
      _Stream,
    );
  }

  late final _fputcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'fputc');
  late final _fputc =
      _fputcPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int _fputchar(
    int _Character,
  ) {
    return __fputchar(
      _Character,
    );
  }

  late final __fputcharPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('_fputchar');
  late final __fputchar = __fputcharPtr.asFunction<int Function(int)>();

  int fputs(
    ffi.Pointer<ffi.Char> _Buffer,
    ffi.Pointer<FILE> _Stream,
  ) {
    return _fputs(
      _Buffer,
      _Stream,
    );
  }

  late final _fputsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>>('fputs');
  late final _fputs = _fputsPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>();

  int fread(
    ffi.Pointer<ffi.Void> _Buffer,
    int _ElementSize,
    int _ElementCount,
    ffi.Pointer<FILE> _Stream,
  ) {
    return _fread(
      _Buffer,
      _ElementSize,
      _ElementCount,
      _Stream,
    );
  }

  late final _freadPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.Void>, ffi.Size,
              ffi.Size, ffi.Pointer<FILE>)>>('fread');
  late final _fread = _freadPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> freopen(
    ffi.Pointer<ffi.Char> _FileName,
    ffi.Pointer<ffi.Char> _Mode,
    ffi.Pointer<FILE> _Stream,
  ) {
    return _freopen(
      _FileName,
      _Mode,
      _Stream,
    );
  }

  late final _freopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>>('freopen');
  late final _freopen = _freopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> _fsopen(
    ffi.Pointer<ffi.Char> _FileName,
    ffi.Pointer<ffi.Char> _Mode,
    int _ShFlag,
  ) {
    return __fsopen(
      _FileName,
      _Mode,
      _ShFlag,
    );
  }

  late final __fsopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('_fsopen');
  late final __fsopen = __fsopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int fsetpos(
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<fpos_t> _Position,
  ) {
    return _fsetpos(
      _Stream,
      _Position,
    );
  }

  late final _fsetposPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>>('fsetpos');
  late final _fsetpos = _fsetposPtr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>();

  int fseek(
    ffi.Pointer<FILE> _Stream,
    int _Offset,
    int _Origin,
  ) {
    return _fseek(
      _Stream,
      _Offset,
      _Origin,
    );
  }

  late final _fseekPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Long, ffi.Int)>>('fseek');
  late final _fseek =
      _fseekPtr.asFunction<int Function(ffi.Pointer<FILE>, int, int)>();

  int _fseeki64(
    ffi.Pointer<FILE> _Stream,
    int _Offset,
    int _Origin,
  ) {
    return __fseeki64(
      _Stream,
      _Offset,
      _Origin,
    );
  }

  late final __fseeki64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FILE>, ffi.LongLong, ffi.Int)>>('_fseeki64');
  late final __fseeki64 =
      __fseeki64Ptr.asFunction<int Function(ffi.Pointer<FILE>, int, int)>();

  int ftell(
    ffi.Pointer<FILE> _Stream,
  ) {
    return _ftell(
      _Stream,
    );
  }

  late final _ftellPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<FILE>)>>(
          'ftell');
  late final _ftell = _ftellPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int _ftelli64(
    ffi.Pointer<FILE> _Stream,
  ) {
    return __ftelli64(
      _Stream,
    );
  }

  late final __ftelli64Ptr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Pointer<FILE>)>>(
          '_ftelli64');
  late final __ftelli64 =
      __ftelli64Ptr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fwrite(
    ffi.Pointer<ffi.Void> _Buffer,
    int _ElementSize,
    int _ElementCount,
    ffi.Pointer<FILE> _Stream,
  ) {
    return _fwrite(
      _Buffer,
      _ElementSize,
      _ElementCount,
      _Stream,
    );
  }

  late final _fwritePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.Void>, ffi.Size,
              ffi.Size, ffi.Pointer<FILE>)>>('fwrite');
  late final _fwrite = _fwritePtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<FILE>)>();

  int getc(
    ffi.Pointer<FILE> _Stream,
  ) {
    return _getc(
      _Stream,
    );
  }

  late final _getcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('getc');
  late final _getc = _getcPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int getchar() {
    return _getchar();
  }

  late final _getcharPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('getchar');
  late final _getchar = _getcharPtr.asFunction<int Function()>();

  int _getmaxstdio() {
    return __getmaxstdio();
  }

  late final __getmaxstdioPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('_getmaxstdio');
  late final __getmaxstdio = __getmaxstdioPtr.asFunction<int Function()>();

  int _getw(
    ffi.Pointer<FILE> _Stream,
  ) {
    return __getw(
      _Stream,
    );
  }

  late final __getwPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('_getw');
  late final __getw = __getwPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  void perror(
    ffi.Pointer<ffi.Char> _ErrorMessage,
  ) {
    return _perror(
      _ErrorMessage,
    );
  }

  late final _perrorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'perror');
  late final _perror =
      _perrorPtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  int _pclose(
    ffi.Pointer<FILE> _Stream,
  ) {
    return __pclose(
      _Stream,
    );
  }

  late final __pclosePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          '_pclose');
  late final __pclose =
      __pclosePtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> _popen(
    ffi.Pointer<ffi.Char> _Command,
    ffi.Pointer<ffi.Char> _Mode,
  ) {
    return __popen(
      _Command,
      _Mode,
    );
  }

  late final __popenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('_popen');
  late final __popen = __popenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int putc(
    int _Character,
    ffi.Pointer<FILE> _Stream,
  ) {
    return _putc(
      _Character,
      _Stream,
    );
  }

  late final _putcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'putc');
  late final _putc =
      _putcPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int putchar(
    int _Character,
  ) {
    return _putchar(
      _Character,
    );
  }

  late final _putcharPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('putchar');
  late final _putchar = _putcharPtr.asFunction<int Function(int)>();

  int puts(
    ffi.Pointer<ffi.Char> _Buffer,
  ) {
    return _puts(
      _Buffer,
    );
  }

  late final _putsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'puts');
  late final _puts = _putsPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int _putw(
    int _Word,
    ffi.Pointer<FILE> _Stream,
  ) {
    return __putw(
      _Word,
      _Stream,
    );
  }

  late final __putwPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          '_putw');
  late final __putw =
      __putwPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int remove(
    ffi.Pointer<ffi.Char> _FileName,
  ) {
    return _remove(
      _FileName,
    );
  }

  late final _removePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'remove');
  late final _remove =
      _removePtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int rename(
    ffi.Pointer<ffi.Char> _OldFileName,
    ffi.Pointer<ffi.Char> _NewFileName,
  ) {
    return _rename(
      _OldFileName,
      _NewFileName,
    );
  }

  late final _renamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('rename');
  late final _rename = _renamePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int _unlink(
    ffi.Pointer<ffi.Char> _FileName,
  ) {
    return __unlink(
      _FileName,
    );
  }

  late final __unlinkPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          '_unlink');
  late final __unlink =
      __unlinkPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int unlink(
    ffi.Pointer<ffi.Char> _FileName,
  ) {
    return _unlink1(
      _FileName,
    );
  }

  late final _unlinkPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'unlink');
  late final _unlink1 =
      _unlinkPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  void rewind(
    ffi.Pointer<FILE> _Stream,
  ) {
    return _rewind(
      _Stream,
    );
  }

  late final _rewindPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'rewind');
  late final _rewind =
      _rewindPtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int _rmtmp() {
    return __rmtmp();
  }

  late final __rmtmpPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('_rmtmp');
  late final __rmtmp = __rmtmpPtr.asFunction<int Function()>();

  void setbuf(
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.Char> _Buffer,
  ) {
    return _setbuf(
      _Stream,
      _Buffer,
    );
  }

  late final _setbufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>>('setbuf');
  late final _setbuf = _setbufPtr
      .asFunction<void Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>();

  int _setmaxstdio(
    int _Maximum,
  ) {
    return __setmaxstdio(
      _Maximum,
    );
  }

  late final __setmaxstdioPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('_setmaxstdio');
  late final __setmaxstdio = __setmaxstdioPtr.asFunction<int Function(int)>();

  int setvbuf(
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.Char> _Buffer,
    int _Mode,
    int _Size,
  ) {
    return _setvbuf(
      _Stream,
      _Buffer,
      _Mode,
      _Size,
    );
  }

  late final _setvbufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Size)>>('setvbuf');
  late final _setvbuf = _setvbufPtr.asFunction<
      int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, int, int)>();

  ffi.Pointer<ffi.Char> _tempnam(
    ffi.Pointer<ffi.Char> _DirectoryName,
    ffi.Pointer<ffi.Char> _FilePrefix,
  ) {
    return __tempnam(
      _DirectoryName,
      _FilePrefix,
    );
  }

  late final __tempnamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('_tempnam');
  late final __tempnam = __tempnamPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<FILE> tmpfile() {
    return _tmpfile();
  }

  late final _tmpfilePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<FILE> Function()>>('tmpfile');
  late final _tmpfile = _tmpfilePtr.asFunction<ffi.Pointer<FILE> Function()>();

  ffi.Pointer<ffi.Char> tmpnam(
    ffi.Pointer<ffi.Char> _Buffer,
  ) {
    return _tmpnam(
      _Buffer,
    );
  }

  late final _tmpnamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('tmpnam');
  late final _tmpnam = _tmpnamPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int ungetc(
    int _Character,
    ffi.Pointer<FILE> _Stream,
  ) {
    return _ungetc(
      _Character,
      _Stream,
    );
  }

  late final _ungetcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'ungetc');
  late final _ungetc =
      _ungetcPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  void _lock_file(
    ffi.Pointer<FILE> _Stream,
  ) {
    return __lock_file(
      _Stream,
    );
  }

  late final __lock_filePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          '_lock_file');
  late final __lock_file =
      __lock_filePtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  void _unlock_file(
    ffi.Pointer<FILE> _Stream,
  ) {
    return __unlock_file(
      _Stream,
    );
  }

  late final __unlock_filePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          '_unlock_file');
  late final __unlock_file =
      __unlock_filePtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int _fclose_nolock(
    ffi.Pointer<FILE> _Stream,
  ) {
    return __fclose_nolock(
      _Stream,
    );
  }

  late final __fclose_nolockPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          '_fclose_nolock');
  late final __fclose_nolock =
      __fclose_nolockPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int _fflush_nolock(
    ffi.Pointer<FILE> _Stream,
  ) {
    return __fflush_nolock(
      _Stream,
    );
  }

  late final __fflush_nolockPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          '_fflush_nolock');
  late final __fflush_nolock =
      __fflush_nolockPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int _fgetc_nolock(
    ffi.Pointer<FILE> _Stream,
  ) {
    return __fgetc_nolock(
      _Stream,
    );
  }

  late final __fgetc_nolockPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          '_fgetc_nolock');
  late final __fgetc_nolock =
      __fgetc_nolockPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int _fputc_nolock(
    int _Character,
    ffi.Pointer<FILE> _Stream,
  ) {
    return __fputc_nolock(
      _Character,
      _Stream,
    );
  }

  late final __fputc_nolockPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          '_fputc_nolock');
  late final __fputc_nolock =
      __fputc_nolockPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int _fread_nolock(
    ffi.Pointer<ffi.Void> _Buffer,
    int _ElementSize,
    int _ElementCount,
    ffi.Pointer<FILE> _Stream,
  ) {
    return __fread_nolock(
      _Buffer,
      _ElementSize,
      _ElementCount,
      _Stream,
    );
  }

  late final __fread_nolockPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size,
              ffi.Pointer<FILE>)>>('_fread_nolock');
  late final __fread_nolock = __fread_nolockPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<FILE>)>();

  int _fread_nolock_s(
    ffi.Pointer<ffi.Void> _Buffer,
    int _BufferSize,
    int _ElementSize,
    int _ElementCount,
    ffi.Pointer<FILE> _Stream,
  ) {
    return __fread_nolock_s(
      _Buffer,
      _BufferSize,
      _ElementSize,
      _ElementCount,
      _Stream,
    );
  }

  late final __fread_nolock_sPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size, ffi.Size,
              ffi.Pointer<FILE>)>>('_fread_nolock_s');
  late final __fread_nolock_s = __fread_nolock_sPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int, int, ffi.Pointer<FILE>)>();

  int _fseek_nolock(
    ffi.Pointer<FILE> _Stream,
    int _Offset,
    int _Origin,
  ) {
    return __fseek_nolock(
      _Stream,
      _Offset,
      _Origin,
    );
  }

  late final __fseek_nolockPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FILE>, ffi.Long, ffi.Int)>>('_fseek_nolock');
  late final __fseek_nolock =
      __fseek_nolockPtr.asFunction<int Function(ffi.Pointer<FILE>, int, int)>();

  int _fseeki64_nolock(
    ffi.Pointer<FILE> _Stream,
    int _Offset,
    int _Origin,
  ) {
    return __fseeki64_nolock(
      _Stream,
      _Offset,
      _Origin,
    );
  }

  late final __fseeki64_nolockPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FILE>, ffi.LongLong, ffi.Int)>>('_fseeki64_nolock');
  late final __fseeki64_nolock = __fseeki64_nolockPtr
      .asFunction<int Function(ffi.Pointer<FILE>, int, int)>();

  int _ftell_nolock(
    ffi.Pointer<FILE> _Stream,
  ) {
    return __ftell_nolock(
      _Stream,
    );
  }

  late final __ftell_nolockPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<FILE>)>>(
          '_ftell_nolock');
  late final __ftell_nolock =
      __ftell_nolockPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int _ftelli64_nolock(
    ffi.Pointer<FILE> _Stream,
  ) {
    return __ftelli64_nolock(
      _Stream,
    );
  }

  late final __ftelli64_nolockPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Pointer<FILE>)>>(
          '_ftelli64_nolock');
  late final __ftelli64_nolock =
      __ftelli64_nolockPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int _fwrite_nolock(
    ffi.Pointer<ffi.Void> _Buffer,
    int _ElementSize,
    int _ElementCount,
    ffi.Pointer<FILE> _Stream,
  ) {
    return __fwrite_nolock(
      _Buffer,
      _ElementSize,
      _ElementCount,
      _Stream,
    );
  }

  late final __fwrite_nolockPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size,
              ffi.Pointer<FILE>)>>('_fwrite_nolock');
  late final __fwrite_nolock = __fwrite_nolockPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<FILE>)>();

  int _getc_nolock(
    ffi.Pointer<FILE> _Stream,
  ) {
    return __getc_nolock(
      _Stream,
    );
  }

  late final __getc_nolockPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          '_getc_nolock');
  late final __getc_nolock =
      __getc_nolockPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int _putc_nolock(
    int _Character,
    ffi.Pointer<FILE> _Stream,
  ) {
    return __putc_nolock(
      _Character,
      _Stream,
    );
  }

  late final __putc_nolockPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          '_putc_nolock');
  late final __putc_nolock =
      __putc_nolockPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int _ungetc_nolock(
    int _Character,
    ffi.Pointer<FILE> _Stream,
  ) {
    return __ungetc_nolock(
      _Character,
      _Stream,
    );
  }

  late final __ungetc_nolockPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          '_ungetc_nolock');
  late final __ungetc_nolock =
      __ungetc_nolockPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  ffi.Pointer<ffi.Int> __p__commode() {
    return ___p__commode();
  }

  late final ___p__commodePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int> Function()>>(
          '__p__commode');
  late final ___p__commode =
      ___p__commodePtr.asFunction<ffi.Pointer<ffi.Int> Function()>();

  int __stdio_common_vfprintf(
    int _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vfprintf(
      _Options,
      _Stream,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vfprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedLongLong,
              ffi.Pointer<FILE>,
              ffi.Pointer<ffi.Char>,
              _locale_t,
              va_list)>>('__stdio_common_vfprintf');
  late final ___stdio_common_vfprintf = ___stdio_common_vfprintfPtr.asFunction<
      int Function(
          int, ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, _locale_t, va_list)>();

  int __stdio_common_vfprintf_s(
    int _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vfprintf_s(
      _Options,
      _Stream,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vfprintf_sPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedLongLong,
              ffi.Pointer<FILE>,
              ffi.Pointer<ffi.Char>,
              _locale_t,
              va_list)>>('__stdio_common_vfprintf_s');
  late final ___stdio_common_vfprintf_s =
      ___stdio_common_vfprintf_sPtr.asFunction<
          int Function(int, ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, _locale_t,
              va_list)>();

  int __stdio_common_vfprintf_p(
    int _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vfprintf_p(
      _Options,
      _Stream,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vfprintf_pPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedLongLong,
              ffi.Pointer<FILE>,
              ffi.Pointer<ffi.Char>,
              _locale_t,
              va_list)>>('__stdio_common_vfprintf_p');
  late final ___stdio_common_vfprintf_p =
      ___stdio_common_vfprintf_pPtr.asFunction<
          int Function(int, ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, _locale_t,
              va_list)>();

  int _set_printf_count_output(
    int _Value,
  ) {
    return __set_printf_count_output(
      _Value,
    );
  }

  late final __set_printf_count_outputPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          '_set_printf_count_output');
  late final __set_printf_count_output =
      __set_printf_count_outputPtr.asFunction<int Function(int)>();

  int _get_printf_count_output() {
    return __get_printf_count_output();
  }

  late final __get_printf_count_outputPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>(
          '_get_printf_count_output');
  late final __get_printf_count_output =
      __get_printf_count_outputPtr.asFunction<int Function()>();

  int __stdio_common_vfscanf(
    int _Options,
    ffi.Pointer<FILE> _Stream,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _Arglist,
  ) {
    return ___stdio_common_vfscanf(
      _Options,
      _Stream,
      _Format,
      _Locale,
      _Arglist,
    );
  }

  late final ___stdio_common_vfscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedLongLong,
              ffi.Pointer<FILE>,
              ffi.Pointer<ffi.Char>,
              _locale_t,
              va_list)>>('__stdio_common_vfscanf');
  late final ___stdio_common_vfscanf = ___stdio_common_vfscanfPtr.asFunction<
      int Function(
          int, ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, _locale_t, va_list)>();

  int __stdio_common_vsprintf(
    int _Options,
    ffi.Pointer<ffi.Char> _Buffer,
    int _BufferCount,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vsprintf(
      _Options,
      _Buffer,
      _BufferCount,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vsprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedLongLong,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<ffi.Char>,
              _locale_t,
              va_list)>>('__stdio_common_vsprintf');
  late final ___stdio_common_vsprintf = ___stdio_common_vsprintfPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>,
          _locale_t, va_list)>();

  int __stdio_common_vsprintf_s(
    int _Options,
    ffi.Pointer<ffi.Char> _Buffer,
    int _BufferCount,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vsprintf_s(
      _Options,
      _Buffer,
      _BufferCount,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vsprintf_sPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedLongLong,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<ffi.Char>,
              _locale_t,
              va_list)>>('__stdio_common_vsprintf_s');
  late final ___stdio_common_vsprintf_s =
      ___stdio_common_vsprintf_sPtr.asFunction<
          int Function(int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>,
              _locale_t, va_list)>();

  int __stdio_common_vsnprintf_s(
    int _Options,
    ffi.Pointer<ffi.Char> _Buffer,
    int _BufferCount,
    int _MaxCount,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vsnprintf_s(
      _Options,
      _Buffer,
      _BufferCount,
      _MaxCount,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vsnprintf_sPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedLongLong,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<ffi.Char>,
              _locale_t,
              va_list)>>('__stdio_common_vsnprintf_s');
  late final ___stdio_common_vsnprintf_s =
      ___stdio_common_vsnprintf_sPtr.asFunction<
          int Function(int, ffi.Pointer<ffi.Char>, int, int,
              ffi.Pointer<ffi.Char>, _locale_t, va_list)>();

  int __stdio_common_vsprintf_p(
    int _Options,
    ffi.Pointer<ffi.Char> _Buffer,
    int _BufferCount,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vsprintf_p(
      _Options,
      _Buffer,
      _BufferCount,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vsprintf_pPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedLongLong,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<ffi.Char>,
              _locale_t,
              va_list)>>('__stdio_common_vsprintf_p');
  late final ___stdio_common_vsprintf_p =
      ___stdio_common_vsprintf_pPtr.asFunction<
          int Function(int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>,
              _locale_t, va_list)>();

  int __stdio_common_vsscanf(
    int _Options,
    ffi.Pointer<ffi.Char> _Buffer,
    int _BufferCount,
    ffi.Pointer<ffi.Char> _Format,
    _locale_t _Locale,
    va_list _ArgList,
  ) {
    return ___stdio_common_vsscanf(
      _Options,
      _Buffer,
      _BufferCount,
      _Format,
      _Locale,
      _ArgList,
    );
  }

  late final ___stdio_common_vsscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedLongLong,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<ffi.Char>,
              _locale_t,
              va_list)>>('__stdio_common_vsscanf');
  late final ___stdio_common_vsscanf = ___stdio_common_vsscanfPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>,
          _locale_t, va_list)>();

  ffi.Pointer<ffi.Char> tempnam(
    ffi.Pointer<ffi.Char> _Directory,
    ffi.Pointer<ffi.Char> _FilePrefix,
  ) {
    return _tempnam1(
      _Directory,
      _FilePrefix,
    );
  }

  late final _tempnamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('tempnam');
  late final _tempnam1 = _tempnamPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int fcloseall() {
    return _fcloseall1();
  }

  late final _fcloseallPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('fcloseall');
  late final _fcloseall1 = _fcloseallPtr.asFunction<int Function()>();

  ffi.Pointer<FILE> fdopen(
    int _FileHandle,
    ffi.Pointer<ffi.Char> _Format,
  ) {
    return _fdopen1(
      _FileHandle,
      _Format,
    );
  }

  late final _fdopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Int, ffi.Pointer<ffi.Char>)>>('fdopen');
  late final _fdopen1 = _fdopenPtr
      .asFunction<ffi.Pointer<FILE> Function(int, ffi.Pointer<ffi.Char>)>();

  int fgetchar() {
    return _fgetchar1();
  }

  late final _fgetcharPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('fgetchar');
  late final _fgetchar1 = _fgetcharPtr.asFunction<int Function()>();

  int fileno(
    ffi.Pointer<FILE> _Stream,
  ) {
    return _fileno1(
      _Stream,
    );
  }

  late final _filenoPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fileno');
  late final _fileno1 =
      _filenoPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int flushall() {
    return _flushall1();
  }

  late final _flushallPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('flushall');
  late final _flushall1 = _flushallPtr.asFunction<int Function()>();

  int fputchar(
    int _Ch,
  ) {
    return _fputchar1(
      _Ch,
    );
  }

  late final _fputcharPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('fputchar');
  late final _fputchar1 = _fputcharPtr.asFunction<int Function(int)>();

  int getw(
    ffi.Pointer<FILE> _Stream,
  ) {
    return _getw1(
      _Stream,
    );
  }

  late final _getwPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('getw');
  late final _getw1 = _getwPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int putw(
    int _Ch,
    ffi.Pointer<FILE> _Stream,
  ) {
    return _putw1(
      _Ch,
      _Stream,
    );
  }

  late final _putwPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'putw');
  late final _putw1 =
      _putwPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int rmtmp() {
    return _rmtmp1();
  }

  late final _rmtmpPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('rmtmp');
  late final _rmtmp1 = _rmtmpPtr.asFunction<int Function()>();

  /// @{*/
  /// /**
  /// \brief Set a global (or module) parameter.
  /// This setting is shared by all Z3 contexts.
  ///
  /// When a Z3 module is initialized it will use the value of these parameters
  /// when Z3_params objects are not provided.
  ///
  /// The name of parameter can be composed of characters [a-z][A-Z], digits [0-9], '-' and '_'.
  /// The character '.' is a delimiter (more later).
  ///
  /// The parameter names are case-insensitive. The character '-' should be viewed as an "alias" for '_'.
  /// Thus, the following parameter names are considered equivalent: "pp.decimal-precision"  and "PP.DECIMAL_PRECISION".
  ///
  /// This function can be used to set parameters for a specific Z3 module.
  /// This can be done by using <module-name>.<parameter-name>.
  /// For example:
  /// Z3_global_param_set('pp.decimal', 'true')
  /// will set the parameter "decimal" in the module "pp" to true.
  ///
  /// \sa Z3_global_param_get
  /// \sa Z3_global_param_reset_all
  ///
  /// def_API('Z3_global_param_set', VOID, (_in(STRING), _in(STRING)))
  void global_param_set(
    Z3_string param_id,
    Z3_string param_value,
  ) {
    return _global_param_set(
      param_id,
      param_value,
    );
  }

  late final _global_param_setPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_string, Z3_string)>>(
          'Z3_global_param_set');
  late final _global_param_set =
      _global_param_setPtr.asFunction<void Function(Z3_string, Z3_string)>();

  /// \brief Restore the value of all global (and module) parameters.
  /// This command will not affect already created objects (such as tactics and solvers).
  ///
  /// \sa Z3_global_param_get
  /// \sa Z3_global_param_set
  ///
  /// def_API('Z3_global_param_reset_all', VOID, ())
  void global_param_reset_all() {
    return _global_param_reset_all();
  }

  late final _global_param_reset_allPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'Z3_global_param_reset_all');
  late final _global_param_reset_all =
      _global_param_reset_allPtr.asFunction<void Function()>();

  /// \brief Get a global (or module) parameter.
  ///
  /// Returns \c false if the parameter value does not exist.
  ///
  /// \sa Z3_global_param_reset_all
  /// \sa Z3_global_param_set
  ///
  /// \remark This function cannot be invoked simultaneously from different threads without synchronization.
  /// The result string stored in param_value is stored in shared location.
  ///
  /// def_API('Z3_global_param_get', BOOL, (_in(STRING), _out(STRING)))
  bool global_param_get(
    Z3_string param_id,
    Z3_string_ptr param_value,
  ) {
    return _global_param_get(
      param_id,
      param_value,
    );
  }

  late final _global_param_getPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Z3_string, Z3_string_ptr)>>(
          'Z3_global_param_get');
  late final _global_param_get = _global_param_getPtr
      .asFunction<bool Function(Z3_string, Z3_string_ptr)>();

  /// \brief Create a configuration object for the Z3 context object.
  ///
  /// Configurations are created in order to assign parameters prior to creating
  /// contexts for Z3 interaction. For example, if the users wishes to use proof
  /// generation, then call:
  ///
  /// \ccode{Z3_set_param_value(cfg\, "proof"\, "true")}
  ///
  /// \remark In previous versions of Z3, the \c Z3_config was used to store
  /// global and module configurations. Now, we should use \c Z3_global_param_set.
  ///
  /// The following parameters can be set:
  ///
  /// - proof  (Boolean)           Enable proof generation
  /// - debug_ref_count (Boolean)  Enable debug support for Z3_ast reference counting
  /// - trace  (Boolean)           Tracing support for VCC
  /// - trace_file_name (String)   Trace out file for VCC traces
  /// - timeout (unsigned)         default timeout (in milliseconds) used for solvers
  /// - well_sorted_check          type checker
  /// - auto_config                use heuristics to automatically select solver and configure it
  /// - model                      model generation for solvers, this parameter can be overwritten when creating a solver
  /// - model_validate             validate models produced by solvers
  /// - unsat_core                 unsat-core generation for solvers, this parameter can be overwritten when creating a solver
  /// - encoding                   the string encoding used internally (must be either "unicode" - 18 bit, "bmp" - 16 bit or "ascii" - 8 bit)
  ///
  /// \sa Z3_set_param_value
  /// \sa Z3_del_config
  ///
  /// def_API('Z3_mk_config', CONFIG, ())
  Z3_config mk_config() {
    return _mk_config();
  }

  late final _mk_configPtr =
      _lookup<ffi.NativeFunction<Z3_config Function()>>('Z3_mk_config');
  late final _mk_config = _mk_configPtr.asFunction<Z3_config Function()>();

  /// \brief Delete the given configuration object.
  ///
  /// \sa Z3_mk_config
  ///
  /// def_API('Z3_del_config', VOID, (_in(CONFIG),))
  void del_config(
    Z3_config c,
  ) {
    return _del_config(
      c,
    );
  }

  late final _del_configPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_config)>>(
          'Z3_del_config');
  late final _del_config =
      _del_configPtr.asFunction<void Function(Z3_config)>();

  /// \brief Set a configuration parameter.
  ///
  /// The following parameters can be set for
  ///
  /// \sa Z3_mk_config
  ///
  /// def_API('Z3_set_param_value', VOID, (_in(CONFIG), _in(STRING), _in(STRING)))
  void set_param_value(
    Z3_config c,
    Z3_string param_id,
    Z3_string param_value,
  ) {
    return _set_param_value(
      c,
      param_id,
      param_value,
    );
  }

  late final _set_param_valuePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(Z3_config, Z3_string, Z3_string)>>(
      'Z3_set_param_value');
  late final _set_param_value = _set_param_valuePtr
      .asFunction<void Function(Z3_config, Z3_string, Z3_string)>();

  /// \brief Create a context using the given configuration.
  ///
  /// After a context is created, the configuration cannot be changed,
  /// although some parameters can be changed using #Z3_update_param_value.
  /// All main interaction with Z3 happens in the context of a \c Z3_context.
  ///
  /// In contrast to #Z3_mk_context_rc, the life time of \c Z3_ast objects
  /// are determined by the scope level of #Z3_solver_push and #Z3_solver_pop.
  /// In other words, a \c Z3_ast object remains valid until there is a
  /// call to #Z3_solver_pop that takes the current scope below the level where
  /// the object was created.
  ///
  /// Note that all other reference counted objects, including \c Z3_model,
  /// \c Z3_solver, \c Z3_func_interp have to be managed by the caller.
  /// Their reference counts are not handled by the context.
  ///
  /// \remark Thread safety: objects created using a given context should not be
  /// accessed from different threads without synchronization. In other words,
  /// operations on a context are not thread safe. To use Z3 from different threads
  /// create separate context objects. The \c Z3_translate, \c Z3_solver_translate,
  /// \c Z3_model_translate, \c Z3_goal_translate
  /// methods are exposed to allow copying state from one context to another.
  ///
  /// \remark
  /// - \c Z3_sort, \c Z3_func_decl, \c Z3_app, \c Z3_pattern are \c Z3_ast's.
  /// - Z3 uses hash-consing, i.e., when the same \c Z3_ast is created twice,
  /// Z3 will return the same pointer twice.
  ///
  /// \sa Z3_del_context
  ///
  /// def_API('Z3_mk_context', CONTEXT, (_in(CONFIG),))
  Z3_context mk_context(
    Z3_config c,
  ) {
    return _mk_context(
      c,
    );
  }

  late final _mk_contextPtr =
      _lookup<ffi.NativeFunction<Z3_context Function(Z3_config)>>(
          'Z3_mk_context');
  late final _mk_context =
      _mk_contextPtr.asFunction<Z3_context Function(Z3_config)>();

  /// \brief Create a context using the given configuration.
  /// This function is similar to #Z3_mk_context. However,
  /// in the context returned by this function, the user
  /// is responsible for managing \c Z3_ast reference counters.
  /// Managing reference counters is a burden and error-prone,
  /// but allows the user to use the memory more efficiently.
  /// The user must invoke #Z3_inc_ref for any \c Z3_ast returned
  /// by Z3, and #Z3_dec_ref whenever the \c Z3_ast is not needed
  /// anymore. This idiom is similar to the one used in
  /// BDD (binary decision diagrams) packages such as CUDD.
  ///
  /// Remarks:
  ///
  /// - \c Z3_sort, \c Z3_func_decl, \c Z3_app, \c Z3_pattern are \c Z3_ast's.
  /// - After a context is created, the configuration cannot be changed.
  /// - All main interaction with Z3 happens in the context of a \c Z3_context.
  /// - Z3 uses hash-consing, i.e., when the same \c Z3_ast is created twice,
  /// Z3 will return the same pointer twice.
  ///
  /// def_API('Z3_mk_context_rc', CONTEXT, (_in(CONFIG),))
  Z3_context mk_context_rc(
    Z3_config c,
  ) {
    return _mk_context_rc(
      c,
    );
  }

  late final _mk_context_rcPtr =
      _lookup<ffi.NativeFunction<Z3_context Function(Z3_config)>>(
          'Z3_mk_context_rc');
  late final _mk_context_rc =
      _mk_context_rcPtr.asFunction<Z3_context Function(Z3_config)>();

  /// \brief Delete the given logical context.
  ///
  /// \sa Z3_mk_context
  ///
  /// def_API('Z3_del_context', VOID, (_in(CONTEXT),))
  void del_context(
    Z3_context c,
  ) {
    return _del_context(
      c,
    );
  }

  late final _del_contextPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context)>>(
          'Z3_del_context');
  late final _del_context =
      _del_contextPtr.asFunction<void Function(Z3_context)>();

  /// \brief Increment the reference counter of the given AST.
  /// The context \c c should have been created using #Z3_mk_context_rc.
  /// This function is a NOOP if \c c was created using #Z3_mk_context.
  ///
  /// def_API('Z3_inc_ref', VOID, (_in(CONTEXT), _in(AST)))
  void inc_ref(
    Z3_context c,
    Z3_ast a,
  ) {
    return _inc_ref(
      c,
      a,
    );
  }

  late final _inc_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_ast)>>(
          'Z3_inc_ref');
  late final _inc_ref =
      _inc_refPtr.asFunction<void Function(Z3_context, Z3_ast)>();

  /// \brief Decrement the reference counter of the given AST.
  /// The context \c c should have been created using #Z3_mk_context_rc.
  /// This function is a NOOP if \c c was created using #Z3_mk_context.
  ///
  /// def_API('Z3_dec_ref', VOID, (_in(CONTEXT), _in(AST)))
  void dec_ref(
    Z3_context c,
    Z3_ast a,
  ) {
    return _dec_ref(
      c,
      a,
    );
  }

  late final _dec_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_ast)>>(
          'Z3_dec_ref');
  late final _dec_ref =
      _dec_refPtr.asFunction<void Function(Z3_context, Z3_ast)>();

  /// \brief Set a value of a context parameter.
  ///
  /// \sa Z3_global_param_set
  ///
  /// def_API('Z3_update_param_value', VOID, (_in(CONTEXT), _in(STRING), _in(STRING)))
  void update_param_value(
    Z3_context c,
    Z3_string param_id,
    Z3_string param_value,
  ) {
    return _update_param_value(
      c,
      param_id,
      param_value,
    );
  }

  late final _update_param_valuePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(Z3_context, Z3_string, Z3_string)>>(
      'Z3_update_param_value');
  late final _update_param_value = _update_param_valuePtr
      .asFunction<void Function(Z3_context, Z3_string, Z3_string)>();

  /// \brief Retrieve description of global parameters.
  ///
  /// def_API('Z3_get_global_param_descrs', PARAM_DESCRS, (_in(CONTEXT),))
  Z3_param_descrs get_global_param_descrs(
    Z3_context c,
  ) {
    return _get_global_param_descrs(
      c,
    );
  }

  late final _get_global_param_descrsPtr =
      _lookup<ffi.NativeFunction<Z3_param_descrs Function(Z3_context)>>(
          'Z3_get_global_param_descrs');
  late final _get_global_param_descrs = _get_global_param_descrsPtr
      .asFunction<Z3_param_descrs Function(Z3_context)>();

  /// \brief Interrupt the execution of a Z3 procedure.
  /// This procedure can be used to interrupt: solvers, simplifiers and tactics.
  ///
  /// def_API('Z3_interrupt', VOID, (_in(CONTEXT),))
  void interrupt(
    Z3_context c,
  ) {
    return _interrupt(
      c,
    );
  }

  late final _interruptPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context)>>(
          'Z3_interrupt');
  late final _interrupt = _interruptPtr.asFunction<void Function(Z3_context)>();

  /// \brief use concurrency control for dec-ref.
  /// Reference counting decrements are allowed in separate threads from the context.
  /// If this setting is not invoked, reference counting decrements are not going to be thread safe.
  ///
  /// def_API('Z3_enable_concurrent_dec_ref', VOID, (_in(CONTEXT),))
  void enable_concurrent_dec_ref(
    Z3_context c,
  ) {
    return _enable_concurrent_dec_ref(
      c,
    );
  }

  late final _enable_concurrent_dec_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context)>>(
          'Z3_enable_concurrent_dec_ref');
  late final _enable_concurrent_dec_ref =
      _enable_concurrent_dec_refPtr.asFunction<void Function(Z3_context)>();

  /// \brief Create a Z3 (empty) parameter set.
  /// Starting at Z3 4.0, parameter sets are used to configure many components such as:
  /// simplifiers, tactics, solvers, etc.
  ///
  /// \remark Reference counting must be used to manage parameter sets, even when the \c Z3_context was
  /// created using #Z3_mk_context instead of #Z3_mk_context_rc.
  ///
  /// def_API('Z3_mk_params', PARAMS, (_in(CONTEXT),))
  Z3_params mk_params(
    Z3_context c,
  ) {
    return _mk_params(
      c,
    );
  }

  late final _mk_paramsPtr =
      _lookup<ffi.NativeFunction<Z3_params Function(Z3_context)>>(
          'Z3_mk_params');
  late final _mk_params =
      _mk_paramsPtr.asFunction<Z3_params Function(Z3_context)>();

  /// \brief Increment the reference counter of the given parameter set.
  ///
  /// def_API('Z3_params_inc_ref', VOID, (_in(CONTEXT), _in(PARAMS)))
  void params_inc_ref(
    Z3_context c,
    Z3_params p,
  ) {
    return _params_inc_ref(
      c,
      p,
    );
  }

  late final _params_inc_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_params)>>(
          'Z3_params_inc_ref');
  late final _params_inc_ref =
      _params_inc_refPtr.asFunction<void Function(Z3_context, Z3_params)>();

  /// \brief Decrement the reference counter of the given parameter set.
  ///
  /// def_API('Z3_params_dec_ref', VOID, (_in(CONTEXT), _in(PARAMS)))
  void params_dec_ref(
    Z3_context c,
    Z3_params p,
  ) {
    return _params_dec_ref(
      c,
      p,
    );
  }

  late final _params_dec_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_params)>>(
          'Z3_params_dec_ref');
  late final _params_dec_ref =
      _params_dec_refPtr.asFunction<void Function(Z3_context, Z3_params)>();

  /// \brief Add a Boolean parameter \c k with value \c v to the parameter set \c p.
  ///
  /// def_API('Z3_params_set_bool', VOID, (_in(CONTEXT), _in(PARAMS), _in(SYMBOL), _in(BOOL)))
  void params_set_bool(
    Z3_context c,
    Z3_params p,
    Z3_symbol k,
    bool v,
  ) {
    return _params_set_bool(
      c,
      p,
      k,
      v,
    );
  }

  late final _params_set_boolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_params, Z3_symbol,
              ffi.Bool)>>('Z3_params_set_bool');
  late final _params_set_bool = _params_set_boolPtr
      .asFunction<void Function(Z3_context, Z3_params, Z3_symbol, bool)>();

  /// \brief Add a unsigned parameter \c k with value \c v to the parameter set \c p.
  ///
  /// def_API('Z3_params_set_uint', VOID, (_in(CONTEXT), _in(PARAMS), _in(SYMBOL), _in(UINT)))
  void params_set_uint(
    Z3_context c,
    Z3_params p,
    Z3_symbol k,
    int v,
  ) {
    return _params_set_uint(
      c,
      p,
      k,
      v,
    );
  }

  late final _params_set_uintPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_params, Z3_symbol,
              ffi.UnsignedInt)>>('Z3_params_set_uint');
  late final _params_set_uint = _params_set_uintPtr
      .asFunction<void Function(Z3_context, Z3_params, Z3_symbol, int)>();

  /// \brief Add a double parameter \c k with value \c v to the parameter set \c p.
  ///
  /// def_API('Z3_params_set_double', VOID, (_in(CONTEXT), _in(PARAMS), _in(SYMBOL), _in(DOUBLE)))
  void params_set_double(
    Z3_context c,
    Z3_params p,
    Z3_symbol k,
    double v,
  ) {
    return _params_set_double(
      c,
      p,
      k,
      v,
    );
  }

  late final _params_set_doublePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_params, Z3_symbol,
              ffi.Double)>>('Z3_params_set_double');
  late final _params_set_double = _params_set_doublePtr
      .asFunction<void Function(Z3_context, Z3_params, Z3_symbol, double)>();

  /// \brief Add a symbol parameter \c k with value \c v to the parameter set \c p.
  ///
  /// def_API('Z3_params_set_symbol', VOID, (_in(CONTEXT), _in(PARAMS), _in(SYMBOL), _in(SYMBOL)))
  void params_set_symbol(
    Z3_context c,
    Z3_params p,
    Z3_symbol k,
    Z3_symbol v,
  ) {
    return _params_set_symbol(
      c,
      p,
      k,
      v,
    );
  }

  late final _params_set_symbolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_params, Z3_symbol,
              Z3_symbol)>>('Z3_params_set_symbol');
  late final _params_set_symbol = _params_set_symbolPtr
      .asFunction<void Function(Z3_context, Z3_params, Z3_symbol, Z3_symbol)>();

  /// \brief Convert a parameter set into a string. This function is mainly used for printing the
  /// contents of a parameter set.
  ///
  /// def_API('Z3_params_to_string', STRING, (_in(CONTEXT), _in(PARAMS)))
  Z3_string params_to_string(
    Z3_context c,
    Z3_params p,
  ) {
    return _params_to_string(
      c,
      p,
    );
  }

  late final _params_to_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_params)>>(
          'Z3_params_to_string');
  late final _params_to_string = _params_to_stringPtr
      .asFunction<Z3_string Function(Z3_context, Z3_params)>();

  /// \brief Validate the parameter set \c p against the parameter description set \c d.
  ///
  /// The procedure invokes the error handler if \c p is invalid.
  ///
  /// def_API('Z3_params_validate', VOID, (_in(CONTEXT), _in(PARAMS), _in(PARAM_DESCRS)))
  void params_validate(
    Z3_context c,
    Z3_params p,
    Z3_param_descrs d,
  ) {
    return _params_validate(
      c,
      p,
      d,
    );
  }

  late final _params_validatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context, Z3_params, Z3_param_descrs)>>('Z3_params_validate');
  late final _params_validate = _params_validatePtr
      .asFunction<void Function(Z3_context, Z3_params, Z3_param_descrs)>();

  /// \brief Increment the reference counter of the given parameter description set.
  ///
  /// def_API('Z3_param_descrs_inc_ref', VOID, (_in(CONTEXT), _in(PARAM_DESCRS)))
  void param_descrs_inc_ref(
    Z3_context c,
    Z3_param_descrs p,
  ) {
    return _param_descrs_inc_ref(
      c,
      p,
    );
  }

  late final _param_descrs_inc_refPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_param_descrs)>>(
      'Z3_param_descrs_inc_ref');
  late final _param_descrs_inc_ref = _param_descrs_inc_refPtr
      .asFunction<void Function(Z3_context, Z3_param_descrs)>();

  /// \brief Decrement the reference counter of the given parameter description set.
  ///
  /// def_API('Z3_param_descrs_dec_ref', VOID, (_in(CONTEXT), _in(PARAM_DESCRS)))
  void param_descrs_dec_ref(
    Z3_context c,
    Z3_param_descrs p,
  ) {
    return _param_descrs_dec_ref(
      c,
      p,
    );
  }

  late final _param_descrs_dec_refPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_param_descrs)>>(
      'Z3_param_descrs_dec_ref');
  late final _param_descrs_dec_ref = _param_descrs_dec_refPtr
      .asFunction<void Function(Z3_context, Z3_param_descrs)>();

  /// \brief Return the kind associated with the given parameter name \c n.
  ///
  /// def_API('Z3_param_descrs_get_kind', UINT, (_in(CONTEXT), _in(PARAM_DESCRS), _in(SYMBOL)))
  int param_descrs_get_kind(
    Z3_context c,
    Z3_param_descrs p,
    Z3_symbol n,
  ) {
    return _param_descrs_get_kind(
      c,
      p,
      n,
    );
  }

  late final _param_descrs_get_kindPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(Z3_context, Z3_param_descrs,
              Z3_symbol)>>('Z3_param_descrs_get_kind');
  late final _param_descrs_get_kind = _param_descrs_get_kindPtr
      .asFunction<int Function(Z3_context, Z3_param_descrs, Z3_symbol)>();

  /// \brief Return the number of parameters in the given parameter description set.
  ///
  /// def_API('Z3_param_descrs_size', UINT, (_in(CONTEXT), _in(PARAM_DESCRS)))
  int param_descrs_size(
    Z3_context c,
    Z3_param_descrs p,
  ) {
    return _param_descrs_size(
      c,
      p,
    );
  }

  late final _param_descrs_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              Z3_context, Z3_param_descrs)>>('Z3_param_descrs_size');
  late final _param_descrs_size = _param_descrs_sizePtr
      .asFunction<int Function(Z3_context, Z3_param_descrs)>();

  /// \brief Return the name of the parameter at given index \c i.
  ///
  /// \pre i < Z3_param_descrs_size(c, p)
  ///
  /// def_API('Z3_param_descrs_get_name', SYMBOL, (_in(CONTEXT), _in(PARAM_DESCRS), _in(UINT)))
  Z3_symbol param_descrs_get_name(
    Z3_context c,
    Z3_param_descrs p,
    int i,
  ) {
    return _param_descrs_get_name(
      c,
      p,
      i,
    );
  }

  late final _param_descrs_get_namePtr = _lookup<
      ffi.NativeFunction<
          Z3_symbol Function(Z3_context, Z3_param_descrs,
              ffi.UnsignedInt)>>('Z3_param_descrs_get_name');
  late final _param_descrs_get_name = _param_descrs_get_namePtr
      .asFunction<Z3_symbol Function(Z3_context, Z3_param_descrs, int)>();

  /// \brief Retrieve documentation string corresponding to parameter name \c s.
  ///
  /// def_API('Z3_param_descrs_get_documentation', STRING, (_in(CONTEXT), _in(PARAM_DESCRS), _in(SYMBOL)))
  Z3_string param_descrs_get_documentation(
    Z3_context c,
    Z3_param_descrs p,
    Z3_symbol s,
  ) {
    return _param_descrs_get_documentation(
      c,
      p,
      s,
    );
  }

  late final _param_descrs_get_documentationPtr = _lookup<
      ffi.NativeFunction<
          Z3_string Function(Z3_context, Z3_param_descrs,
              Z3_symbol)>>('Z3_param_descrs_get_documentation');
  late final _param_descrs_get_documentation =
      _param_descrs_get_documentationPtr.asFunction<
          Z3_string Function(Z3_context, Z3_param_descrs, Z3_symbol)>();

  /// \brief Convert a parameter description set into a string. This function is mainly used for printing the
  /// contents of a parameter description set.
  ///
  /// def_API('Z3_param_descrs_to_string', STRING, (_in(CONTEXT), _in(PARAM_DESCRS)))
  Z3_string param_descrs_to_string(
    Z3_context c,
    Z3_param_descrs p,
  ) {
    return _param_descrs_to_string(
      c,
      p,
    );
  }

  late final _param_descrs_to_stringPtr = _lookup<
          ffi.NativeFunction<Z3_string Function(Z3_context, Z3_param_descrs)>>(
      'Z3_param_descrs_to_string');
  late final _param_descrs_to_string = _param_descrs_to_stringPtr
      .asFunction<Z3_string Function(Z3_context, Z3_param_descrs)>();

  /// \brief Create a Z3 symbol using an integer.
  ///
  /// Symbols are used to name several term and type constructors.
  ///
  /// NB. Not all integers can be passed to this function.
  /// The legal range of unsigned integers is 0 to 2^30-1.
  ///
  /// \sa Z3_get_symbol_int
  /// \sa Z3_mk_string_symbol
  ///
  /// def_API('Z3_mk_int_symbol', SYMBOL, (_in(CONTEXT), _in(INT)))
  Z3_symbol mk_int_symbol(
    Z3_context c,
    int i,
  ) {
    return _mk_int_symbol(
      c,
      i,
    );
  }

  late final _mk_int_symbolPtr =
      _lookup<ffi.NativeFunction<Z3_symbol Function(Z3_context, ffi.Int)>>(
          'Z3_mk_int_symbol');
  late final _mk_int_symbol =
      _mk_int_symbolPtr.asFunction<Z3_symbol Function(Z3_context, int)>();

  /// \brief Create a Z3 symbol using a C string.
  ///
  /// Symbols are used to name several term and type constructors.
  ///
  /// \sa Z3_get_symbol_string
  /// \sa Z3_mk_int_symbol
  ///
  /// def_API('Z3_mk_string_symbol', SYMBOL, (_in(CONTEXT), _in(STRING)))
  Z3_symbol mk_string_symbol(
    Z3_context c,
    Z3_string s,
  ) {
    return _mk_string_symbol(
      c,
      s,
    );
  }

  late final _mk_string_symbolPtr =
      _lookup<ffi.NativeFunction<Z3_symbol Function(Z3_context, Z3_string)>>(
          'Z3_mk_string_symbol');
  late final _mk_string_symbol = _mk_string_symbolPtr
      .asFunction<Z3_symbol Function(Z3_context, Z3_string)>();

  /// \brief Create a free (uninterpreted) type using the given name (symbol).
  ///
  /// Two free types are considered the same iff the have the same name.
  ///
  /// def_API('Z3_mk_uninterpreted_sort', SORT, (_in(CONTEXT), _in(SYMBOL)))
  Z3_sort mk_uninterpreted_sort(
    Z3_context c,
    Z3_symbol s,
  ) {
    return _mk_uninterpreted_sort(
      c,
      s,
    );
  }

  late final _mk_uninterpreted_sortPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context, Z3_symbol)>>(
          'Z3_mk_uninterpreted_sort');
  late final _mk_uninterpreted_sort = _mk_uninterpreted_sortPtr
      .asFunction<Z3_sort Function(Z3_context, Z3_symbol)>();

  /// \brief Create a type variable.
  ///
  /// Functions using type variables can be applied to instantiations that match the signature
  /// of the function. Assertions using type variables correspond to assertions over all possible
  /// instantiations.
  ///
  /// def_API('Z3_mk_type_variable', SORT, (_in(CONTEXT), _in(SYMBOL)))
  Z3_sort mk_type_variable(
    Z3_context c,
    Z3_symbol s,
  ) {
    return _mk_type_variable(
      c,
      s,
    );
  }

  late final _mk_type_variablePtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context, Z3_symbol)>>(
          'Z3_mk_type_variable');
  late final _mk_type_variable = _mk_type_variablePtr
      .asFunction<Z3_sort Function(Z3_context, Z3_symbol)>();

  /// \brief Create the Boolean type.
  ///
  /// This type is used to create propositional variables and predicates.
  ///
  /// def_API('Z3_mk_bool_sort', SORT, (_in(CONTEXT), ))
  Z3_sort mk_bool_sort(
    Z3_context c,
  ) {
    return _mk_bool_sort(
      c,
    );
  }

  late final _mk_bool_sortPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context)>>(
          'Z3_mk_bool_sort');
  late final _mk_bool_sort =
      _mk_bool_sortPtr.asFunction<Z3_sort Function(Z3_context)>();

  /// \brief Create the integer type.
  ///
  /// This type is not the int type found in programming languages.
  /// A machine integer can be represented using bit-vectors. The function
  /// #Z3_mk_bv_sort creates a bit-vector type.
  ///
  /// \sa Z3_mk_bv_sort
  ///
  /// def_API('Z3_mk_int_sort', SORT, (_in(CONTEXT), ))
  Z3_sort mk_int_sort(
    Z3_context c,
  ) {
    return _mk_int_sort(
      c,
    );
  }

  late final _mk_int_sortPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context)>>(
          'Z3_mk_int_sort');
  late final _mk_int_sort =
      _mk_int_sortPtr.asFunction<Z3_sort Function(Z3_context)>();

  /// \brief Create the real type.
  ///
  /// Note that this type is not a floating point number.
  ///
  /// def_API('Z3_mk_real_sort', SORT, (_in(CONTEXT), ))
  Z3_sort mk_real_sort(
    Z3_context c,
  ) {
    return _mk_real_sort(
      c,
    );
  }

  late final _mk_real_sortPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context)>>(
          'Z3_mk_real_sort');
  late final _mk_real_sort =
      _mk_real_sortPtr.asFunction<Z3_sort Function(Z3_context)>();

  /// \brief Create a bit-vector type of the given size.
  ///
  /// This type can also be seen as a machine integer.
  ///
  /// \remark The size of the bit-vector type must be greater than zero.
  ///
  /// def_API('Z3_mk_bv_sort', SORT, (_in(CONTEXT), _in(UINT)))
  Z3_sort mk_bv_sort(
    Z3_context c,
    int sz,
  ) {
    return _mk_bv_sort(
      c,
      sz,
    );
  }

  late final _mk_bv_sortPtr = _lookup<
          ffi.NativeFunction<Z3_sort Function(Z3_context, ffi.UnsignedInt)>>(
      'Z3_mk_bv_sort');
  late final _mk_bv_sort =
      _mk_bv_sortPtr.asFunction<Z3_sort Function(Z3_context, int)>();

  /// \brief Create a named finite domain sort.
  ///
  /// To create constants that belong to the finite domain,
  /// use the APIs for creating numerals and pass a numeric
  /// constant together with the sort returned by this call.
  /// The numeric constant should be between 0 and the less
  /// than the size of the domain.
  ///
  /// \sa Z3_get_finite_domain_sort_size
  ///
  /// def_API('Z3_mk_finite_domain_sort', SORT, (_in(CONTEXT), _in(SYMBOL), _in(UINT64)))
  Z3_sort mk_finite_domain_sort(
    Z3_context c,
    Z3_symbol name,
    int size,
  ) {
    return _mk_finite_domain_sort(
      c,
      name,
      size,
    );
  }

  late final _mk_finite_domain_sortPtr = _lookup<
          ffi
          .NativeFunction<Z3_sort Function(Z3_context, Z3_symbol, ffi.Uint64)>>(
      'Z3_mk_finite_domain_sort');
  late final _mk_finite_domain_sort = _mk_finite_domain_sortPtr
      .asFunction<Z3_sort Function(Z3_context, Z3_symbol, int)>();

  /// \brief Create an array type.
  ///
  /// We usually represent the array type as: \ccode{[domain -> range]}.
  /// Arrays are usually used to model the heap/memory in software verification.
  ///
  /// \sa Z3_mk_select
  /// \sa Z3_mk_store
  ///
  /// def_API('Z3_mk_array_sort', SORT, (_in(CONTEXT), _in(SORT), _in(SORT)))
  Z3_sort mk_array_sort(
    Z3_context c,
    Z3_sort domain,
    Z3_sort range,
  ) {
    return _mk_array_sort(
      c,
      domain,
      range,
    );
  }

  late final _mk_array_sortPtr = _lookup<
          ffi.NativeFunction<Z3_sort Function(Z3_context, Z3_sort, Z3_sort)>>(
      'Z3_mk_array_sort');
  late final _mk_array_sort = _mk_array_sortPtr
      .asFunction<Z3_sort Function(Z3_context, Z3_sort, Z3_sort)>();

  /// \brief Create an array type with N arguments
  ///
  /// \sa Z3_mk_select_n
  /// \sa Z3_mk_store_n
  ///
  /// def_API('Z3_mk_array_sort_n', SORT, (_in(CONTEXT), _in(UINT), _in_array(1, SORT), _in(SORT)))
  Z3_sort mk_array_sort_n(
    Z3_context c,
    int n,
    ffi.Pointer<Z3_sort> domain,
    Z3_sort range,
  ) {
    return _mk_array_sort_n(
      c,
      n,
      domain,
      range,
    );
  }

  late final _mk_array_sort_nPtr = _lookup<
      ffi.NativeFunction<
          Z3_sort Function(Z3_context, ffi.UnsignedInt, ffi.Pointer<Z3_sort>,
              Z3_sort)>>('Z3_mk_array_sort_n');
  late final _mk_array_sort_n = _mk_array_sort_nPtr.asFunction<
      Z3_sort Function(Z3_context, int, ffi.Pointer<Z3_sort>, Z3_sort)>();

  /// \brief Create a tuple type.
  ///
  /// A tuple with \c n fields has a constructor and \c n projections.
  /// This function will also declare the constructor and projection functions.
  ///
  /// \param c logical context
  /// \param mk_tuple_name name of the constructor function associated with the tuple type.
  /// \param num_fields number of fields in the tuple type.
  /// \param field_names name of the projection functions.
  /// \param field_sorts type of the tuple fields.
  /// \param mk_tuple_decl output parameter that will contain the constructor declaration.
  /// \param proj_decl output parameter that will contain the projection function declarations. This field must be a buffer of size \c num_fields allocated by the user.
  ///
  /// def_API('Z3_mk_tuple_sort', SORT, (_in(CONTEXT), _in(SYMBOL), _in(UINT), _in_array(2, SYMBOL), _in_array(2, SORT), _out(FUNC_DECL), _out_array(2, FUNC_DECL)))
  Z3_sort mk_tuple_sort(
    Z3_context c,
    Z3_symbol mk_tuple_name,
    int num_fields,
    ffi.Pointer<Z3_symbol> field_names,
    ffi.Pointer<Z3_sort> field_sorts,
    ffi.Pointer<Z3_func_decl> mk_tuple_decl,
    ffi.Pointer<Z3_func_decl> proj_decl,
  ) {
    return _mk_tuple_sort(
      c,
      mk_tuple_name,
      num_fields,
      field_names,
      field_sorts,
      mk_tuple_decl,
      proj_decl,
    );
  }

  late final _mk_tuple_sortPtr = _lookup<
      ffi.NativeFunction<
          Z3_sort Function(
              Z3_context,
              Z3_symbol,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_symbol>,
              ffi.Pointer<Z3_sort>,
              ffi.Pointer<Z3_func_decl>,
              ffi.Pointer<Z3_func_decl>)>>('Z3_mk_tuple_sort');
  late final _mk_tuple_sort = _mk_tuple_sortPtr.asFunction<
      Z3_sort Function(
          Z3_context,
          Z3_symbol,
          int,
          ffi.Pointer<Z3_symbol>,
          ffi.Pointer<Z3_sort>,
          ffi.Pointer<Z3_func_decl>,
          ffi.Pointer<Z3_func_decl>)>();

  /// \brief Create a enumeration sort.
  ///
  /// An enumeration sort with \c n elements.
  /// This function will also declare the functions corresponding to the enumerations.
  ///
  /// \param c logical context
  /// \param name name of the enumeration sort.
  /// \param n number of elements in enumeration sort.
  /// \param enum_names names of the enumerated elements.
  /// \param enum_consts constants corresponding to the enumerated elements.
  /// \param enum_testers predicates testing if terms of the enumeration sort correspond to an enumeration.
  ///
  /// For example, if this function is called with three symbols A, B, C and the name S, then
  /// \c s is a sort whose name is S, and the function returns three terms corresponding to A, B, C in
  /// \c enum_consts. The array \c enum_testers has three predicates of type \ccode{(s -> Bool)}.
  /// The first predicate (corresponding to A) is true when applied to A, and false otherwise.
  /// Similarly for the other predicates.
  ///
  /// def_API('Z3_mk_enumeration_sort', SORT, (_in(CONTEXT), _in(SYMBOL), _in(UINT), _in_array(2, SYMBOL), _out_array(2, FUNC_DECL), _out_array(2, FUNC_DECL)))
  Z3_sort mk_enumeration_sort(
    Z3_context c,
    Z3_symbol name,
    int n,
    ffi.Pointer<Z3_symbol> enum_names,
    ffi.Pointer<Z3_func_decl> enum_consts,
    ffi.Pointer<Z3_func_decl> enum_testers,
  ) {
    return _mk_enumeration_sort(
      c,
      name,
      n,
      enum_names,
      enum_consts,
      enum_testers,
    );
  }

  late final _mk_enumeration_sortPtr = _lookup<
      ffi.NativeFunction<
          Z3_sort Function(
              Z3_context,
              Z3_symbol,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_symbol>,
              ffi.Pointer<Z3_func_decl>,
              ffi.Pointer<Z3_func_decl>)>>('Z3_mk_enumeration_sort');
  late final _mk_enumeration_sort = _mk_enumeration_sortPtr.asFunction<
      Z3_sort Function(Z3_context, Z3_symbol, int, ffi.Pointer<Z3_symbol>,
          ffi.Pointer<Z3_func_decl>, ffi.Pointer<Z3_func_decl>)>();

  /// \brief Create a list sort
  ///
  /// A list sort over \c elem_sort
  /// This function declares the corresponding constructors and testers for lists.
  ///
  /// \param c logical context
  /// \param name name of the list sort.
  /// \param elem_sort sort of list elements.
  /// \param nil_decl declaration for the empty list.
  /// \param is_nil_decl test for the empty list.
  /// \param cons_decl declaration for a cons cell.
  /// \param is_cons_decl cons cell test.
  /// \param head_decl list head.
  /// \param tail_decl list tail.
  ///
  /// def_API('Z3_mk_list_sort', SORT, (_in(CONTEXT), _in(SYMBOL), _in(SORT), _out(FUNC_DECL), _out(FUNC_DECL), _out(FUNC_DECL), _out(FUNC_DECL), _out(FUNC_DECL), _out(FUNC_DECL)))
  Z3_sort mk_list_sort(
    Z3_context c,
    Z3_symbol name,
    Z3_sort elem_sort,
    ffi.Pointer<Z3_func_decl> nil_decl,
    ffi.Pointer<Z3_func_decl> is_nil_decl,
    ffi.Pointer<Z3_func_decl> cons_decl,
    ffi.Pointer<Z3_func_decl> is_cons_decl,
    ffi.Pointer<Z3_func_decl> head_decl,
    ffi.Pointer<Z3_func_decl> tail_decl,
  ) {
    return _mk_list_sort(
      c,
      name,
      elem_sort,
      nil_decl,
      is_nil_decl,
      cons_decl,
      is_cons_decl,
      head_decl,
      tail_decl,
    );
  }

  late final _mk_list_sortPtr = _lookup<
      ffi.NativeFunction<
          Z3_sort Function(
              Z3_context,
              Z3_symbol,
              Z3_sort,
              ffi.Pointer<Z3_func_decl>,
              ffi.Pointer<Z3_func_decl>,
              ffi.Pointer<Z3_func_decl>,
              ffi.Pointer<Z3_func_decl>,
              ffi.Pointer<Z3_func_decl>,
              ffi.Pointer<Z3_func_decl>)>>('Z3_mk_list_sort');
  late final _mk_list_sort = _mk_list_sortPtr.asFunction<
      Z3_sort Function(
          Z3_context,
          Z3_symbol,
          Z3_sort,
          ffi.Pointer<Z3_func_decl>,
          ffi.Pointer<Z3_func_decl>,
          ffi.Pointer<Z3_func_decl>,
          ffi.Pointer<Z3_func_decl>,
          ffi.Pointer<Z3_func_decl>,
          ffi.Pointer<Z3_func_decl>)>();

  /// \brief Create a constructor.
  ///
  /// \param c logical context.
  /// \param name constructor name.
  /// \param recognizer name of recognizer function.
  /// \param num_fields number of fields in constructor.
  /// \param field_names names of the constructor fields.
  /// \param sorts field sorts, 0 if the field sort refers to a recursive sort.
  /// \param sort_refs reference to datatype sort that is an argument to the constructor; if the corresponding
  /// sort reference is 0, then the value in sort_refs should be an index referring to
  /// one of the recursive datatypes that is declared.
  ///
  /// \sa Z3_del_constructor
  /// \sa Z3_mk_constructor_list
  /// \sa Z3_query_constructor
  ///
  /// def_API('Z3_mk_constructor', CONSTRUCTOR, (_in(CONTEXT), _in(SYMBOL), _in(SYMBOL), _in(UINT), _in_array(3, SYMBOL), _in_array(3, SORT), _in_array(3, UINT)))
  Z3_constructor mk_constructor(
    Z3_context c,
    Z3_symbol name,
    Z3_symbol recognizer,
    int num_fields,
    ffi.Pointer<Z3_symbol> field_names,
    ffi.Pointer<Z3_sort> sorts,
    ffi.Pointer<ffi.UnsignedInt> sort_refs,
  ) {
    return _mk_constructor(
      c,
      name,
      recognizer,
      num_fields,
      field_names,
      sorts,
      sort_refs,
    );
  }

  late final _mk_constructorPtr = _lookup<
      ffi.NativeFunction<
          Z3_constructor Function(
              Z3_context,
              Z3_symbol,
              Z3_symbol,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_symbol>,
              ffi.Pointer<Z3_sort>,
              ffi.Pointer<ffi.UnsignedInt>)>>('Z3_mk_constructor');
  late final _mk_constructor = _mk_constructorPtr.asFunction<
      Z3_constructor Function(
          Z3_context,
          Z3_symbol,
          Z3_symbol,
          int,
          ffi.Pointer<Z3_symbol>,
          ffi.Pointer<Z3_sort>,
          ffi.Pointer<ffi.UnsignedInt>)>();

  /// \brief Reclaim memory allocated to constructor.
  ///
  /// \param c logical context.
  /// \param constr constructor.
  ///
  /// \sa Z3_mk_constructor
  ///
  /// def_API('Z3_del_constructor', VOID, (_in(CONTEXT), _in(CONSTRUCTOR)))
  void del_constructor(
    Z3_context c,
    Z3_constructor constr,
  ) {
    return _del_constructor(
      c,
      constr,
    );
  }

  late final _del_constructorPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_constructor)>>(
      'Z3_del_constructor');
  late final _del_constructor = _del_constructorPtr
      .asFunction<void Function(Z3_context, Z3_constructor)>();

  /// \brief Create datatype, such as lists, trees, records, enumerations or unions of records.
  /// The datatype may be recursive. Return the datatype sort.
  ///
  /// \param c logical context.
  /// \param name name of datatype.
  /// \param num_constructors number of constructors passed in.
  /// \param constructors array of constructor containers.
  ///
  /// \sa Z3_mk_constructor
  /// \sa Z3_mk_constructor_list
  /// \sa Z3_mk_datatypes
  ///
  /// def_API('Z3_mk_datatype', SORT, (_in(CONTEXT), _in(SYMBOL), _in(UINT), _inout_array(2, CONSTRUCTOR)))
  Z3_sort mk_datatype(
    Z3_context c,
    Z3_symbol name,
    int num_constructors,
    ffi.Pointer<Z3_constructor> constructors,
  ) {
    return _mk_datatype(
      c,
      name,
      num_constructors,
      constructors,
    );
  }

  late final _mk_datatypePtr = _lookup<
      ffi.NativeFunction<
          Z3_sort Function(Z3_context, Z3_symbol, ffi.UnsignedInt,
              ffi.Pointer<Z3_constructor>)>>('Z3_mk_datatype');
  late final _mk_datatype = _mk_datatypePtr.asFunction<
      Z3_sort Function(
          Z3_context, Z3_symbol, int, ffi.Pointer<Z3_constructor>)>();

  /// \brief create a forward reference to a recursive datatype being declared.
  /// The forward reference can be used in a nested occurrence: the range of an array
  /// or as element sort of a sequence. The forward reference should only be used when
  /// used in an accessor for a recursive datatype that gets declared.
  ///
  /// Forward references can replace the use sort references, that are unsigned integers
  /// in the \c Z3_mk_constructor call
  ///
  /// def_API('Z3_mk_datatype_sort', SORT, (_in(CONTEXT), _in(SYMBOL)))
  Z3_sort mk_datatype_sort(
    Z3_context c,
    Z3_symbol name,
  ) {
    return _mk_datatype_sort(
      c,
      name,
    );
  }

  late final _mk_datatype_sortPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context, Z3_symbol)>>(
          'Z3_mk_datatype_sort');
  late final _mk_datatype_sort = _mk_datatype_sortPtr
      .asFunction<Z3_sort Function(Z3_context, Z3_symbol)>();

  /// \brief Create list of constructors.
  ///
  /// \param c logical context.
  /// \param num_constructors number of constructors in list.
  /// \param constructors list of constructors.
  ///
  /// \sa Z3_del_constructor_list
  /// \sa Z3_mk_constructor
  ///
  /// def_API('Z3_mk_constructor_list', CONSTRUCTOR_LIST, (_in(CONTEXT), _in(UINT), _in_array(1, CONSTRUCTOR)))
  Z3_constructor_list mk_constructor_list(
    Z3_context c,
    int num_constructors,
    ffi.Pointer<Z3_constructor> constructors,
  ) {
    return _mk_constructor_list(
      c,
      num_constructors,
      constructors,
    );
  }

  late final _mk_constructor_listPtr = _lookup<
      ffi.NativeFunction<
          Z3_constructor_list Function(Z3_context, ffi.UnsignedInt,
              ffi.Pointer<Z3_constructor>)>>('Z3_mk_constructor_list');
  late final _mk_constructor_list = _mk_constructor_listPtr.asFunction<
      Z3_constructor_list Function(
          Z3_context, int, ffi.Pointer<Z3_constructor>)>();

  /// \brief Reclaim memory allocated for constructor list.
  ///
  /// Each constructor inside the constructor list must be independently reclaimed using #Z3_del_constructor.
  ///
  /// \param c logical context.
  /// \param clist constructor list container.
  ///
  /// \sa Z3_mk_constructor_list
  ///
  /// def_API('Z3_del_constructor_list', VOID, (_in(CONTEXT), _in(CONSTRUCTOR_LIST)))
  void del_constructor_list(
    Z3_context c,
    Z3_constructor_list clist,
  ) {
    return _del_constructor_list(
      c,
      clist,
    );
  }

  late final _del_constructor_listPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(Z3_context, Z3_constructor_list)>>(
      'Z3_del_constructor_list');
  late final _del_constructor_list = _del_constructor_listPtr
      .asFunction<void Function(Z3_context, Z3_constructor_list)>();

  /// \brief Create mutually recursive datatypes.
  ///
  /// \param c logical context.
  /// \param num_sorts number of datatype sorts.
  /// \param sort_names names of datatype sorts.
  /// \param sorts array of datatype sorts.
  /// \param constructor_lists list of constructors, one list per sort.
  ///
  /// \sa Z3_mk_constructor
  /// \sa Z3_mk_constructor_list
  /// \sa Z3_mk_datatype
  ///
  /// def_API('Z3_mk_datatypes', VOID, (_in(CONTEXT), _in(UINT), _in_array(1, SYMBOL), _out_array(1, SORT), _inout_array(1, CONSTRUCTOR_LIST)))
  void mk_datatypes(
    Z3_context c,
    int num_sorts,
    ffi.Pointer<Z3_symbol> sort_names,
    ffi.Pointer<Z3_sort> sorts,
    ffi.Pointer<Z3_constructor_list> constructor_lists,
  ) {
    return _mk_datatypes(
      c,
      num_sorts,
      sort_names,
      sorts,
      constructor_lists,
    );
  }

  late final _mk_datatypesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_symbol>,
              ffi.Pointer<Z3_sort>,
              ffi.Pointer<Z3_constructor_list>)>>('Z3_mk_datatypes');
  late final _mk_datatypes = _mk_datatypesPtr.asFunction<
      void Function(Z3_context, int, ffi.Pointer<Z3_symbol>,
          ffi.Pointer<Z3_sort>, ffi.Pointer<Z3_constructor_list>)>();

  /// \brief Query constructor for declared functions.
  ///
  /// \param c logical context.
  /// \param constr constructor container. The container must have been passed into a #Z3_mk_datatype call.
  /// \param num_fields number of accessor fields in the constructor.
  /// \param constructor constructor function declaration, allocated by user.
  /// \param tester constructor test function declaration, allocated by user.
  /// \param accessors array of accessor function declarations allocated by user. The array must contain num_fields elements.
  ///
  /// \sa Z3_mk_constructor
  ///
  /// def_API('Z3_query_constructor', VOID, (_in(CONTEXT), _in(CONSTRUCTOR), _in(UINT), _out(FUNC_DECL), _out(FUNC_DECL), _out_array(2, FUNC_DECL)))
  void query_constructor(
    Z3_context c,
    Z3_constructor constr,
    int num_fields,
    ffi.Pointer<Z3_func_decl> constructor,
    ffi.Pointer<Z3_func_decl> tester,
    ffi.Pointer<Z3_func_decl> accessors,
  ) {
    return _query_constructor(
      c,
      constr,
      num_fields,
      constructor,
      tester,
      accessors,
    );
  }

  late final _query_constructorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context,
              Z3_constructor,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_func_decl>,
              ffi.Pointer<Z3_func_decl>,
              ffi.Pointer<Z3_func_decl>)>>('Z3_query_constructor');
  late final _query_constructor = _query_constructorPtr.asFunction<
      void Function(Z3_context, Z3_constructor, int, ffi.Pointer<Z3_func_decl>,
          ffi.Pointer<Z3_func_decl>, ffi.Pointer<Z3_func_decl>)>();

  /// \brief Declare a constant or function.
  ///
  /// \param c logical context.
  /// \param s name of the constant or function.
  /// \param domain_size number of arguments. It is 0 when declaring a constant.
  /// \param domain array containing the sort of each argument. The array must contain domain_size elements. It is 0 when declaring a constant.
  /// \param range sort of the constant or the return sort of the function.
  ///
  /// After declaring a constant or function, the function
  /// #Z3_mk_app can be used to create a constant or function
  /// application.
  ///
  /// \sa Z3_mk_app
  /// \sa Z3_mk_fresh_func_decl
  /// \sa Z3_mk_rec_func_decl
  ///
  /// def_API('Z3_mk_func_decl', FUNC_DECL, (_in(CONTEXT), _in(SYMBOL), _in(UINT), _in_array(2, SORT), _in(SORT)))
  Z3_func_decl mk_func_decl(
    Z3_context c,
    Z3_symbol s,
    int domain_size,
    ffi.Pointer<Z3_sort> domain,
    Z3_sort range,
  ) {
    return _mk_func_decl(
      c,
      s,
      domain_size,
      domain,
      range,
    );
  }

  late final _mk_func_declPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_decl Function(Z3_context, Z3_symbol, ffi.UnsignedInt,
              ffi.Pointer<Z3_sort>, Z3_sort)>>('Z3_mk_func_decl');
  late final _mk_func_decl = _mk_func_declPtr.asFunction<
      Z3_func_decl Function(
          Z3_context, Z3_symbol, int, ffi.Pointer<Z3_sort>, Z3_sort)>();

  /// \brief Create a constant or function application.
  ///
  /// \sa Z3_mk_fresh_func_decl
  /// \sa Z3_mk_func_decl
  /// \sa Z3_mk_rec_func_decl
  ///
  /// def_API('Z3_mk_app', AST, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT), _in_array(2, AST)))
  Z3_ast mk_app(
    Z3_context c,
    Z3_func_decl d,
    int num_args,
    ffi.Pointer<Z3_ast> args,
  ) {
    return _mk_app(
      c,
      d,
      num_args,
      args,
    );
  }

  late final _mk_appPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_func_decl, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_mk_app');
  late final _mk_app = _mk_appPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_func_decl, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Declare and create a constant.
  ///
  /// This function is a shorthand for:
  /// \code
  /// Z3_func_decl d = Z3_mk_func_decl(c, s, 0, 0, ty);
  /// Z3_ast n            = Z3_mk_app(c, d, 0, 0);
  /// \endcode
  ///
  /// \sa Z3_mk_app
  /// \sa Z3_mk_fresh_const
  /// \sa Z3_mk_func_decl
  ///
  /// def_API('Z3_mk_const', AST, (_in(CONTEXT), _in(SYMBOL), _in(SORT)))
  Z3_ast mk_const(
    Z3_context c,
    Z3_symbol s,
    Z3_sort ty,
  ) {
    return _mk_const(
      c,
      s,
      ty,
    );
  }

  late final _mk_constPtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_symbol, Z3_sort)>>(
      'Z3_mk_const');
  late final _mk_const = _mk_constPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_symbol, Z3_sort)>();

  /// \brief Declare a fresh constant or function.
  ///
  /// Z3 will generate an unique name for this function declaration.
  /// If prefix is different from \c NULL, then the name generate by Z3 will start with \c prefix.
  ///
  /// \remark If \c prefix is \c NULL, then it is assumed to be the empty string.
  ///
  /// \sa Z3_mk_func_decl
  ///
  /// def_API('Z3_mk_fresh_func_decl', FUNC_DECL, (_in(CONTEXT), _in(STRING), _in(UINT), _in_array(2, SORT), _in(SORT)))
  Z3_func_decl mk_fresh_func_decl(
    Z3_context c,
    Z3_string prefix,
    int domain_size,
    ffi.Pointer<Z3_sort> domain,
    Z3_sort range,
  ) {
    return _mk_fresh_func_decl(
      c,
      prefix,
      domain_size,
      domain,
      range,
    );
  }

  late final _mk_fresh_func_declPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_decl Function(Z3_context, Z3_string, ffi.UnsignedInt,
              ffi.Pointer<Z3_sort>, Z3_sort)>>('Z3_mk_fresh_func_decl');
  late final _mk_fresh_func_decl = _mk_fresh_func_declPtr.asFunction<
      Z3_func_decl Function(
          Z3_context, Z3_string, int, ffi.Pointer<Z3_sort>, Z3_sort)>();

  /// \brief Declare and create a fresh constant.
  ///
  /// This function is a shorthand for:
  /// \code Z3_func_decl d = Z3_mk_fresh_func_decl(c, prefix, 0, 0, ty); Z3_ast n = Z3_mk_app(c, d, 0, 0); \endcode
  ///
  /// \remark If \c prefix is \c NULL, then it is assumed to be the empty string.
  ///
  /// \sa Z3_mk_app
  /// \sa Z3_mk_const
  /// \sa Z3_mk_fresh_func_decl
  /// \sa Z3_mk_func_decl
  ///
  /// def_API('Z3_mk_fresh_const', AST, (_in(CONTEXT), _in(STRING), _in(SORT)))
  Z3_ast mk_fresh_const(
    Z3_context c,
    Z3_string prefix,
    Z3_sort ty,
  ) {
    return _mk_fresh_const(
      c,
      prefix,
      ty,
    );
  }

  late final _mk_fresh_constPtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_string, Z3_sort)>>(
      'Z3_mk_fresh_const');
  late final _mk_fresh_const = _mk_fresh_constPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_string, Z3_sort)>();

  /// \brief Declare a recursive function
  ///
  /// \param c logical context.
  /// \param s name of the function.
  /// \param domain_size number of arguments. It should be greater than 0.
  /// \param domain array containing the sort of each argument. The array must contain domain_size elements.
  /// \param range sort of the constant or the return sort of the function.
  ///
  /// After declaring recursive function, it should be associated with a recursive definition #Z3_add_rec_def.
  /// The function #Z3_mk_app can be used to create a constant or function
  /// application.
  ///
  /// \sa Z3_add_rec_def
  /// \sa Z3_mk_app
  /// \sa Z3_mk_func_decl
  ///
  /// def_API('Z3_mk_rec_func_decl', FUNC_DECL, (_in(CONTEXT), _in(SYMBOL), _in(UINT), _in_array(2, SORT), _in(SORT)))
  Z3_func_decl mk_rec_func_decl(
    Z3_context c,
    Z3_symbol s,
    int domain_size,
    ffi.Pointer<Z3_sort> domain,
    Z3_sort range,
  ) {
    return _mk_rec_func_decl(
      c,
      s,
      domain_size,
      domain,
      range,
    );
  }

  late final _mk_rec_func_declPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_decl Function(Z3_context, Z3_symbol, ffi.UnsignedInt,
              ffi.Pointer<Z3_sort>, Z3_sort)>>('Z3_mk_rec_func_decl');
  late final _mk_rec_func_decl = _mk_rec_func_declPtr.asFunction<
      Z3_func_decl Function(
          Z3_context, Z3_symbol, int, ffi.Pointer<Z3_sort>, Z3_sort)>();

  /// \brief Define the body of a recursive function.
  ///
  /// \param c logical context.
  /// \param f function declaration.
  /// \param n number of arguments to the function
  /// \param args constants that are used as arguments to the recursive function in the definition.
  /// \param body body of the recursive function
  ///
  /// After declaring a recursive function or a collection of mutually recursive functions, use
  /// this function to provide the definition for the recursive function.
  ///
  /// \sa Z3_mk_rec_func_decl
  ///
  /// def_API('Z3_add_rec_def', VOID, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT), _in_array(2, AST), _in(AST)))
  void add_rec_def(
    Z3_context c,
    Z3_func_decl f,
    int n,
    ffi.Pointer<Z3_ast> args,
    Z3_ast body,
  ) {
    return _add_rec_def(
      c,
      f,
      n,
      args,
      body,
    );
  }

  late final _add_rec_defPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_func_decl, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>, Z3_ast)>>('Z3_add_rec_def');
  late final _add_rec_def = _add_rec_defPtr.asFunction<
      void Function(
          Z3_context, Z3_func_decl, int, ffi.Pointer<Z3_ast>, Z3_ast)>();

  /// @name Propositional Logic and Equality */
  /// /**@{*/
  /// /**
  /// \brief Create an AST node representing \c true.
  ///
  /// def_API('Z3_mk_true', AST, (_in(CONTEXT), ))
  Z3_ast mk_true(
    Z3_context c,
  ) {
    return _mk_true(
      c,
    );
  }

  late final _mk_truePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context)>>('Z3_mk_true');
  late final _mk_true = _mk_truePtr.asFunction<Z3_ast Function(Z3_context)>();

  /// \brief Create an AST node representing \c false.
  ///
  /// def_API('Z3_mk_false', AST, (_in(CONTEXT), ))
  Z3_ast mk_false(
    Z3_context c,
  ) {
    return _mk_false(
      c,
    );
  }

  late final _mk_falsePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context)>>('Z3_mk_false');
  late final _mk_false = _mk_falsePtr.asFunction<Z3_ast Function(Z3_context)>();

  /// \brief Create an AST node representing \ccode{l = r}.
  ///
  /// The nodes \c l and \c r must have the same type.
  ///
  /// def_API('Z3_mk_eq', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_eq(
    Z3_context c,
    Z3_ast l,
    Z3_ast r,
  ) {
    return _mk_eq(
      c,
      l,
      r,
    );
  }

  late final _mk_eqPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_eq');
  late final _mk_eq =
      _mk_eqPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create an AST node representing \ccode{distinct(args[0], ..., args[num_args-1])}.
  ///
  /// The \c distinct construct is used for declaring the arguments pairwise distinct.
  /// That is, \ccode{Forall 0 <= i < j < num_args. not args[i] = args[j]}.
  ///
  /// All arguments must have the same sort.
  ///
  /// \remark The number of arguments of a distinct construct must be greater than one.
  ///
  /// def_API('Z3_mk_distinct', AST, (_in(CONTEXT), _in(UINT), _in_array(1, AST)))
  Z3_ast mk_distinct(
    Z3_context c,
    int num_args,
    ffi.Pointer<Z3_ast> args,
  ) {
    return _mk_distinct(
      c,
      num_args,
      args,
    );
  }

  late final _mk_distinctPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_mk_distinct');
  late final _mk_distinct = _mk_distinctPtr
      .asFunction<Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Create an AST node representing \ccode{not(a)}.
  ///
  /// The node \c a must have Boolean sort.
  ///
  /// def_API('Z3_mk_not', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast mk_not(
    Z3_context c,
    Z3_ast a,
  ) {
    return _mk_not(
      c,
      a,
    );
  }

  late final _mk_notPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_not');
  late final _mk_not =
      _mk_notPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Create an AST node representing an if-then-else: \ccode{ite(t1, t2, t3)}.
  ///
  /// The node \c t1 must have Boolean sort, \c t2 and \c t3 must have the same sort.
  /// The sort of the new node is equal to the sort of \c t2 and \c t3.
  ///
  /// def_API('Z3_mk_ite', AST, (_in(CONTEXT), _in(AST), _in(AST), _in(AST)))
  Z3_ast mk_ite(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
    Z3_ast t3,
  ) {
    return _mk_ite(
      c,
      t1,
      t2,
      t3,
    );
  }

  late final _mk_itePtr = _lookup<
          ffi
          .NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>>(
      'Z3_mk_ite');
  late final _mk_ite = _mk_itePtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>();

  /// \brief Create an AST node representing \ccode{t1 iff t2}.
  ///
  /// The nodes \c t1 and \c t2 must have Boolean sort.
  ///
  /// def_API('Z3_mk_iff', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_iff(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_iff(
      c,
      t1,
      t2,
    );
  }

  late final _mk_iffPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_iff');
  late final _mk_iff =
      _mk_iffPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create an AST node representing \ccode{t1 implies t2}.
  ///
  /// The nodes \c t1 and \c t2 must have Boolean sort.
  ///
  /// def_API('Z3_mk_implies', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_implies(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_implies(
      c,
      t1,
      t2,
    );
  }

  late final _mk_impliesPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_implies');
  late final _mk_implies =
      _mk_impliesPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create an AST node representing \ccode{t1 xor t2}.
  ///
  /// The nodes \c t1 and \c t2 must have Boolean sort.
  ///
  /// def_API('Z3_mk_xor', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_xor(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_xor(
      c,
      t1,
      t2,
    );
  }

  late final _mk_xorPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_xor');
  late final _mk_xor =
      _mk_xorPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create an AST node representing \ccode{args[0] and ... and args[num_args-1]}.
  ///
  /// The array \c args must have \c num_args elements.
  /// All arguments must have Boolean sort.
  ///
  /// \remark The number of arguments must be greater than zero.
  ///
  /// def_API('Z3_mk_and', AST, (_in(CONTEXT), _in(UINT), _in_array(1, AST)))
  Z3_ast mk_and(
    Z3_context c,
    int num_args,
    ffi.Pointer<Z3_ast> args,
  ) {
    return _mk_and(
      c,
      num_args,
      args,
    );
  }

  late final _mk_andPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, ffi.UnsignedInt, ffi.Pointer<Z3_ast>)>>('Z3_mk_and');
  late final _mk_and = _mk_andPtr
      .asFunction<Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Create an AST node representing \ccode{args[0] or ... or args[num_args-1]}.
  ///
  /// The array \c args must have \c num_args elements.
  /// All arguments must have Boolean sort.
  ///
  /// \remark The number of arguments must be greater than zero.
  ///
  /// def_API('Z3_mk_or', AST, (_in(CONTEXT), _in(UINT), _in_array(1, AST)))
  Z3_ast mk_or(
    Z3_context c,
    int num_args,
    ffi.Pointer<Z3_ast> args,
  ) {
    return _mk_or(
      c,
      num_args,
      args,
    );
  }

  late final _mk_orPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, ffi.UnsignedInt, ffi.Pointer<Z3_ast>)>>('Z3_mk_or');
  late final _mk_or = _mk_orPtr
      .asFunction<Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_ast>)>();

  /// @name Integers and Reals */
  /// /**@{*/
  /// /**
  /// \brief Create an AST node representing \ccode{args[0] + ... + args[num_args-1]}.
  ///
  /// The array \c args must have \c num_args elements.
  /// All arguments must have int or real sort.
  ///
  /// \remark The number of arguments must be greater than zero.
  ///
  /// def_API('Z3_mk_add', AST, (_in(CONTEXT), _in(UINT), _in_array(1, AST)))
  Z3_ast mk_add(
    Z3_context c,
    int num_args,
    ffi.Pointer<Z3_ast> args,
  ) {
    return _mk_add(
      c,
      num_args,
      args,
    );
  }

  late final _mk_addPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, ffi.UnsignedInt, ffi.Pointer<Z3_ast>)>>('Z3_mk_add');
  late final _mk_add = _mk_addPtr
      .asFunction<Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Create an AST node representing \ccode{args[0] * ... * args[num_args-1]}.
  ///
  /// The array \c args must have \c num_args elements.
  /// All arguments must have int or real sort.
  ///
  /// \remark Z3 has limited support for non-linear arithmetic.
  /// \remark The number of arguments must be greater than zero.
  ///
  /// def_API('Z3_mk_mul', AST, (_in(CONTEXT), _in(UINT), _in_array(1, AST)))
  Z3_ast mk_mul(
    Z3_context c,
    int num_args,
    ffi.Pointer<Z3_ast> args,
  ) {
    return _mk_mul(
      c,
      num_args,
      args,
    );
  }

  late final _mk_mulPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, ffi.UnsignedInt, ffi.Pointer<Z3_ast>)>>('Z3_mk_mul');
  late final _mk_mul = _mk_mulPtr
      .asFunction<Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Create an AST node representing \ccode{args[0] - ... - args[num_args - 1]}.
  ///
  /// The array \c args must have \c num_args elements.
  /// All arguments must have int or real sort.
  ///
  /// \remark The number of arguments must be greater than zero.
  ///
  /// def_API('Z3_mk_sub', AST, (_in(CONTEXT), _in(UINT), _in_array(1, AST)))
  Z3_ast mk_sub(
    Z3_context c,
    int num_args,
    ffi.Pointer<Z3_ast> args,
  ) {
    return _mk_sub(
      c,
      num_args,
      args,
    );
  }

  late final _mk_subPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, ffi.UnsignedInt, ffi.Pointer<Z3_ast>)>>('Z3_mk_sub');
  late final _mk_sub = _mk_subPtr
      .asFunction<Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Create an AST node representing \ccode{- arg}.
  ///
  /// The arguments must have int or real type.
  ///
  /// def_API('Z3_mk_unary_minus', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast mk_unary_minus(
    Z3_context c,
    Z3_ast arg,
  ) {
    return _mk_unary_minus(
      c,
      arg,
    );
  }

  late final _mk_unary_minusPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_unary_minus');
  late final _mk_unary_minus =
      _mk_unary_minusPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Create an AST node representing \ccode{arg1 div arg2}.
  ///
  /// The arguments must either both have int type or both have real type.
  /// If the arguments have int type, then the result type is an int type, otherwise the
  /// the result type is real.
  ///
  /// def_API('Z3_mk_div', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_div(
    Z3_context c,
    Z3_ast arg1,
    Z3_ast arg2,
  ) {
    return _mk_div(
      c,
      arg1,
      arg2,
    );
  }

  late final _mk_divPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_div');
  late final _mk_div =
      _mk_divPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create an AST node representing \ccode{arg1 mod arg2}.
  ///
  /// The arguments must have int type.
  ///
  /// def_API('Z3_mk_mod', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_mod(
    Z3_context c,
    Z3_ast arg1,
    Z3_ast arg2,
  ) {
    return _mk_mod(
      c,
      arg1,
      arg2,
    );
  }

  late final _mk_modPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_mod');
  late final _mk_mod =
      _mk_modPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create an AST node representing \ccode{arg1 rem arg2}.
  ///
  /// The arguments must have int type.
  ///
  /// def_API('Z3_mk_rem', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_rem(
    Z3_context c,
    Z3_ast arg1,
    Z3_ast arg2,
  ) {
    return _mk_rem(
      c,
      arg1,
      arg2,
    );
  }

  late final _mk_remPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_rem');
  late final _mk_rem =
      _mk_remPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create an AST node representing \ccode{arg1 ^ arg2}.
  ///
  /// The arguments must have int or real type.
  ///
  /// def_API('Z3_mk_power', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_power(
    Z3_context c,
    Z3_ast arg1,
    Z3_ast arg2,
  ) {
    return _mk_power(
      c,
      arg1,
      arg2,
    );
  }

  late final _mk_powerPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_power');
  late final _mk_power =
      _mk_powerPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create less than.
  ///
  /// The nodes \c t1 and \c t2 must have the same sort, and must be int or real.
  ///
  /// def_API('Z3_mk_lt', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_lt(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_lt(
      c,
      t1,
      t2,
    );
  }

  late final _mk_ltPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_lt');
  late final _mk_lt =
      _mk_ltPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create less than or equal to.
  ///
  /// The nodes \c t1 and \c t2 must have the same sort, and must be int or real.
  ///
  /// def_API('Z3_mk_le', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_le(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_le(
      c,
      t1,
      t2,
    );
  }

  late final _mk_lePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_le');
  late final _mk_le =
      _mk_lePtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create greater than.
  ///
  /// The nodes \c t1 and \c t2 must have the same sort, and must be int or real.
  ///
  /// def_API('Z3_mk_gt', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_gt(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_gt(
      c,
      t1,
      t2,
    );
  }

  late final _mk_gtPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_gt');
  late final _mk_gt =
      _mk_gtPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create greater than or equal to.
  ///
  /// The nodes \c t1 and \c t2 must have the same sort, and must be int or real.
  ///
  /// def_API('Z3_mk_ge', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_ge(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_ge(
      c,
      t1,
      t2,
    );
  }

  late final _mk_gePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_ge');
  late final _mk_ge =
      _mk_gePtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create division predicate.
  ///
  /// The nodes \c t1 and \c t2 must be of integer sort.
  /// The predicate is true when \c t1 divides \c t2. For the predicate to be part of
  /// linear integer arithmetic, the first argument \c t1 must be a non-zero integer.
  ///
  /// def_API('Z3_mk_divides', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_divides(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_divides(
      c,
      t1,
      t2,
    );
  }

  late final _mk_dividesPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_divides');
  late final _mk_divides =
      _mk_dividesPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Coerce an integer to a real.
  ///
  /// There is also a converse operation exposed.
  /// It follows the semantics prescribed by the SMT-LIB standard.
  ///
  /// You can take the floor of a real by
  /// creating an auxiliary integer constant \c k and
  /// and asserting \ccode{mk_int2real(k) <= t1 < mk_int2real(k)+1}.
  ///
  /// The node \c t1 must have sort integer.
  ///
  /// \sa Z3_mk_real2int
  /// \sa Z3_mk_is_int
  ///
  /// def_API('Z3_mk_int2real', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast mk_int2real(
    Z3_context c,
    Z3_ast t1,
  ) {
    return _mk_int2real(
      c,
      t1,
    );
  }

  late final _mk_int2realPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_int2real');
  late final _mk_int2real =
      _mk_int2realPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Coerce a real to an integer.
  ///
  /// The semantics of this function follows the SMT-LIB standard
  /// for the function to_int
  ///
  /// \sa Z3_mk_int2real
  /// \sa Z3_mk_is_int
  ///
  /// def_API('Z3_mk_real2int', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast mk_real2int(
    Z3_context c,
    Z3_ast t1,
  ) {
    return _mk_real2int(
      c,
      t1,
    );
  }

  late final _mk_real2intPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_real2int');
  late final _mk_real2int =
      _mk_real2intPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Check if a real number is an integer.
  ///
  /// \sa Z3_mk_int2real
  /// \sa Z3_mk_real2int
  ///
  /// def_API('Z3_mk_is_int', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast mk_is_int(
    Z3_context c,
    Z3_ast t1,
  ) {
    return _mk_is_int(
      c,
      t1,
    );
  }

  late final _mk_is_intPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_is_int');
  late final _mk_is_int =
      _mk_is_intPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// @name Bit-vectors */
  /// /**@{*/
  /// /**
  /// \brief Bitwise negation.
  ///
  /// The node \c t1 must have a bit-vector sort.
  ///
  /// def_API('Z3_mk_bvnot', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast mk_bvnot(
    Z3_context c,
    Z3_ast t1,
  ) {
    return _mk_bvnot(
      c,
      t1,
    );
  }

  late final _mk_bvnotPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_bvnot');
  late final _mk_bvnot =
      _mk_bvnotPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Take conjunction of bits in vector, return vector of length 1.
  ///
  /// The node \c t1 must have a bit-vector sort.
  ///
  /// def_API('Z3_mk_bvredand', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast mk_bvredand(
    Z3_context c,
    Z3_ast t1,
  ) {
    return _mk_bvredand(
      c,
      t1,
    );
  }

  late final _mk_bvredandPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_bvredand');
  late final _mk_bvredand =
      _mk_bvredandPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Take disjunction of bits in vector, return vector of length 1.
  ///
  /// The node \c t1 must have a bit-vector sort.
  ///
  /// def_API('Z3_mk_bvredor', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast mk_bvredor(
    Z3_context c,
    Z3_ast t1,
  ) {
    return _mk_bvredor(
      c,
      t1,
    );
  }

  late final _mk_bvredorPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_bvredor');
  late final _mk_bvredor =
      _mk_bvredorPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Bitwise and.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvand', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_bvand(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_bvand(
      c,
      t1,
      t2,
    );
  }

  late final _mk_bvandPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvand');
  late final _mk_bvand =
      _mk_bvandPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Bitwise or.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvor', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_bvor(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_bvor(
      c,
      t1,
      t2,
    );
  }

  late final _mk_bvorPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvor');
  late final _mk_bvor =
      _mk_bvorPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Bitwise exclusive-or.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvxor', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_bvxor(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_bvxor(
      c,
      t1,
      t2,
    );
  }

  late final _mk_bvxorPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvxor');
  late final _mk_bvxor =
      _mk_bvxorPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Bitwise nand.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvnand', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_bvnand(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_bvnand(
      c,
      t1,
      t2,
    );
  }

  late final _mk_bvnandPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvnand');
  late final _mk_bvnand =
      _mk_bvnandPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Bitwise nor.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvnor', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_bvnor(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_bvnor(
      c,
      t1,
      t2,
    );
  }

  late final _mk_bvnorPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvnor');
  late final _mk_bvnor =
      _mk_bvnorPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Bitwise xnor.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvxnor', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_bvxnor(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_bvxnor(
      c,
      t1,
      t2,
    );
  }

  late final _mk_bvxnorPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvxnor');
  late final _mk_bvxnor =
      _mk_bvxnorPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Standard two's complement unary minus.
  ///
  /// The node \c t1 must have bit-vector sort.
  ///
  /// def_API('Z3_mk_bvneg', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast mk_bvneg(
    Z3_context c,
    Z3_ast t1,
  ) {
    return _mk_bvneg(
      c,
      t1,
    );
  }

  late final _mk_bvnegPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_bvneg');
  late final _mk_bvneg =
      _mk_bvnegPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Standard two's complement addition.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvadd', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_bvadd(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_bvadd(
      c,
      t1,
      t2,
    );
  }

  late final _mk_bvaddPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvadd');
  late final _mk_bvadd =
      _mk_bvaddPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Standard two's complement subtraction.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvsub', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_bvsub(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_bvsub(
      c,
      t1,
      t2,
    );
  }

  late final _mk_bvsubPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvsub');
  late final _mk_bvsub =
      _mk_bvsubPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Standard two's complement multiplication.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvmul', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_bvmul(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_bvmul(
      c,
      t1,
      t2,
    );
  }

  late final _mk_bvmulPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvmul');
  late final _mk_bvmul =
      _mk_bvmulPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Unsigned division.
  ///
  /// It is defined as the \c floor of \ccode{t1/t2} if \c t2 is
  /// different from zero. If \ccode{t2} is zero, then the result
  /// is undefined.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvudiv', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_bvudiv(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_bvudiv(
      c,
      t1,
      t2,
    );
  }

  late final _mk_bvudivPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvudiv');
  late final _mk_bvudiv =
      _mk_bvudivPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Two's complement signed division.
  ///
  /// It is defined in the following way:
  ///
  /// - The \c floor of \ccode{t1/t2} if \c t2 is different from zero, and \ccode{t1*t2 >= 0}.
  ///
  /// - The \c ceiling of \ccode{t1/t2} if \c t2 is different from zero, and \ccode{t1*t2 < 0}.
  ///
  /// If \ccode{t2} is zero, then the result is undefined.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvsdiv', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_bvsdiv(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_bvsdiv(
      c,
      t1,
      t2,
    );
  }

  late final _mk_bvsdivPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvsdiv');
  late final _mk_bvsdiv =
      _mk_bvsdivPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Unsigned remainder.
  ///
  /// It is defined as \ccode{t1 - (t1 /u t2) * t2}, where \ccode{/u} represents unsigned division.
  ///
  /// If \ccode{t2} is zero, then the result is undefined.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvurem', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_bvurem(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_bvurem(
      c,
      t1,
      t2,
    );
  }

  late final _mk_bvuremPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvurem');
  late final _mk_bvurem =
      _mk_bvuremPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Two's complement signed remainder (sign follows dividend).
  ///
  /// It is defined as \ccode{t1 - (t1 /s t2) * t2}, where \ccode{/s} represents signed division.
  /// The most significant bit (sign) of the result is equal to the most significant bit of \c t1.
  ///
  /// If \ccode{t2} is zero, then the result is undefined.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// \sa Z3_mk_bvsmod
  ///
  /// def_API('Z3_mk_bvsrem', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_bvsrem(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_bvsrem(
      c,
      t1,
      t2,
    );
  }

  late final _mk_bvsremPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvsrem');
  late final _mk_bvsrem =
      _mk_bvsremPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Two's complement signed remainder (sign follows divisor).
  ///
  /// If \ccode{t2} is zero, then the result is undefined.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// \sa Z3_mk_bvsrem
  ///
  /// def_API('Z3_mk_bvsmod', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_bvsmod(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_bvsmod(
      c,
      t1,
      t2,
    );
  }

  late final _mk_bvsmodPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvsmod');
  late final _mk_bvsmod =
      _mk_bvsmodPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Unsigned less than.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvult', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_bvult(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_bvult(
      c,
      t1,
      t2,
    );
  }

  late final _mk_bvultPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvult');
  late final _mk_bvult =
      _mk_bvultPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Two's complement signed less than.
  ///
  /// It abbreviates:
  /// \code
  /// (or (and (= (extract[|m-1|:|m-1|] t1) bit1)
  /// (= (extract[|m-1|:|m-1|] t2) bit0))
  /// (and (= (extract[|m-1|:|m-1|] t1) (extract[|m-1|:|m-1|] t2))
  /// (bvult t1 t2)))
  /// \endcode
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvslt', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_bvslt(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_bvslt(
      c,
      t1,
      t2,
    );
  }

  late final _mk_bvsltPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvslt');
  late final _mk_bvslt =
      _mk_bvsltPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Unsigned less than or equal to.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvule', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_bvule(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_bvule(
      c,
      t1,
      t2,
    );
  }

  late final _mk_bvulePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvule');
  late final _mk_bvule =
      _mk_bvulePtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Two's complement signed less than or equal to.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvsle', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_bvsle(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_bvsle(
      c,
      t1,
      t2,
    );
  }

  late final _mk_bvslePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvsle');
  late final _mk_bvsle =
      _mk_bvslePtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Unsigned greater than or equal to.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvuge', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_bvuge(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_bvuge(
      c,
      t1,
      t2,
    );
  }

  late final _mk_bvugePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvuge');
  late final _mk_bvuge =
      _mk_bvugePtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Two's complement signed greater than or equal to.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvsge', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_bvsge(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_bvsge(
      c,
      t1,
      t2,
    );
  }

  late final _mk_bvsgePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvsge');
  late final _mk_bvsge =
      _mk_bvsgePtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Unsigned greater than.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvugt', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_bvugt(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_bvugt(
      c,
      t1,
      t2,
    );
  }

  late final _mk_bvugtPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvugt');
  late final _mk_bvugt =
      _mk_bvugtPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Two's complement signed greater than.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvsgt', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_bvsgt(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_bvsgt(
      c,
      t1,
      t2,
    );
  }

  late final _mk_bvsgtPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvsgt');
  late final _mk_bvsgt =
      _mk_bvsgtPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Concatenate the given bit-vectors.
  ///
  /// The nodes \c t1 and \c t2 must have (possibly different) bit-vector sorts
  ///
  /// The result is a bit-vector of size \ccode{n1+n2}, where \c n1 (\c n2) is the size
  /// of \c t1 (\c t2).
  ///
  /// def_API('Z3_mk_concat', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_concat(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_concat(
      c,
      t1,
      t2,
    );
  }

  late final _mk_concatPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_concat');
  late final _mk_concat =
      _mk_concatPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Extract the bits \c high down to \c low from a bit-vector of
  /// size \c m to yield a new bit-vector of size \c n, where \ccode{n = high - low + 1}.
  ///
  /// The node \c t1 must have a bit-vector sort.
  ///
  /// def_API('Z3_mk_extract', AST, (_in(CONTEXT), _in(UINT), _in(UINT), _in(AST)))
  Z3_ast mk_extract(
    Z3_context c,
    int high,
    int low,
    Z3_ast t1,
  ) {
    return _mk_extract(
      c,
      high,
      low,
      t1,
    );
  }

  late final _mk_extractPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt, ffi.UnsignedInt,
              Z3_ast)>>('Z3_mk_extract');
  late final _mk_extract = _mk_extractPtr
      .asFunction<Z3_ast Function(Z3_context, int, int, Z3_ast)>();

  /// \brief Sign-extend of the given bit-vector to the (signed) equivalent bit-vector of
  /// size \ccode{m+i}, where \c m is the size of the given
  /// bit-vector.
  ///
  /// The node \c t1 must have a bit-vector sort.
  ///
  /// def_API('Z3_mk_sign_ext', AST, (_in(CONTEXT), _in(UINT), _in(AST)))
  Z3_ast mk_sign_ext(
    Z3_context c,
    int i,
    Z3_ast t1,
  ) {
    return _mk_sign_ext(
      c,
      i,
      t1,
    );
  }

  late final _mk_sign_extPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, ffi.UnsignedInt, Z3_ast)>>('Z3_mk_sign_ext');
  late final _mk_sign_ext =
      _mk_sign_extPtr.asFunction<Z3_ast Function(Z3_context, int, Z3_ast)>();

  /// \brief Extend the given bit-vector with zeros to the (unsigned) equivalent
  /// bit-vector of size \ccode{m+i}, where \c m is the size of the
  /// given bit-vector.
  ///
  /// The node \c t1 must have a bit-vector sort.
  ///
  /// def_API('Z3_mk_zero_ext', AST, (_in(CONTEXT), _in(UINT), _in(AST)))
  Z3_ast mk_zero_ext(
    Z3_context c,
    int i,
    Z3_ast t1,
  ) {
    return _mk_zero_ext(
      c,
      i,
      t1,
    );
  }

  late final _mk_zero_extPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, ffi.UnsignedInt, Z3_ast)>>('Z3_mk_zero_ext');
  late final _mk_zero_ext =
      _mk_zero_extPtr.asFunction<Z3_ast Function(Z3_context, int, Z3_ast)>();

  /// \brief Repeat the given bit-vector up length \ccode{i}.
  ///
  /// The node \c t1 must have a bit-vector sort.
  ///
  /// def_API('Z3_mk_repeat', AST, (_in(CONTEXT), _in(UINT), _in(AST)))
  Z3_ast mk_repeat(
    Z3_context c,
    int i,
    Z3_ast t1,
  ) {
    return _mk_repeat(
      c,
      i,
      t1,
    );
  }

  late final _mk_repeatPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, ffi.UnsignedInt, Z3_ast)>>('Z3_mk_repeat');
  late final _mk_repeat =
      _mk_repeatPtr.asFunction<Z3_ast Function(Z3_context, int, Z3_ast)>();

  /// \brief Extracts the bit at position \ccode{i} of a bit-vector and
  /// yields a boolean.
  ///
  /// The node \c t1 must have a bit-vector sort.
  ///
  /// def_API('Z3_mk_bit2bool', AST, (_in(CONTEXT), _in(UINT), _in(AST)))
  Z3_ast mk_bit2bool(
    Z3_context c,
    int i,
    Z3_ast t1,
  ) {
    return _mk_bit2bool(
      c,
      i,
      t1,
    );
  }

  late final _mk_bit2boolPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, ffi.UnsignedInt, Z3_ast)>>('Z3_mk_bit2bool');
  late final _mk_bit2bool =
      _mk_bit2boolPtr.asFunction<Z3_ast Function(Z3_context, int, Z3_ast)>();

  /// \brief Shift left.
  ///
  /// It is equivalent to multiplication by \ccode{2^x} where \c x is the value of the
  /// third argument.
  ///
  /// NB. The semantics of shift operations varies between environments. This
  /// definition does not necessarily capture directly the semantics of the
  /// programming language or assembly architecture you are modeling.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvshl', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_bvshl(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_bvshl(
      c,
      t1,
      t2,
    );
  }

  late final _mk_bvshlPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvshl');
  late final _mk_bvshl =
      _mk_bvshlPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Logical shift right.
  ///
  /// It is equivalent to unsigned division by \ccode{2^x} where \c x is the
  /// value of the third argument.
  ///
  /// NB. The semantics of shift operations varies between environments. This
  /// definition does not necessarily capture directly the semantics of the
  /// programming language or assembly architecture you are modeling.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvlshr', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_bvlshr(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_bvlshr(
      c,
      t1,
      t2,
    );
  }

  late final _mk_bvlshrPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvlshr');
  late final _mk_bvlshr =
      _mk_bvlshrPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Arithmetic shift right.
  ///
  /// It is like logical shift right except that the most significant
  /// bits of the result always copy the most significant bit of the
  /// second argument.
  ///
  /// The semantics of shift operations varies between environments. This
  /// definition does not necessarily capture directly the semantics of the
  /// programming language or assembly architecture you are modeling.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_bvashr', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_bvashr(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_bvashr(
      c,
      t1,
      t2,
    );
  }

  late final _mk_bvashrPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvashr');
  late final _mk_bvashr =
      _mk_bvashrPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Rotate bits of \c t1 to the left \c i times.
  ///
  /// The node \c t1 must have a bit-vector sort.
  ///
  /// def_API('Z3_mk_rotate_left', AST, (_in(CONTEXT), _in(UINT), _in(AST)))
  Z3_ast mk_rotate_left(
    Z3_context c,
    int i,
    Z3_ast t1,
  ) {
    return _mk_rotate_left(
      c,
      i,
      t1,
    );
  }

  late final _mk_rotate_leftPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, ffi.UnsignedInt, Z3_ast)>>('Z3_mk_rotate_left');
  late final _mk_rotate_left =
      _mk_rotate_leftPtr.asFunction<Z3_ast Function(Z3_context, int, Z3_ast)>();

  /// \brief Rotate bits of \c t1 to the right \c i times.
  ///
  /// The node \c t1 must have a bit-vector sort.
  ///
  /// def_API('Z3_mk_rotate_right', AST, (_in(CONTEXT), _in(UINT), _in(AST)))
  Z3_ast mk_rotate_right(
    Z3_context c,
    int i,
    Z3_ast t1,
  ) {
    return _mk_rotate_right(
      c,
      i,
      t1,
    );
  }

  late final _mk_rotate_rightPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, ffi.UnsignedInt, Z3_ast)>>('Z3_mk_rotate_right');
  late final _mk_rotate_right = _mk_rotate_rightPtr
      .asFunction<Z3_ast Function(Z3_context, int, Z3_ast)>();

  /// \brief Rotate bits of \c t1 to the left \c t2 times.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_ext_rotate_left', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_ext_rotate_left(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_ext_rotate_left(
      c,
      t1,
      t2,
    );
  }

  late final _mk_ext_rotate_leftPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_ext_rotate_left');
  late final _mk_ext_rotate_left = _mk_ext_rotate_leftPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Rotate bits of \c t1 to the right \c t2 times.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  ///
  /// def_API('Z3_mk_ext_rotate_right', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_ext_rotate_right(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_ext_rotate_right(
      c,
      t1,
      t2,
    );
  }

  late final _mk_ext_rotate_rightPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_ext_rotate_right');
  late final _mk_ext_rotate_right = _mk_ext_rotate_rightPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create an \c n bit bit-vector from the integer argument \c t1.
  ///
  /// The resulting bit-vector has \c n bits, where the i'th bit (counting
  /// from 0 to \c n-1) is 1 if \c (t1 div 2^i) mod 2 is 1.
  ///
  /// The node \c t1 must have integer sort.
  ///
  /// def_API('Z3_mk_int2bv', AST, (_in(CONTEXT), _in(UINT), _in(AST)))
  Z3_ast mk_int2bv(
    Z3_context c,
    int n,
    Z3_ast t1,
  ) {
    return _mk_int2bv(
      c,
      n,
      t1,
    );
  }

  late final _mk_int2bvPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, ffi.UnsignedInt, Z3_ast)>>('Z3_mk_int2bv');
  late final _mk_int2bv =
      _mk_int2bvPtr.asFunction<Z3_ast Function(Z3_context, int, Z3_ast)>();

  /// \brief Create an integer from the bit-vector argument \c t1.
  /// If \c is_signed is false, then the bit-vector \c t1 is treated as unsigned.
  /// So the result is non-negative
  /// and in the range \ccode{[0..2^N-1]}, where N are the number of bits in \c t1.
  /// If \c is_signed is true, \c t1 is treated as a signed bit-vector.
  ///
  ///
  /// The node \c t1 must have a bit-vector sort.
  ///
  /// def_API('Z3_mk_bv2int', AST, (_in(CONTEXT), _in(AST), _in(BOOL)))
  Z3_ast mk_bv2int(
    Z3_context c,
    Z3_ast t1,
    bool is_signed,
  ) {
    return _mk_bv2int(
      c,
      t1,
      is_signed,
    );
  }

  late final _mk_bv2intPtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, ffi.Bool)>>(
      'Z3_mk_bv2int');
  late final _mk_bv2int =
      _mk_bv2intPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, bool)>();

  /// \brief Create a predicate that checks that the bit-wise addition
  /// of \c t1 and \c t2 does not overflow.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  /// The returned node is of sort Bool.
  ///
  /// def_API('Z3_mk_bvadd_no_overflow', AST, (_in(CONTEXT), _in(AST), _in(AST), _in(BOOL)))
  Z3_ast mk_bvadd_no_overflow(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
    bool is_signed,
  ) {
    return _mk_bvadd_no_overflow(
      c,
      t1,
      t2,
      is_signed,
    );
  }

  late final _mk_bvadd_no_overflowPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast, Z3_ast,
              ffi.Bool)>>('Z3_mk_bvadd_no_overflow');
  late final _mk_bvadd_no_overflow = _mk_bvadd_no_overflowPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast, bool)>();

  /// \brief Create a predicate that checks that the bit-wise signed addition
  /// of \c t1 and \c t2 does not underflow.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  /// The returned node is of sort Bool.
  ///
  /// def_API('Z3_mk_bvadd_no_underflow', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_bvadd_no_underflow(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_bvadd_no_underflow(
      c,
      t1,
      t2,
    );
  }

  late final _mk_bvadd_no_underflowPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvadd_no_underflow');
  late final _mk_bvadd_no_underflow = _mk_bvadd_no_underflowPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create a predicate that checks that the bit-wise signed subtraction
  /// of \c t1 and \c t2 does not overflow.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  /// The returned node is of sort Bool.
  ///
  /// def_API('Z3_mk_bvsub_no_overflow', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_bvsub_no_overflow(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_bvsub_no_overflow(
      c,
      t1,
      t2,
    );
  }

  late final _mk_bvsub_no_overflowPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvsub_no_overflow');
  late final _mk_bvsub_no_overflow = _mk_bvsub_no_overflowPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create a predicate that checks that the bit-wise subtraction
  /// of \c t1 and \c t2 does not underflow.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  /// The returned node is of sort Bool.
  ///
  /// def_API('Z3_mk_bvsub_no_underflow', AST, (_in(CONTEXT), _in(AST), _in(AST), _in(BOOL)))
  Z3_ast mk_bvsub_no_underflow(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
    bool is_signed,
  ) {
    return _mk_bvsub_no_underflow(
      c,
      t1,
      t2,
      is_signed,
    );
  }

  late final _mk_bvsub_no_underflowPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast, Z3_ast,
              ffi.Bool)>>('Z3_mk_bvsub_no_underflow');
  late final _mk_bvsub_no_underflow = _mk_bvsub_no_underflowPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast, bool)>();

  /// \brief Create a predicate that checks that the bit-wise signed division
  /// of \c t1 and \c t2 does not overflow.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  /// The returned node is of sort Bool.
  ///
  /// def_API('Z3_mk_bvsdiv_no_overflow', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_bvsdiv_no_overflow(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_bvsdiv_no_overflow(
      c,
      t1,
      t2,
    );
  }

  late final _mk_bvsdiv_no_overflowPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvsdiv_no_overflow');
  late final _mk_bvsdiv_no_overflow = _mk_bvsdiv_no_overflowPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Check that bit-wise negation does not overflow when
  /// \c t1 is interpreted as a signed bit-vector.
  ///
  /// The node \c t1 must have bit-vector sort.
  /// The returned node is of sort Bool.
  ///
  /// def_API('Z3_mk_bvneg_no_overflow', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast mk_bvneg_no_overflow(
    Z3_context c,
    Z3_ast t1,
  ) {
    return _mk_bvneg_no_overflow(
      c,
      t1,
    );
  }

  late final _mk_bvneg_no_overflowPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_bvneg_no_overflow');
  late final _mk_bvneg_no_overflow = _mk_bvneg_no_overflowPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Create a predicate that checks that the bit-wise multiplication
  /// of \c t1 and \c t2 does not overflow.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  /// The returned node is of sort Bool.
  ///
  /// def_API('Z3_mk_bvmul_no_overflow', AST, (_in(CONTEXT), _in(AST), _in(AST), _in(BOOL)))
  Z3_ast mk_bvmul_no_overflow(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
    bool is_signed,
  ) {
    return _mk_bvmul_no_overflow(
      c,
      t1,
      t2,
      is_signed,
    );
  }

  late final _mk_bvmul_no_overflowPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast, Z3_ast,
              ffi.Bool)>>('Z3_mk_bvmul_no_overflow');
  late final _mk_bvmul_no_overflow = _mk_bvmul_no_overflowPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast, bool)>();

  /// \brief Create a predicate that checks that the bit-wise signed multiplication
  /// of \c t1 and \c t2 does not underflow.
  ///
  /// The nodes \c t1 and \c t2 must have the same bit-vector sort.
  /// The returned node is of sort Bool.
  ///
  /// def_API('Z3_mk_bvmul_no_underflow', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_bvmul_no_underflow(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_bvmul_no_underflow(
      c,
      t1,
      t2,
    );
  }

  late final _mk_bvmul_no_underflowPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_bvmul_no_underflow');
  late final _mk_bvmul_no_underflow = _mk_bvmul_no_underflowPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// @name Arrays */
  /// /**@{*/
  /// /**
  /// \brief Array read.
  /// The argument \c a is the array and \c i is the index of the array that gets read.
  ///
  /// The node \c a must have an array sort \ccode{[domain -> range]},
  /// and \c i must have the sort \c domain.
  /// The sort of the result is \c range.
  ///
  /// \sa Z3_mk_array_sort
  /// \sa Z3_mk_store
  ///
  /// def_API('Z3_mk_select', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_select(
    Z3_context c,
    Z3_ast a,
    Z3_ast i,
  ) {
    return _mk_select(
      c,
      a,
      i,
    );
  }

  late final _mk_selectPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_select');
  late final _mk_select =
      _mk_selectPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief n-ary Array read.
  /// The argument \c a is the array and \c idxs are the indices of the array that gets read.
  ///
  /// def_API('Z3_mk_select_n', AST, (_in(CONTEXT), _in(AST), _in(UINT), _in_array(2, AST)))
  Z3_ast mk_select_n(
    Z3_context c,
    Z3_ast a,
    int n,
    ffi.Pointer<Z3_ast> idxs,
  ) {
    return _mk_select_n(
      c,
      a,
      n,
      idxs,
    );
  }

  late final _mk_select_nPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_mk_select_n');
  late final _mk_select_n = _mk_select_nPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Array update.
  ///
  /// The node \c a must have an array sort \ccode{[domain -> range]}, \c i must have sort \c domain,
  /// \c v must have sort range. The sort of the result is \ccode{[domain -> range]}.
  /// The semantics of this function is given by the theory of arrays described in the SMT-LIB
  /// standard. See http://smtlib.org for more details.
  /// The result of this function is an array that is equal to \c a (with respect to \c select)
  /// on all indices except for \c i, where it maps to \c v (and the \c select of \c a with
  /// respect to \c i may be a different value).
  ///
  /// \sa Z3_mk_array_sort
  /// \sa Z3_mk_select
  ///
  /// def_API('Z3_mk_store', AST, (_in(CONTEXT), _in(AST), _in(AST), _in(AST)))
  Z3_ast mk_store(
    Z3_context c,
    Z3_ast a,
    Z3_ast i,
    Z3_ast v,
  ) {
    return _mk_store(
      c,
      a,
      i,
      v,
    );
  }

  late final _mk_storePtr = _lookup<
          ffi
          .NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>>(
      'Z3_mk_store');
  late final _mk_store = _mk_storePtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>();

  /// \brief n-ary Array update.
  ///
  /// def_API('Z3_mk_store_n', AST, (_in(CONTEXT), _in(AST), _in(UINT), _in_array(2, AST), _in(AST)))
  Z3_ast mk_store_n(
    Z3_context c,
    Z3_ast a,
    int n,
    ffi.Pointer<Z3_ast> idxs,
    Z3_ast v,
  ) {
    return _mk_store_n(
      c,
      a,
      n,
      idxs,
      v,
    );
  }

  late final _mk_store_nPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>, Z3_ast)>>('Z3_mk_store_n');
  late final _mk_store_n = _mk_store_nPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, int, ffi.Pointer<Z3_ast>, Z3_ast)>();

  /// \brief Create the constant array.
  ///
  /// The resulting term is an array, such that a \c select on an arbitrary index
  /// produces the value \c v.
  ///
  /// \param c logical context.
  /// \param domain domain sort for the array.
  /// \param v value that the array maps to.
  ///
  /// def_API('Z3_mk_const_array', AST, (_in(CONTEXT), _in(SORT), _in(AST)))
  Z3_ast mk_const_array(
    Z3_context c,
    Z3_sort domain,
    Z3_ast v,
  ) {
    return _mk_const_array(
      c,
      domain,
      v,
    );
  }

  late final _mk_const_arrayPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_sort, Z3_ast)>>(
          'Z3_mk_const_array');
  late final _mk_const_array = _mk_const_arrayPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_sort, Z3_ast)>();

  /// \brief Map f on the argument arrays.
  ///
  /// The \c n nodes \c args must be of array sorts \ccode{[domain_i -> range_i]}.
  /// The function declaration \c f must have type \ccode{ range_1 .. range_n -> range}.
  /// \c v must have sort range. The sort of the result is \ccode{[domain_i -> range]}.
  ///
  /// \sa Z3_mk_array_sort
  /// \sa Z3_mk_store
  /// \sa Z3_mk_select
  ///
  /// def_API('Z3_mk_map', AST, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT), _in_array(2, AST)))
  Z3_ast mk_map(
    Z3_context c,
    Z3_func_decl f,
    int n,
    ffi.Pointer<Z3_ast> args,
  ) {
    return _mk_map(
      c,
      f,
      n,
      args,
    );
  }

  late final _mk_mapPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_func_decl, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_mk_map');
  late final _mk_map = _mk_mapPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_func_decl, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Access the array default value.
  /// Produces the default range value, for arrays that can be represented as
  /// finite maps with a default range value.
  ///
  /// \param c logical context.
  /// \param array array value whose default range value is accessed.
  ///
  /// def_API('Z3_mk_array_default', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast mk_array_default(
    Z3_context c,
    Z3_ast array,
  ) {
    return _mk_array_default(
      c,
      array,
    );
  }

  late final _mk_array_defaultPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_array_default');
  late final _mk_array_default =
      _mk_array_defaultPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Create array with the same interpretation as a function.
  /// The array satisfies the property (f x) = (select (_ as-array f) x)
  /// for every argument x.
  ///
  /// def_API('Z3_mk_as_array', AST, (_in(CONTEXT), _in(FUNC_DECL)))
  Z3_ast mk_as_array(
    Z3_context c,
    Z3_func_decl f,
  ) {
    return _mk_as_array(
      c,
      f,
    );
  }

  late final _mk_as_arrayPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_func_decl)>>(
          'Z3_mk_as_array');
  late final _mk_as_array =
      _mk_as_arrayPtr.asFunction<Z3_ast Function(Z3_context, Z3_func_decl)>();

  /// \brief Create predicate that holds if Boolean array \c set has \c k elements set to true.
  ///
  /// def_API('Z3_mk_set_has_size', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_set_has_size(
    Z3_context c,
    Z3_ast set1,
    Z3_ast k,
  ) {
    return _mk_set_has_size(
      c,
      set1,
      k,
    );
  }

  late final _mk_set_has_sizePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_set_has_size');
  late final _mk_set_has_size = _mk_set_has_sizePtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// @name Sets */
  /// /**@{*/
  /// /**
  /// \brief Create Set type.
  ///
  /// def_API('Z3_mk_set_sort', SORT, (_in(CONTEXT), _in(SORT)))
  Z3_sort mk_set_sort(
    Z3_context c,
    Z3_sort ty,
  ) {
    return _mk_set_sort(
      c,
      ty,
    );
  }

  late final _mk_set_sortPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context, Z3_sort)>>(
          'Z3_mk_set_sort');
  late final _mk_set_sort =
      _mk_set_sortPtr.asFunction<Z3_sort Function(Z3_context, Z3_sort)>();

  /// \brief Create the empty set.
  ///
  /// def_API('Z3_mk_empty_set', AST, (_in(CONTEXT), _in(SORT)))
  Z3_ast mk_empty_set(
    Z3_context c,
    Z3_sort domain,
  ) {
    return _mk_empty_set(
      c,
      domain,
    );
  }

  late final _mk_empty_setPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_sort)>>(
          'Z3_mk_empty_set');
  late final _mk_empty_set =
      _mk_empty_setPtr.asFunction<Z3_ast Function(Z3_context, Z3_sort)>();

  /// \brief Create the full set.
  ///
  /// def_API('Z3_mk_full_set', AST, (_in(CONTEXT), _in(SORT)))
  Z3_ast mk_full_set(
    Z3_context c,
    Z3_sort domain,
  ) {
    return _mk_full_set(
      c,
      domain,
    );
  }

  late final _mk_full_setPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_sort)>>(
          'Z3_mk_full_set');
  late final _mk_full_set =
      _mk_full_setPtr.asFunction<Z3_ast Function(Z3_context, Z3_sort)>();

  /// \brief Add an element to a set.
  ///
  /// The first argument must be a set, the second an element.
  ///
  /// def_API('Z3_mk_set_add', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_set_add(
    Z3_context c,
    Z3_ast set1,
    Z3_ast elem,
  ) {
    return _mk_set_add(
      c,
      set1,
      elem,
    );
  }

  late final _mk_set_addPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_set_add');
  late final _mk_set_add =
      _mk_set_addPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Remove an element to a set.
  ///
  /// The first argument must be a set, the second an element.
  ///
  /// def_API('Z3_mk_set_del', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_set_del(
    Z3_context c,
    Z3_ast set1,
    Z3_ast elem,
  ) {
    return _mk_set_del(
      c,
      set1,
      elem,
    );
  }

  late final _mk_set_delPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_set_del');
  late final _mk_set_del =
      _mk_set_delPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Take the union of a list of sets.
  ///
  /// def_API('Z3_mk_set_union', AST, (_in(CONTEXT), _in(UINT), _in_array(1, AST)))
  Z3_ast mk_set_union(
    Z3_context c,
    int num_args,
    ffi.Pointer<Z3_ast> args,
  ) {
    return _mk_set_union(
      c,
      num_args,
      args,
    );
  }

  late final _mk_set_unionPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_mk_set_union');
  late final _mk_set_union = _mk_set_unionPtr
      .asFunction<Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Take the intersection of a list of sets.
  ///
  /// def_API('Z3_mk_set_intersect', AST, (_in(CONTEXT), _in(UINT), _in_array(1, AST)))
  Z3_ast mk_set_intersect(
    Z3_context c,
    int num_args,
    ffi.Pointer<Z3_ast> args,
  ) {
    return _mk_set_intersect(
      c,
      num_args,
      args,
    );
  }

  late final _mk_set_intersectPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_mk_set_intersect');
  late final _mk_set_intersect = _mk_set_intersectPtr
      .asFunction<Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Take the set difference between two sets.
  ///
  /// def_API('Z3_mk_set_difference', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_set_difference(
    Z3_context c,
    Z3_ast arg1,
    Z3_ast arg2,
  ) {
    return _mk_set_difference(
      c,
      arg1,
      arg2,
    );
  }

  late final _mk_set_differencePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_set_difference');
  late final _mk_set_difference = _mk_set_differencePtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Take the complement of a set.
  ///
  /// def_API('Z3_mk_set_complement', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast mk_set_complement(
    Z3_context c,
    Z3_ast arg,
  ) {
    return _mk_set_complement(
      c,
      arg,
    );
  }

  late final _mk_set_complementPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_set_complement');
  late final _mk_set_complement =
      _mk_set_complementPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Check for set membership.
  ///
  /// The first argument should be an element type of the set.
  ///
  /// def_API('Z3_mk_set_member', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_set_member(
    Z3_context c,
    Z3_ast elem,
    Z3_ast set1,
  ) {
    return _mk_set_member(
      c,
      elem,
      set1,
    );
  }

  late final _mk_set_memberPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_set_member');
  late final _mk_set_member = _mk_set_memberPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Check for subsetness of sets.
  ///
  /// def_API('Z3_mk_set_subset', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_set_subset(
    Z3_context c,
    Z3_ast arg1,
    Z3_ast arg2,
  ) {
    return _mk_set_subset(
      c,
      arg1,
      arg2,
    );
  }

  late final _mk_set_subsetPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_set_subset');
  late final _mk_set_subset = _mk_set_subsetPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create array extensionality index given two arrays with the same sort.
  /// The meaning is given by the axiom:
  /// (=> (= (select A (array-ext A B)) (select B (array-ext A B))) (= A B))
  ///
  /// def_API('Z3_mk_array_ext', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_array_ext(
    Z3_context c,
    Z3_ast arg1,
    Z3_ast arg2,
  ) {
    return _mk_array_ext(
      c,
      arg1,
      arg2,
    );
  }

  late final _mk_array_extPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_array_ext');
  late final _mk_array_ext = _mk_array_extPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// @name Numerals */
  /// /**@{*/
  /// /**
  /// \brief Create a numeral of a given sort.
  ///
  /// \param c logical context.
  /// \param numeral A string representing the numeral value in decimal notation. The string may be of the form `[num]*[.[num]*][E[+|-][num]+]`.
  /// If the given sort is a real, then the numeral can be a rational, that is, a string of the form `[num]* / [num]*` .
  /// \param ty The sort of the numeral. In the current implementation, the given sort can be an int, real, finite-domain, or bit-vectors of arbitrary size.
  ///
  /// \sa Z3_mk_int
  /// \sa Z3_mk_unsigned_int
  ///
  /// def_API('Z3_mk_numeral', AST, (_in(CONTEXT), _in(STRING), _in(SORT)))
  Z3_ast mk_numeral(
    Z3_context c,
    Z3_string numeral,
    Z3_sort ty,
  ) {
    return _mk_numeral(
      c,
      numeral,
      ty,
    );
  }

  late final _mk_numeralPtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_string, Z3_sort)>>(
      'Z3_mk_numeral');
  late final _mk_numeral = _mk_numeralPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_string, Z3_sort)>();

  /// \brief Create a real from a fraction.
  ///
  /// \param c logical context.
  /// \param num numerator of rational.
  /// \param den denominator of rational.
  ///
  /// \pre den != 0
  ///
  /// \sa Z3_mk_numeral
  /// \sa Z3_mk_int
  /// \sa Z3_mk_real_int64
  /// \sa Z3_mk_unsigned_int
  ///
  /// def_API('Z3_mk_real', AST, (_in(CONTEXT), _in(INT), _in(INT)))
  Z3_ast mk_real(
    Z3_context c,
    int num,
    int den,
  ) {
    return _mk_real(
      c,
      num,
      den,
    );
  }

  late final _mk_realPtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, ffi.Int, ffi.Int)>>(
      'Z3_mk_real');
  late final _mk_real =
      _mk_realPtr.asFunction<Z3_ast Function(Z3_context, int, int)>();

  /// \brief Create a real from a fraction of int64.
  ///
  /// \sa Z3_mk_real
  /// def_API('Z3_mk_real_int64', AST, (_in(CONTEXT), _in(INT64), _in(INT64)))
  Z3_ast mk_real_int64(
    Z3_context c,
    int num,
    int den,
  ) {
    return _mk_real_int64(
      c,
      num,
      den,
    );
  }

  late final _mk_real_int64Ptr = _lookup<
          ffi
          .NativeFunction<Z3_ast Function(Z3_context, ffi.Int64, ffi.Int64)>>(
      'Z3_mk_real_int64');
  late final _mk_real_int64 =
      _mk_real_int64Ptr.asFunction<Z3_ast Function(Z3_context, int, int)>();

  /// \brief Create a numeral of an int, bit-vector, or finite-domain sort.
  ///
  /// This function can be used to create numerals that fit in a machine integer.
  /// It is slightly faster than #Z3_mk_numeral since it is not necessary to parse a string.
  ///
  /// \sa Z3_mk_numeral
  ///
  /// def_API('Z3_mk_int', AST, (_in(CONTEXT), _in(INT), _in(SORT)))
  Z3_ast mk_int(
    Z3_context c,
    int v,
    Z3_sort ty,
  ) {
    return _mk_int(
      c,
      v,
      ty,
    );
  }

  late final _mk_intPtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, ffi.Int, Z3_sort)>>(
      'Z3_mk_int');
  late final _mk_int =
      _mk_intPtr.asFunction<Z3_ast Function(Z3_context, int, Z3_sort)>();

  /// \brief Create a numeral of a int, bit-vector, or finite-domain sort.
  ///
  /// This function can be used to create numerals that fit in a machine unsigned integer.
  /// It is slightly faster than #Z3_mk_numeral since it is not necessary to parse a string.
  ///
  /// \sa Z3_mk_numeral
  ///
  /// def_API('Z3_mk_unsigned_int', AST, (_in(CONTEXT), _in(UINT), _in(SORT)))
  Z3_ast mk_unsigned_int(
    Z3_context c,
    int v,
    Z3_sort ty,
  ) {
    return _mk_unsigned_int(
      c,
      v,
      ty,
    );
  }

  late final _mk_unsigned_intPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, ffi.UnsignedInt, Z3_sort)>>('Z3_mk_unsigned_int');
  late final _mk_unsigned_int = _mk_unsigned_intPtr
      .asFunction<Z3_ast Function(Z3_context, int, Z3_sort)>();

  /// \brief Create a numeral of a int, bit-vector, or finite-domain sort.
  ///
  /// This function can be used to create numerals that fit in a machine \c int64_t integer.
  /// It is slightly faster than #Z3_mk_numeral since it is not necessary to parse a string.
  ///
  /// \sa Z3_mk_numeral
  ///
  /// def_API('Z3_mk_int64', AST, (_in(CONTEXT), _in(INT64), _in(SORT)))
  Z3_ast mk_int64(
    Z3_context c,
    int v,
    Z3_sort ty,
  ) {
    return _mk_int64(
      c,
      v,
      ty,
    );
  }

  late final _mk_int64Ptr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, ffi.Int64, Z3_sort)>>(
      'Z3_mk_int64');
  late final _mk_int64 =
      _mk_int64Ptr.asFunction<Z3_ast Function(Z3_context, int, Z3_sort)>();

  /// \brief Create a numeral of a int, bit-vector, or finite-domain sort.
  ///
  /// This function can be used to create numerals that fit in a machine \c uint64_t integer.
  /// It is slightly faster than #Z3_mk_numeral since it is not necessary to parse a string.
  ///
  /// \sa Z3_mk_numeral
  ///
  /// def_API('Z3_mk_unsigned_int64', AST, (_in(CONTEXT), _in(UINT64), _in(SORT)))
  Z3_ast mk_unsigned_int64(
    Z3_context c,
    int v,
    Z3_sort ty,
  ) {
    return _mk_unsigned_int64(
      c,
      v,
      ty,
    );
  }

  late final _mk_unsigned_int64Ptr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, ffi.Uint64, Z3_sort)>>(
      'Z3_mk_unsigned_int64');
  late final _mk_unsigned_int64 = _mk_unsigned_int64Ptr
      .asFunction<Z3_ast Function(Z3_context, int, Z3_sort)>();

  /// \brief create a bit-vector numeral from a vector of Booleans.
  ///
  /// \sa Z3_mk_numeral
  /// def_API('Z3_mk_bv_numeral', AST, (_in(CONTEXT), _in(UINT), _in_array(1, BOOL)))
  Z3_ast mk_bv_numeral(
    Z3_context c,
    int sz,
    ffi.Pointer<ffi.Bool> bits,
  ) {
    return _mk_bv_numeral(
      c,
      sz,
      bits,
    );
  }

  late final _mk_bv_numeralPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt,
              ffi.Pointer<ffi.Bool>)>>('Z3_mk_bv_numeral');
  late final _mk_bv_numeral = _mk_bv_numeralPtr
      .asFunction<Z3_ast Function(Z3_context, int, ffi.Pointer<ffi.Bool>)>();

  /// \brief Create a sequence sort out of the sort for the elements.
  ///
  /// def_API('Z3_mk_seq_sort', SORT, (_in(CONTEXT), _in(SORT)))
  Z3_sort mk_seq_sort(
    Z3_context c,
    Z3_sort s,
  ) {
    return _mk_seq_sort(
      c,
      s,
    );
  }

  late final _mk_seq_sortPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context, Z3_sort)>>(
          'Z3_mk_seq_sort');
  late final _mk_seq_sort =
      _mk_seq_sortPtr.asFunction<Z3_sort Function(Z3_context, Z3_sort)>();

  /// \brief Check if \c s is a sequence sort.
  ///
  /// def_API('Z3_is_seq_sort', BOOL, (_in(CONTEXT), _in(SORT)))
  bool is_seq_sort(
    Z3_context c,
    Z3_sort s,
  ) {
    return _is_seq_sort(
      c,
      s,
    );
  }

  late final _is_seq_sortPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_sort)>>(
          'Z3_is_seq_sort');
  late final _is_seq_sort =
      _is_seq_sortPtr.asFunction<bool Function(Z3_context, Z3_sort)>();

  /// \brief Retrieve basis sort for sequence sort.
  ///
  /// def_API('Z3_get_seq_sort_basis', SORT, (_in(CONTEXT), _in(SORT)))
  Z3_sort get_seq_sort_basis(
    Z3_context c,
    Z3_sort s,
  ) {
    return _get_seq_sort_basis(
      c,
      s,
    );
  }

  late final _get_seq_sort_basisPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context, Z3_sort)>>(
          'Z3_get_seq_sort_basis');
  late final _get_seq_sort_basis = _get_seq_sort_basisPtr
      .asFunction<Z3_sort Function(Z3_context, Z3_sort)>();

  /// \brief Create a regular expression sort out of a sequence sort.
  ///
  /// def_API('Z3_mk_re_sort', SORT, (_in(CONTEXT), _in(SORT)))
  Z3_sort mk_re_sort(
    Z3_context c,
    Z3_sort seq,
  ) {
    return _mk_re_sort(
      c,
      seq,
    );
  }

  late final _mk_re_sortPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context, Z3_sort)>>(
          'Z3_mk_re_sort');
  late final _mk_re_sort =
      _mk_re_sortPtr.asFunction<Z3_sort Function(Z3_context, Z3_sort)>();

  /// \brief Check if \c s is a regular expression sort.
  ///
  /// def_API('Z3_is_re_sort', BOOL, (_in(CONTEXT), _in(SORT)))
  bool is_re_sort(
    Z3_context c,
    Z3_sort s,
  ) {
    return _is_re_sort(
      c,
      s,
    );
  }

  late final _is_re_sortPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_sort)>>(
          'Z3_is_re_sort');
  late final _is_re_sort =
      _is_re_sortPtr.asFunction<bool Function(Z3_context, Z3_sort)>();

  /// \brief Retrieve basis sort for regex sort.
  ///
  /// def_API('Z3_get_re_sort_basis', SORT, (_in(CONTEXT), _in(SORT)))
  Z3_sort get_re_sort_basis(
    Z3_context c,
    Z3_sort s,
  ) {
    return _get_re_sort_basis(
      c,
      s,
    );
  }

  late final _get_re_sort_basisPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context, Z3_sort)>>(
          'Z3_get_re_sort_basis');
  late final _get_re_sort_basis =
      _get_re_sort_basisPtr.asFunction<Z3_sort Function(Z3_context, Z3_sort)>();

  /// \brief Create a sort for unicode strings.
  ///
  /// The sort for characters can be changed to ASCII by setting
  /// the global parameter \c encoding to \c ascii, or alternative
  /// to 16 bit characters by setting \c encoding to \c bmp.
  ///
  /// def_API('Z3_mk_string_sort', SORT, (_in(CONTEXT), ))
  Z3_sort mk_string_sort(
    Z3_context c,
  ) {
    return _mk_string_sort(
      c,
    );
  }

  late final _mk_string_sortPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context)>>(
          'Z3_mk_string_sort');
  late final _mk_string_sort =
      _mk_string_sortPtr.asFunction<Z3_sort Function(Z3_context)>();

  /// \brief Create a sort for unicode characters.
  ///
  /// The sort for characters can be changed to ASCII by setting
  /// the global parameter \c encoding to \c ascii, or alternative
  /// to 16 bit characters by setting \c encoding to \c bmp.
  ///
  /// def_API('Z3_mk_char_sort', SORT, (_in(CONTEXT), ))
  Z3_sort mk_char_sort(
    Z3_context c,
  ) {
    return _mk_char_sort(
      c,
    );
  }

  late final _mk_char_sortPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context)>>(
          'Z3_mk_char_sort');
  late final _mk_char_sort =
      _mk_char_sortPtr.asFunction<Z3_sort Function(Z3_context)>();

  /// \brief Check if \c s is a string sort.
  ///
  /// def_API('Z3_is_string_sort', BOOL, (_in(CONTEXT), _in(SORT)))
  bool is_string_sort(
    Z3_context c,
    Z3_sort s,
  ) {
    return _is_string_sort(
      c,
      s,
    );
  }

  late final _is_string_sortPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_sort)>>(
          'Z3_is_string_sort');
  late final _is_string_sort =
      _is_string_sortPtr.asFunction<bool Function(Z3_context, Z3_sort)>();

  /// \brief Check if \c s is a character sort.
  ///
  /// def_API('Z3_is_char_sort', BOOL, (_in(CONTEXT), _in(SORT)))
  bool is_char_sort(
    Z3_context c,
    Z3_sort s,
  ) {
    return _is_char_sort(
      c,
      s,
    );
  }

  late final _is_char_sortPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_sort)>>(
          'Z3_is_char_sort');
  late final _is_char_sort =
      _is_char_sortPtr.asFunction<bool Function(Z3_context, Z3_sort)>();

  /// \brief Create a string constant out of the string that is passed in
  /// The string may contain escape encoding for non-printable characters
  /// or characters outside of the basic printable ASCII range. For example,
  /// the escape encoding \\u{0} represents the character 0 and the encoding
  /// \\u{100} represents the character 256.
  ///
  /// def_API('Z3_mk_string', AST, (_in(CONTEXT), _in(STRING)))
  Z3_ast mk_string(
    Z3_context c,
    Z3_string s,
  ) {
    return _mk_string(
      c,
      s,
    );
  }

  late final _mk_stringPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_string)>>(
          'Z3_mk_string');
  late final _mk_string =
      _mk_stringPtr.asFunction<Z3_ast Function(Z3_context, Z3_string)>();

  /// \brief Create a string constant out of the string that is passed in
  /// It takes the length of the string as well to take into account
  /// 0 characters. The string is treated as if it is unescaped so a sequence
  /// of characters \\u{0} is treated as 5 characters and not the character 0.
  ///
  /// def_API('Z3_mk_lstring', AST, (_in(CONTEXT), _in(UINT), _in(STRING)))
  Z3_ast mk_lstring(
    Z3_context c,
    int len,
    Z3_string s,
  ) {
    return _mk_lstring(
      c,
      len,
      s,
    );
  }

  late final _mk_lstringPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, ffi.UnsignedInt, Z3_string)>>('Z3_mk_lstring');
  late final _mk_lstring =
      _mk_lstringPtr.asFunction<Z3_ast Function(Z3_context, int, Z3_string)>();

  /// \brief Create a string constant out of the string that is passed in
  /// It takes the length of the string as well to take into account
  /// 0 characters. The string is unescaped.
  ///
  /// def_API('Z3_mk_u32string', AST, (_in(CONTEXT), _in(UINT), _in_array(1, UINT)))
  Z3_ast mk_u32string(
    Z3_context c,
    int len,
    ffi.Pointer<ffi.UnsignedInt> chars,
  ) {
    return _mk_u32string(
      c,
      len,
      chars,
    );
  }

  late final _mk_u32stringPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt,
              ffi.Pointer<ffi.UnsignedInt>)>>('Z3_mk_u32string');
  late final _mk_u32string = _mk_u32stringPtr.asFunction<
      Z3_ast Function(Z3_context, int, ffi.Pointer<ffi.UnsignedInt>)>();

  /// \brief Determine if \c s is a string constant.
  ///
  /// def_API('Z3_is_string', BOOL, (_in(CONTEXT), _in(AST)))
  bool is_string(
    Z3_context c,
    Z3_ast s,
  ) {
    return _is_string(
      c,
      s,
    );
  }

  late final _is_stringPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_ast)>>(
          'Z3_is_string');
  late final _is_string =
      _is_stringPtr.asFunction<bool Function(Z3_context, Z3_ast)>();

  /// \brief Retrieve the string constant stored in \c s.
  /// Characters outside the basic printable ASCII range are escaped.
  ///
  /// \pre  Z3_is_string(c, s)
  ///
  /// def_API('Z3_get_string', STRING, (_in(CONTEXT), _in(AST)))
  Z3_string get_string(
    Z3_context c,
    Z3_ast s,
  ) {
    return _get_string(
      c,
      s,
    );
  }

  late final _get_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_ast)>>(
          'Z3_get_string');
  late final _get_string =
      _get_stringPtr.asFunction<Z3_string Function(Z3_context, Z3_ast)>();

  /// \brief Retrieve the string constant stored in \c s. The string can contain escape sequences.
  /// Characters in the range 1 to 255 are literal.
  /// Characters in the range 0, and 256 above are escaped.
  ///
  /// \pre  Z3_is_string(c, s)
  ///
  /// def_API('Z3_get_lstring', CHAR_PTR, (_in(CONTEXT), _in(AST), _out(UINT)))
  Z3_char_ptr get_lstring(
    Z3_context c,
    Z3_ast s,
    ffi.Pointer<ffi.UnsignedInt> length,
  ) {
    return _get_lstring(
      c,
      s,
      length,
    );
  }

  late final _get_lstringPtr = _lookup<
      ffi.NativeFunction<
          Z3_char_ptr Function(Z3_context, Z3_ast,
              ffi.Pointer<ffi.UnsignedInt>)>>('Z3_get_lstring');
  late final _get_lstring = _get_lstringPtr.asFunction<
      Z3_char_ptr Function(Z3_context, Z3_ast, ffi.Pointer<ffi.UnsignedInt>)>();

  /// \brief Retrieve the length of the unescaped string constant stored in \c s.
  ///
  /// \pre  Z3_is_string(c, s)
  ///
  /// def_API('Z3_get_string_length', UINT, (_in(CONTEXT), _in(AST)))
  int get_string_length(
    Z3_context c,
    Z3_ast s,
  ) {
    return _get_string_length(
      c,
      s,
    );
  }

  late final _get_string_lengthPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_ast)>>(
          'Z3_get_string_length');
  late final _get_string_length =
      _get_string_lengthPtr.asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Retrieve the unescaped string constant stored in \c s.
  ///
  /// \pre  Z3_is_string(c, s)
  ///
  /// \pre length contains the number of characters in s
  ///
  /// def_API('Z3_get_string_contents', VOID, (_in(CONTEXT), _in(AST), _in(UINT), _out_array(2, UINT)))
  void get_string_contents(
    Z3_context c,
    Z3_ast s,
    int length,
    ffi.Pointer<ffi.UnsignedInt> contents,
  ) {
    return _get_string_contents(
      c,
      s,
      length,
      contents,
    );
  }

  late final _get_string_contentsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_ast, ffi.UnsignedInt,
              ffi.Pointer<ffi.UnsignedInt>)>>('Z3_get_string_contents');
  late final _get_string_contents = _get_string_contentsPtr.asFunction<
      void Function(Z3_context, Z3_ast, int, ffi.Pointer<ffi.UnsignedInt>)>();

  /// \brief Create an empty sequence of the sequence sort \c seq.
  ///
  /// \pre s is a sequence sort.
  ///
  /// def_API('Z3_mk_seq_empty', AST ,(_in(CONTEXT), _in(SORT)))
  Z3_ast mk_seq_empty(
    Z3_context c,
    Z3_sort seq,
  ) {
    return _mk_seq_empty(
      c,
      seq,
    );
  }

  late final _mk_seq_emptyPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_sort)>>(
          'Z3_mk_seq_empty');
  late final _mk_seq_empty =
      _mk_seq_emptyPtr.asFunction<Z3_ast Function(Z3_context, Z3_sort)>();

  /// \brief Create a unit sequence of \c a.
  ///
  /// def_API('Z3_mk_seq_unit', AST ,(_in(CONTEXT), _in(AST)))
  Z3_ast mk_seq_unit(
    Z3_context c,
    Z3_ast a,
  ) {
    return _mk_seq_unit(
      c,
      a,
    );
  }

  late final _mk_seq_unitPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_seq_unit');
  late final _mk_seq_unit =
      _mk_seq_unitPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Concatenate sequences.
  ///
  /// \pre n > 0
  ///
  /// def_API('Z3_mk_seq_concat', AST ,(_in(CONTEXT), _in(UINT), _in_array(1, AST)))
  Z3_ast mk_seq_concat(
    Z3_context c,
    int n,
    ffi.Pointer<Z3_ast> args,
  ) {
    return _mk_seq_concat(
      c,
      n,
      args,
    );
  }

  late final _mk_seq_concatPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_mk_seq_concat');
  late final _mk_seq_concat = _mk_seq_concatPtr
      .asFunction<Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Check if \c prefix is a prefix of \c s.
  ///
  /// \pre prefix and s are the same sequence sorts.
  ///
  /// def_API('Z3_mk_seq_prefix', AST ,(_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_seq_prefix(
    Z3_context c,
    Z3_ast prefix,
    Z3_ast s,
  ) {
    return _mk_seq_prefix(
      c,
      prefix,
      s,
    );
  }

  late final _mk_seq_prefixPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_seq_prefix');
  late final _mk_seq_prefix = _mk_seq_prefixPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Check if \c suffix is a suffix of \c s.
  ///
  /// \pre \c suffix and \c s are the same sequence sorts.
  ///
  /// def_API('Z3_mk_seq_suffix', AST ,(_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_seq_suffix(
    Z3_context c,
    Z3_ast suffix,
    Z3_ast s,
  ) {
    return _mk_seq_suffix(
      c,
      suffix,
      s,
    );
  }

  late final _mk_seq_suffixPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_seq_suffix');
  late final _mk_seq_suffix = _mk_seq_suffixPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Check if \c container contains \c containee.
  ///
  /// \pre \c container and \c containee are the same sequence sorts.
  ///
  /// def_API('Z3_mk_seq_contains', AST ,(_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_seq_contains(
    Z3_context c,
    Z3_ast container,
    Z3_ast containee,
  ) {
    return _mk_seq_contains(
      c,
      container,
      containee,
    );
  }

  late final _mk_seq_containsPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_seq_contains');
  late final _mk_seq_contains = _mk_seq_containsPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Check if \c s1 is lexicographically strictly less than \c s2.
  ///
  /// \pre \c s1 and \c s2 are strings
  ///
  /// def_API('Z3_mk_str_lt', AST ,(_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_str_lt(
    Z3_context c,
    Z3_ast prefix,
    Z3_ast s,
  ) {
    return _mk_str_lt(
      c,
      prefix,
      s,
    );
  }

  late final _mk_str_ltPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_str_lt');
  late final _mk_str_lt =
      _mk_str_ltPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Check if \c s1 is equal or lexicographically strictly less than \c s2.
  ///
  /// \pre \c s1 and \c s2 are strings
  ///
  /// def_API('Z3_mk_str_le', AST ,(_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_str_le(
    Z3_context c,
    Z3_ast prefix,
    Z3_ast s,
  ) {
    return _mk_str_le(
      c,
      prefix,
      s,
    );
  }

  late final _mk_str_lePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_str_le');
  late final _mk_str_le =
      _mk_str_lePtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Extract subsequence starting at \c offset of \c length.
  ///
  /// def_API('Z3_mk_seq_extract', AST ,(_in(CONTEXT), _in(AST), _in(AST), _in(AST)))
  Z3_ast mk_seq_extract(
    Z3_context c,
    Z3_ast s,
    Z3_ast offset,
    Z3_ast length,
  ) {
    return _mk_seq_extract(
      c,
      s,
      offset,
      length,
    );
  }

  late final _mk_seq_extractPtr = _lookup<
          ffi
          .NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>>(
      'Z3_mk_seq_extract');
  late final _mk_seq_extract = _mk_seq_extractPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>();

  /// \brief Replace the first occurrence of \c src with \c dst in \c s.
  ///
  /// def_API('Z3_mk_seq_replace', AST ,(_in(CONTEXT), _in(AST), _in(AST), _in(AST)))
  Z3_ast mk_seq_replace(
    Z3_context c,
    Z3_ast s,
    Z3_ast src,
    Z3_ast dst,
  ) {
    return _mk_seq_replace(
      c,
      s,
      src,
      dst,
    );
  }

  late final _mk_seq_replacePtr = _lookup<
          ffi
          .NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>>(
      'Z3_mk_seq_replace');
  late final _mk_seq_replace = _mk_seq_replacePtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>();

  /// \brief Retrieve from \c s the unit sequence positioned at position \c index.
  /// The sequence is empty if the index is out of bounds.
  ///
  /// def_API('Z3_mk_seq_at', AST ,(_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_seq_at(
    Z3_context c,
    Z3_ast s,
    Z3_ast index,
  ) {
    return _mk_seq_at(
      c,
      s,
      index,
    );
  }

  late final _mk_seq_atPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_seq_at');
  late final _mk_seq_at =
      _mk_seq_atPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Retrieve from \c s the element positioned at position \c index.
  /// The function is under-specified if the index is out of bounds.
  ///
  /// def_API('Z3_mk_seq_nth', AST ,(_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_seq_nth(
    Z3_context c,
    Z3_ast s,
    Z3_ast index,
  ) {
    return _mk_seq_nth(
      c,
      s,
      index,
    );
  }

  late final _mk_seq_nthPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_seq_nth');
  late final _mk_seq_nth =
      _mk_seq_nthPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Return the length of the sequence \c s.
  ///
  /// def_API('Z3_mk_seq_length', AST ,(_in(CONTEXT), _in(AST)))
  Z3_ast mk_seq_length(
    Z3_context c,
    Z3_ast s,
  ) {
    return _mk_seq_length(
      c,
      s,
    );
  }

  late final _mk_seq_lengthPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_seq_length');
  late final _mk_seq_length =
      _mk_seq_lengthPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Return index of the first occurrence of \c substr in \c s starting from offset \c offset.
  /// If \c s does not contain \c substr, then the value is -1, if \c offset is the length of \c s, then the value is -1 as well.
  /// The value is -1 if \c offset is negative or larger than the length of \c s.
  ///
  /// def_API('Z3_mk_seq_index', AST ,(_in(CONTEXT), _in(AST), _in(AST), _in(AST)))
  Z3_ast mk_seq_index(
    Z3_context c,
    Z3_ast s,
    Z3_ast substr,
    Z3_ast offset,
  ) {
    return _mk_seq_index(
      c,
      s,
      substr,
      offset,
    );
  }

  late final _mk_seq_indexPtr = _lookup<
          ffi
          .NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>>(
      'Z3_mk_seq_index');
  late final _mk_seq_index = _mk_seq_indexPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>();

  /// \brief Return index of the last occurrence of \c substr in \c s.
  /// If \c s does not contain \c substr, then the value is -1,
  /// def_API('Z3_mk_seq_last_index', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_seq_last_index(
    Z3_context c,
    Z3_ast s,
    Z3_ast substr,
  ) {
    return _mk_seq_last_index(
      c,
      s,
      substr,
    );
  }

  late final _mk_seq_last_indexPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_seq_last_index');
  late final _mk_seq_last_index = _mk_seq_last_indexPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Convert string to integer.
  ///
  /// def_API('Z3_mk_str_to_int', AST ,(_in(CONTEXT), _in(AST)))
  Z3_ast mk_str_to_int(
    Z3_context c,
    Z3_ast s,
  ) {
    return _mk_str_to_int(
      c,
      s,
    );
  }

  late final _mk_str_to_intPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_str_to_int');
  late final _mk_str_to_int =
      _mk_str_to_intPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Integer to string conversion.
  ///
  /// def_API('Z3_mk_int_to_str', AST ,(_in(CONTEXT), _in(AST)))
  Z3_ast mk_int_to_str(
    Z3_context c,
    Z3_ast s,
  ) {
    return _mk_int_to_str(
      c,
      s,
    );
  }

  late final _mk_int_to_strPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_int_to_str');
  late final _mk_int_to_str =
      _mk_int_to_strPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief String to code conversion.
  ///
  /// def_API('Z3_mk_string_to_code', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast mk_string_to_code(
    Z3_context c,
    Z3_ast a,
  ) {
    return _mk_string_to_code(
      c,
      a,
    );
  }

  late final _mk_string_to_codePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_string_to_code');
  late final _mk_string_to_code =
      _mk_string_to_codePtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Code to string conversion.
  ///
  /// def_API('Z3_mk_string_from_code', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast mk_string_from_code(
    Z3_context c,
    Z3_ast a,
  ) {
    return _mk_string_from_code(
      c,
      a,
    );
  }

  late final _mk_string_from_codePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_string_from_code');
  late final _mk_string_from_code =
      _mk_string_from_codePtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Unsigned bit-vector to string conversion.
  ///
  /// def_API('Z3_mk_ubv_to_str', AST ,(_in(CONTEXT), _in(AST)))
  Z3_ast mk_ubv_to_str(
    Z3_context c,
    Z3_ast s,
  ) {
    return _mk_ubv_to_str(
      c,
      s,
    );
  }

  late final _mk_ubv_to_strPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_ubv_to_str');
  late final _mk_ubv_to_str =
      _mk_ubv_to_strPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Signed bit-vector to string conversion.
  ///
  /// def_API('Z3_mk_sbv_to_str', AST ,(_in(CONTEXT), _in(AST)))
  Z3_ast mk_sbv_to_str(
    Z3_context c,
    Z3_ast s,
  ) {
    return _mk_sbv_to_str(
      c,
      s,
    );
  }

  late final _mk_sbv_to_strPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_sbv_to_str');
  late final _mk_sbv_to_str =
      _mk_sbv_to_strPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Create a regular expression that accepts the sequence \c seq.
  ///
  /// def_API('Z3_mk_seq_to_re', AST ,(_in(CONTEXT), _in(AST)))
  Z3_ast mk_seq_to_re(
    Z3_context c,
    Z3_ast seq,
  ) {
    return _mk_seq_to_re(
      c,
      seq,
    );
  }

  late final _mk_seq_to_rePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_seq_to_re');
  late final _mk_seq_to_re =
      _mk_seq_to_rePtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Check if \c seq is in the language generated by the regular expression \c re.
  ///
  /// def_API('Z3_mk_seq_in_re', AST ,(_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_seq_in_re(
    Z3_context c,
    Z3_ast seq,
    Z3_ast re,
  ) {
    return _mk_seq_in_re(
      c,
      seq,
      re,
    );
  }

  late final _mk_seq_in_rePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_seq_in_re');
  late final _mk_seq_in_re = _mk_seq_in_rePtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create the regular language \c re+.
  ///
  /// def_API('Z3_mk_re_plus', AST ,(_in(CONTEXT), _in(AST)))
  Z3_ast mk_re_plus(
    Z3_context c,
    Z3_ast re,
  ) {
    return _mk_re_plus(
      c,
      re,
    );
  }

  late final _mk_re_plusPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_re_plus');
  late final _mk_re_plus =
      _mk_re_plusPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Create the regular language \c re*.
  ///
  /// def_API('Z3_mk_re_star', AST ,(_in(CONTEXT), _in(AST)))
  Z3_ast mk_re_star(
    Z3_context c,
    Z3_ast re,
  ) {
    return _mk_re_star(
      c,
      re,
    );
  }

  late final _mk_re_starPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_re_star');
  late final _mk_re_star =
      _mk_re_starPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Create the regular language \c [re].
  ///
  /// def_API('Z3_mk_re_option', AST ,(_in(CONTEXT), _in(AST)))
  Z3_ast mk_re_option(
    Z3_context c,
    Z3_ast re,
  ) {
    return _mk_re_option(
      c,
      re,
    );
  }

  late final _mk_re_optionPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_re_option');
  late final _mk_re_option =
      _mk_re_optionPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Create the union of the regular languages.
  ///
  /// \pre n > 0
  ///
  /// def_API('Z3_mk_re_union', AST ,(_in(CONTEXT), _in(UINT), _in_array(1, AST)))
  Z3_ast mk_re_union(
    Z3_context c,
    int n,
    ffi.Pointer<Z3_ast> args,
  ) {
    return _mk_re_union(
      c,
      n,
      args,
    );
  }

  late final _mk_re_unionPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_mk_re_union');
  late final _mk_re_union = _mk_re_unionPtr
      .asFunction<Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Create the concatenation of the regular languages.
  ///
  /// \pre n > 0
  ///
  /// def_API('Z3_mk_re_concat', AST ,(_in(CONTEXT), _in(UINT), _in_array(1, AST)))
  Z3_ast mk_re_concat(
    Z3_context c,
    int n,
    ffi.Pointer<Z3_ast> args,
  ) {
    return _mk_re_concat(
      c,
      n,
      args,
    );
  }

  late final _mk_re_concatPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_mk_re_concat');
  late final _mk_re_concat = _mk_re_concatPtr
      .asFunction<Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Create the range regular expression over two sequences of length 1.
  ///
  /// def_API('Z3_mk_re_range', AST ,(_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_re_range(
    Z3_context c,
    Z3_ast lo,
    Z3_ast hi,
  ) {
    return _mk_re_range(
      c,
      lo,
      hi,
    );
  }

  late final _mk_re_rangePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_re_range');
  late final _mk_re_range =
      _mk_re_rangePtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create a regular expression that accepts all singleton sequences of the regular expression sort
  ///
  /// def_API('Z3_mk_re_allchar', AST, (_in(CONTEXT), _in(SORT)))
  Z3_ast mk_re_allchar(
    Z3_context c,
    Z3_sort regex_sort,
  ) {
    return _mk_re_allchar(
      c,
      regex_sort,
    );
  }

  late final _mk_re_allcharPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_sort)>>(
          'Z3_mk_re_allchar');
  late final _mk_re_allchar =
      _mk_re_allcharPtr.asFunction<Z3_ast Function(Z3_context, Z3_sort)>();

  /// \brief Create a regular expression loop. The supplied regular expression \c r is repeated
  /// between \c lo and \c hi times. The \c lo should be below \c hi with one exception: when
  /// supplying the value \c hi as 0, the meaning is to repeat the argument \c r at least
  /// \c lo number of times, and with an unbounded upper bound.
  ///
  /// def_API('Z3_mk_re_loop', AST, (_in(CONTEXT), _in(AST), _in(UINT), _in(UINT)))
  Z3_ast mk_re_loop(
    Z3_context c,
    Z3_ast r,
    int lo,
    int hi,
  ) {
    return _mk_re_loop(
      c,
      r,
      lo,
      hi,
    );
  }

  late final _mk_re_loopPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast, ffi.UnsignedInt,
              ffi.UnsignedInt)>>('Z3_mk_re_loop');
  late final _mk_re_loop = _mk_re_loopPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, int, int)>();

  /// \brief Create a power regular expression.
  ///
  /// def_API('Z3_mk_re_power', AST, (_in(CONTEXT), _in(AST), _in(UINT)))
  Z3_ast mk_re_power(
    Z3_context c,
    Z3_ast re,
    int n,
  ) {
    return _mk_re_power(
      c,
      re,
      n,
    );
  }

  late final _mk_re_powerPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, Z3_ast, ffi.UnsignedInt)>>('Z3_mk_re_power');
  late final _mk_re_power =
      _mk_re_powerPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, int)>();

  /// \brief Create the intersection of the regular languages.
  ///
  /// \pre n > 0
  ///
  /// def_API('Z3_mk_re_intersect', AST ,(_in(CONTEXT), _in(UINT), _in_array(1, AST)))
  Z3_ast mk_re_intersect(
    Z3_context c,
    int n,
    ffi.Pointer<Z3_ast> args,
  ) {
    return _mk_re_intersect(
      c,
      n,
      args,
    );
  }

  late final _mk_re_intersectPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_mk_re_intersect');
  late final _mk_re_intersect = _mk_re_intersectPtr
      .asFunction<Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Create the complement of the regular language \c re.
  ///
  /// def_API('Z3_mk_re_complement', AST ,(_in(CONTEXT), _in(AST)))
  Z3_ast mk_re_complement(
    Z3_context c,
    Z3_ast re,
  ) {
    return _mk_re_complement(
      c,
      re,
    );
  }

  late final _mk_re_complementPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_re_complement');
  late final _mk_re_complement =
      _mk_re_complementPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Create the difference of regular expressions.
  ///
  /// def_API('Z3_mk_re_diff', AST ,(_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_re_diff(
    Z3_context c,
    Z3_ast re1,
    Z3_ast re2,
  ) {
    return _mk_re_diff(
      c,
      re1,
      re2,
    );
  }

  late final _mk_re_diffPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_re_diff');
  late final _mk_re_diff =
      _mk_re_diffPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create an empty regular expression of sort \c re.
  ///
  /// \pre re is a regular expression sort.
  ///
  /// def_API('Z3_mk_re_empty', AST ,(_in(CONTEXT), _in(SORT)))
  Z3_ast mk_re_empty(
    Z3_context c,
    Z3_sort re,
  ) {
    return _mk_re_empty(
      c,
      re,
    );
  }

  late final _mk_re_emptyPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_sort)>>(
          'Z3_mk_re_empty');
  late final _mk_re_empty =
      _mk_re_emptyPtr.asFunction<Z3_ast Function(Z3_context, Z3_sort)>();

  /// \brief Create an universal regular expression of sort \c re.
  ///
  /// \pre re is a regular expression sort.
  ///
  /// def_API('Z3_mk_re_full', AST ,(_in(CONTEXT), _in(SORT)))
  Z3_ast mk_re_full(
    Z3_context c,
    Z3_sort re,
  ) {
    return _mk_re_full(
      c,
      re,
    );
  }

  late final _mk_re_fullPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_sort)>>(
          'Z3_mk_re_full');
  late final _mk_re_full =
      _mk_re_fullPtr.asFunction<Z3_ast Function(Z3_context, Z3_sort)>();

  /// \brief Create a character literal
  /// def_API('Z3_mk_char', AST, (_in(CONTEXT), _in(UINT)))
  Z3_ast mk_char(
    Z3_context c,
    int ch,
  ) {
    return _mk_char(
      c,
      ch,
    );
  }

  late final _mk_charPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, ffi.UnsignedInt)>>(
          'Z3_mk_char');
  late final _mk_char =
      _mk_charPtr.asFunction<Z3_ast Function(Z3_context, int)>();

  /// \brief Create less than or equal to between two characters.
  ///
  /// def_API('Z3_mk_char_le', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast mk_char_le(
    Z3_context c,
    Z3_ast ch1,
    Z3_ast ch2,
  ) {
    return _mk_char_le(
      c,
      ch1,
      ch2,
    );
  }

  late final _mk_char_lePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_char_le');
  late final _mk_char_le =
      _mk_char_lePtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Create an integer (code point) from character.
  ///
  /// def_API('Z3_mk_char_to_int', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast mk_char_to_int(
    Z3_context c,
    Z3_ast ch,
  ) {
    return _mk_char_to_int(
      c,
      ch,
    );
  }

  late final _mk_char_to_intPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_char_to_int');
  late final _mk_char_to_int =
      _mk_char_to_intPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Create a bit-vector (code point) from character.
  ///
  /// def_API('Z3_mk_char_to_bv', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast mk_char_to_bv(
    Z3_context c,
    Z3_ast ch,
  ) {
    return _mk_char_to_bv(
      c,
      ch,
    );
  }

  late final _mk_char_to_bvPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_char_to_bv');
  late final _mk_char_to_bv =
      _mk_char_to_bvPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Create a character from a bit-vector (code point).
  ///
  /// def_API('Z3_mk_char_from_bv', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast mk_char_from_bv(
    Z3_context c,
    Z3_ast bv,
  ) {
    return _mk_char_from_bv(
      c,
      bv,
    );
  }

  late final _mk_char_from_bvPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_char_from_bv');
  late final _mk_char_from_bv =
      _mk_char_from_bvPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Create a check if the character is a digit.
  ///
  /// def_API('Z3_mk_char_is_digit', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast mk_char_is_digit(
    Z3_context c,
    Z3_ast ch,
  ) {
    return _mk_char_is_digit(
      c,
      ch,
    );
  }

  late final _mk_char_is_digitPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_char_is_digit');
  late final _mk_char_is_digit =
      _mk_char_is_digitPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// @name Special relations */
  /// /**@{*/
  /// /**
  /// \brief create a linear ordering relation over signature \c a.
  /// The relation is identified by the index \c id.
  ///
  /// def_API('Z3_mk_linear_order', FUNC_DECL ,(_in(CONTEXT), _in(SORT), _in(UINT)))
  Z3_func_decl mk_linear_order(
    Z3_context c,
    Z3_sort a,
    int id,
  ) {
    return _mk_linear_order(
      c,
      a,
      id,
    );
  }

  late final _mk_linear_orderPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_decl Function(
              Z3_context, Z3_sort, ffi.UnsignedInt)>>('Z3_mk_linear_order');
  late final _mk_linear_order = _mk_linear_orderPtr
      .asFunction<Z3_func_decl Function(Z3_context, Z3_sort, int)>();

  /// \brief create a partial ordering relation over signature \c a and index \c id.
  ///
  /// def_API('Z3_mk_partial_order', FUNC_DECL ,(_in(CONTEXT), _in(SORT), _in(UINT)))
  Z3_func_decl mk_partial_order(
    Z3_context c,
    Z3_sort a,
    int id,
  ) {
    return _mk_partial_order(
      c,
      a,
      id,
    );
  }

  late final _mk_partial_orderPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_decl Function(
              Z3_context, Z3_sort, ffi.UnsignedInt)>>('Z3_mk_partial_order');
  late final _mk_partial_order = _mk_partial_orderPtr
      .asFunction<Z3_func_decl Function(Z3_context, Z3_sort, int)>();

  /// \brief create a piecewise linear ordering relation over signature \c a and index \c id.
  ///
  /// def_API('Z3_mk_piecewise_linear_order', FUNC_DECL ,(_in(CONTEXT), _in(SORT), _in(UINT)))
  Z3_func_decl mk_piecewise_linear_order(
    Z3_context c,
    Z3_sort a,
    int id,
  ) {
    return _mk_piecewise_linear_order(
      c,
      a,
      id,
    );
  }

  late final _mk_piecewise_linear_orderPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_decl Function(Z3_context, Z3_sort,
              ffi.UnsignedInt)>>('Z3_mk_piecewise_linear_order');
  late final _mk_piecewise_linear_order = _mk_piecewise_linear_orderPtr
      .asFunction<Z3_func_decl Function(Z3_context, Z3_sort, int)>();

  /// \brief create a tree ordering relation over signature \c a identified using index \c id.
  ///
  /// def_API('Z3_mk_tree_order', FUNC_DECL, (_in(CONTEXT), _in(SORT), _in(UINT)))
  Z3_func_decl mk_tree_order(
    Z3_context c,
    Z3_sort a,
    int id,
  ) {
    return _mk_tree_order(
      c,
      a,
      id,
    );
  }

  late final _mk_tree_orderPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_decl Function(
              Z3_context, Z3_sort, ffi.UnsignedInt)>>('Z3_mk_tree_order');
  late final _mk_tree_order = _mk_tree_orderPtr
      .asFunction<Z3_func_decl Function(Z3_context, Z3_sort, int)>();

  /// \brief create transitive closure of binary relation.
  ///
  /// \pre f is a binary relation, such that the two arguments have the same sorts.
  ///
  /// The resulting relation f+ represents the transitive closure of f.
  ///
  /// def_API('Z3_mk_transitive_closure', FUNC_DECL ,(_in(CONTEXT), _in(FUNC_DECL)))
  Z3_func_decl mk_transitive_closure(
    Z3_context c,
    Z3_func_decl f,
  ) {
    return _mk_transitive_closure(
      c,
      f,
    );
  }

  late final _mk_transitive_closurePtr = _lookup<
          ffi.NativeFunction<Z3_func_decl Function(Z3_context, Z3_func_decl)>>(
      'Z3_mk_transitive_closure');
  late final _mk_transitive_closure = _mk_transitive_closurePtr
      .asFunction<Z3_func_decl Function(Z3_context, Z3_func_decl)>();

  /// @name Quantifiers */
  /// /**@{*/
  /// /**
  /// \brief Create a pattern for quantifier instantiation.
  ///
  /// Z3 uses pattern matching to instantiate quantifiers. If a
  /// pattern is not provided for a quantifier, then Z3 will
  /// automatically compute a set of patterns for it. However, for
  /// optimal performance, the user should provide the patterns.
  ///
  /// Patterns comprise a list of terms. The list should be
  /// non-empty.  If the list comprises of more than one term, it is
  /// a called a multi-pattern.
  ///
  /// In general, one can pass in a list of (multi-)patterns in the
  /// quantifier constructor.
  ///
  /// \sa Z3_mk_forall
  /// \sa Z3_mk_exists
  ///
  /// def_API('Z3_mk_pattern', PATTERN, (_in(CONTEXT), _in(UINT), _in_array(1, AST)))
  Z3_pattern mk_pattern(
    Z3_context c,
    int num_patterns,
    ffi.Pointer<Z3_ast> terms,
  ) {
    return _mk_pattern(
      c,
      num_patterns,
      terms,
    );
  }

  late final _mk_patternPtr = _lookup<
      ffi.NativeFunction<
          Z3_pattern Function(Z3_context, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_mk_pattern');
  late final _mk_pattern = _mk_patternPtr
      .asFunction<Z3_pattern Function(Z3_context, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Create a variable.
  ///
  /// Variables are intended to be bound by a scope created by a quantifier. So we call them bound variables
  /// even if they appear as free variables in the expression produced by \c Z3_mk_bound.
  ///
  /// Bound variables are indexed by de-Bruijn indices. It is perhaps easiest to explain
  /// the meaning of de-Bruijn indices by indicating the compilation process from
  /// non-de-Bruijn formulas to de-Bruijn format.
  ///
  /// \verbatim
  /// abs(forall (x1) phi) = forall (x1) abs1(phi, x1, 0)
  /// abs(forall (x1, x2) phi) = abs(forall (x1) abs(forall (x2) phi))
  /// abs1(x, x, n) = b_n
  /// abs1(y, x, n) = y
  /// abs1(f(t1,...,tn), x, n) = f(abs1(t1,x,n), ..., abs1(tn,x,n))
  /// abs1(forall (x1) phi, x, n) = forall (x1) (abs1(phi, x, n+1))
  /// \endverbatim
  ///
  /// The last line is significant: the index of a bound variable is different depending
  /// on the scope in which it appears. The deeper x appears, the higher is its
  /// index.
  ///
  /// \param c logical context
  /// \param index de-Bruijn index
  /// \param ty sort of the bound variable
  ///
  /// \sa Z3_mk_forall
  /// \sa Z3_mk_exists
  ///
  /// def_API('Z3_mk_bound', AST, (_in(CONTEXT), _in(UINT), _in(SORT)))
  Z3_ast mk_bound(
    Z3_context c,
    int index,
    Z3_sort ty,
  ) {
    return _mk_bound(
      c,
      index,
      ty,
    );
  }

  late final _mk_boundPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, ffi.UnsignedInt, Z3_sort)>>('Z3_mk_bound');
  late final _mk_bound =
      _mk_boundPtr.asFunction<Z3_ast Function(Z3_context, int, Z3_sort)>();

  /// \brief Create a forall formula. It takes an expression \c body that contains bound variables
  /// of the same sorts as the sorts listed in the array \c sorts. The bound variables are de-Bruijn indices created
  /// using #Z3_mk_bound. The array \c decl_names contains the names that the quantified formula uses for the
  /// bound variables. Z3 applies the convention that the last element in the \c decl_names and \c sorts array
  /// refers to the variable with index 0, the second to last element of \c decl_names and \c sorts refers
  /// to the variable with index 1, etc.
  ///
  /// \param c logical context.
  /// \param weight quantifiers are associated with weights indicating the importance of using the quantifier during instantiation. By default, pass the weight 0.
  /// \param num_patterns number of patterns.
  /// \param patterns array containing the patterns created using #Z3_mk_pattern.
  /// \param num_decls number of variables to be bound.
  /// \param sorts the sorts of the bound variables.
  /// \param decl_names names of the bound variables
  /// \param body the body of the quantifier.
  ///
  /// \sa Z3_mk_pattern
  /// \sa Z3_mk_bound
  /// \sa Z3_mk_exists
  ///
  /// def_API('Z3_mk_forall', AST, (_in(CONTEXT), _in(UINT), _in(UINT), _in_array(2, PATTERN), _in(UINT), _in_array(4, SORT), _in_array(4, SYMBOL), _in(AST)))
  Z3_ast mk_forall(
    Z3_context c,
    int weight,
    int num_patterns,
    ffi.Pointer<Z3_pattern> patterns,
    int num_decls,
    ffi.Pointer<Z3_sort> sorts,
    ffi.Pointer<Z3_symbol> decl_names,
    Z3_ast body,
  ) {
    return _mk_forall(
      c,
      weight,
      num_patterns,
      patterns,
      num_decls,
      sorts,
      decl_names,
      body,
    );
  }

  late final _mk_forallPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_pattern>,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_sort>,
              ffi.Pointer<Z3_symbol>,
              Z3_ast)>>('Z3_mk_forall');
  late final _mk_forall = _mk_forallPtr.asFunction<
      Z3_ast Function(Z3_context, int, int, ffi.Pointer<Z3_pattern>, int,
          ffi.Pointer<Z3_sort>, ffi.Pointer<Z3_symbol>, Z3_ast)>();

  /// \brief Create an exists formula. Similar to #Z3_mk_forall.
  ///
  /// \sa Z3_mk_pattern
  /// \sa Z3_mk_bound
  /// \sa Z3_mk_forall
  /// \sa Z3_mk_quantifier
  ///
  /// def_API('Z3_mk_exists', AST, (_in(CONTEXT), _in(UINT), _in(UINT), _in_array(2, PATTERN), _in(UINT), _in_array(4, SORT), _in_array(4, SYMBOL), _in(AST)))
  Z3_ast mk_exists(
    Z3_context c,
    int weight,
    int num_patterns,
    ffi.Pointer<Z3_pattern> patterns,
    int num_decls,
    ffi.Pointer<Z3_sort> sorts,
    ffi.Pointer<Z3_symbol> decl_names,
    Z3_ast body,
  ) {
    return _mk_exists(
      c,
      weight,
      num_patterns,
      patterns,
      num_decls,
      sorts,
      decl_names,
      body,
    );
  }

  late final _mk_existsPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_pattern>,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_sort>,
              ffi.Pointer<Z3_symbol>,
              Z3_ast)>>('Z3_mk_exists');
  late final _mk_exists = _mk_existsPtr.asFunction<
      Z3_ast Function(Z3_context, int, int, ffi.Pointer<Z3_pattern>, int,
          ffi.Pointer<Z3_sort>, ffi.Pointer<Z3_symbol>, Z3_ast)>();

  /// \brief Create a quantifier - universal or existential, with pattern hints.
  /// See the documentation for #Z3_mk_forall for an explanation of the parameters.
  ///
  /// \param c logical context.
  /// \param is_forall flag to indicate if this is a universal or existential quantifier.
  /// \param weight quantifiers are associated with weights indicating the importance of using the quantifier during instantiation. By default, pass the weight 0.
  /// \param num_patterns number of patterns.
  /// \param patterns array containing the patterns created using #Z3_mk_pattern.
  /// \param num_decls number of variables to be bound.
  /// \param sorts array of sorts of the bound variables.
  /// \param decl_names names of the bound variables.
  /// \param body the body of the quantifier.
  ///
  /// \sa Z3_mk_pattern
  /// \sa Z3_mk_bound
  /// \sa Z3_mk_forall
  /// \sa Z3_mk_exists
  ///
  /// def_API('Z3_mk_quantifier', AST, (_in(CONTEXT), _in(BOOL), _in(UINT), _in(UINT), _in_array(3, PATTERN), _in(UINT), _in_array(5, SORT), _in_array(5, SYMBOL), _in(AST)))
  Z3_ast mk_quantifier(
    Z3_context c,
    bool is_forall,
    int weight,
    int num_patterns,
    ffi.Pointer<Z3_pattern> patterns,
    int num_decls,
    ffi.Pointer<Z3_sort> sorts,
    ffi.Pointer<Z3_symbol> decl_names,
    Z3_ast body,
  ) {
    return _mk_quantifier(
      c,
      is_forall,
      weight,
      num_patterns,
      patterns,
      num_decls,
      sorts,
      decl_names,
      body,
    );
  }

  late final _mk_quantifierPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context,
              ffi.Bool,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_pattern>,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_sort>,
              ffi.Pointer<Z3_symbol>,
              Z3_ast)>>('Z3_mk_quantifier');
  late final _mk_quantifier = _mk_quantifierPtr.asFunction<
      Z3_ast Function(Z3_context, bool, int, int, ffi.Pointer<Z3_pattern>, int,
          ffi.Pointer<Z3_sort>, ffi.Pointer<Z3_symbol>, Z3_ast)>();

  /// \brief Create a quantifier - universal or existential, with pattern hints, no patterns, and attributes
  ///
  /// \param c logical context.
  /// \param is_forall flag to indicate if this is a universal or existential quantifier.
  /// \param quantifier_id identifier to identify quantifier
  /// \param skolem_id identifier to identify skolem constants introduced by quantifier.
  /// \param weight quantifiers are associated with weights indicating the importance of using the quantifier during instantiation. By default, pass the weight 0.
  /// \param num_patterns number of patterns.
  /// \param patterns array containing the patterns created using #Z3_mk_pattern.
  /// \param num_no_patterns number of no_patterns.
  /// \param no_patterns array containing subexpressions to be excluded from inferred patterns.
  /// \param num_decls number of variables to be bound.
  /// \param sorts array of sorts of the bound variables.
  /// \param decl_names names of the bound variables.
  /// \param body the body of the quantifier.
  ///
  /// \sa Z3_mk_pattern
  /// \sa Z3_mk_bound
  /// \sa Z3_mk_forall
  /// \sa Z3_mk_exists
  ///
  /// def_API('Z3_mk_quantifier_ex', AST, (_in(CONTEXT), _in(BOOL), _in(UINT), _in(SYMBOL), _in(SYMBOL), _in(UINT), _in_array(5, PATTERN), _in(UINT), _in_array(7, AST), _in(UINT), _in_array(9, SORT), _in_array(9, SYMBOL), _in(AST)))
  Z3_ast mk_quantifier_ex(
    Z3_context c,
    bool is_forall,
    int weight,
    Z3_symbol quantifier_id,
    Z3_symbol skolem_id,
    int num_patterns,
    ffi.Pointer<Z3_pattern> patterns,
    int num_no_patterns,
    ffi.Pointer<Z3_ast> no_patterns,
    int num_decls,
    ffi.Pointer<Z3_sort> sorts,
    ffi.Pointer<Z3_symbol> decl_names,
    Z3_ast body,
  ) {
    return _mk_quantifier_ex(
      c,
      is_forall,
      weight,
      quantifier_id,
      skolem_id,
      num_patterns,
      patterns,
      num_no_patterns,
      no_patterns,
      num_decls,
      sorts,
      decl_names,
      body,
    );
  }

  late final _mk_quantifier_exPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context,
              ffi.Bool,
              ffi.UnsignedInt,
              Z3_symbol,
              Z3_symbol,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_pattern>,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_sort>,
              ffi.Pointer<Z3_symbol>,
              Z3_ast)>>('Z3_mk_quantifier_ex');
  late final _mk_quantifier_ex = _mk_quantifier_exPtr.asFunction<
      Z3_ast Function(
          Z3_context,
          bool,
          int,
          Z3_symbol,
          Z3_symbol,
          int,
          ffi.Pointer<Z3_pattern>,
          int,
          ffi.Pointer<Z3_ast>,
          int,
          ffi.Pointer<Z3_sort>,
          ffi.Pointer<Z3_symbol>,
          Z3_ast)>();

  /// \brief Create a universal quantifier using a list of constants that
  /// will form the set of bound variables.
  ///
  /// \param c logical context.
  /// \param weight quantifiers are associated with weights indicating the importance of using
  /// the quantifier during instantiation. By default, pass the weight 0.
  /// \param num_bound number of constants to be abstracted into bound variables.
  /// \param bound array of constants to be abstracted into bound variables.
  /// \param num_patterns number of patterns.
  /// \param patterns array containing the patterns created using #Z3_mk_pattern.
  /// \param body the body of the quantifier.
  ///
  /// \sa Z3_mk_pattern
  /// \sa Z3_mk_exists_const
  ///
  /// def_API('Z3_mk_forall_const', AST, (_in(CONTEXT), _in(UINT), _in(UINT), _in_array(2, APP), _in(UINT), _in_array(4, PATTERN), _in(AST)))
  Z3_ast mk_forall_const(
    Z3_context c,
    int weight,
    int num_bound,
    ffi.Pointer<Z3_app> bound,
    int num_patterns,
    ffi.Pointer<Z3_pattern> patterns,
    Z3_ast body,
  ) {
    return _mk_forall_const(
      c,
      weight,
      num_bound,
      bound,
      num_patterns,
      patterns,
      body,
    );
  }

  late final _mk_forall_constPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_app>,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_pattern>,
              Z3_ast)>>('Z3_mk_forall_const');
  late final _mk_forall_const = _mk_forall_constPtr.asFunction<
      Z3_ast Function(Z3_context, int, int, ffi.Pointer<Z3_app>, int,
          ffi.Pointer<Z3_pattern>, Z3_ast)>();

  /// \brief Similar to #Z3_mk_forall_const.
  ///
  /// \brief Create an existential quantifier using a list of constants that
  /// will form the set of bound variables.
  ///
  /// \param c logical context.
  /// \param weight quantifiers are associated with weights indicating the importance of using
  /// the quantifier during instantiation. By default, pass the weight 0.
  /// \param num_bound number of constants to be abstracted into bound variables.
  /// \param bound array of constants to be abstracted into bound variables.
  /// \param num_patterns number of patterns.
  /// \param patterns array containing the patterns created using #Z3_mk_pattern.
  /// \param body the body of the quantifier.
  ///
  /// \sa Z3_mk_pattern
  /// \sa Z3_mk_forall_const
  ///
  /// def_API('Z3_mk_exists_const', AST, (_in(CONTEXT), _in(UINT), _in(UINT), _in_array(2, APP), _in(UINT), _in_array(4, PATTERN), _in(AST)))
  Z3_ast mk_exists_const(
    Z3_context c,
    int weight,
    int num_bound,
    ffi.Pointer<Z3_app> bound,
    int num_patterns,
    ffi.Pointer<Z3_pattern> patterns,
    Z3_ast body,
  ) {
    return _mk_exists_const(
      c,
      weight,
      num_bound,
      bound,
      num_patterns,
      patterns,
      body,
    );
  }

  late final _mk_exists_constPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_app>,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_pattern>,
              Z3_ast)>>('Z3_mk_exists_const');
  late final _mk_exists_const = _mk_exists_constPtr.asFunction<
      Z3_ast Function(Z3_context, int, int, ffi.Pointer<Z3_app>, int,
          ffi.Pointer<Z3_pattern>, Z3_ast)>();

  /// \brief Create a universal or existential quantifier using a list of
  /// constants that will form the set of bound variables.
  ///
  /// def_API('Z3_mk_quantifier_const', AST, (_in(CONTEXT), _in(BOOL), _in(UINT), _in(UINT), _in_array(3, APP), _in(UINT), _in_array(5, PATTERN), _in(AST)))
  Z3_ast mk_quantifier_const(
    Z3_context c,
    bool is_forall,
    int weight,
    int num_bound,
    ffi.Pointer<Z3_app> bound,
    int num_patterns,
    ffi.Pointer<Z3_pattern> patterns,
    Z3_ast body,
  ) {
    return _mk_quantifier_const(
      c,
      is_forall,
      weight,
      num_bound,
      bound,
      num_patterns,
      patterns,
      body,
    );
  }

  late final _mk_quantifier_constPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context,
              ffi.Bool,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_app>,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_pattern>,
              Z3_ast)>>('Z3_mk_quantifier_const');
  late final _mk_quantifier_const = _mk_quantifier_constPtr.asFunction<
      Z3_ast Function(Z3_context, bool, int, int, ffi.Pointer<Z3_app>, int,
          ffi.Pointer<Z3_pattern>, Z3_ast)>();

  /// \brief Create a universal or existential quantifier using a list of
  /// constants that will form the set of bound variables.
  ///
  /// def_API('Z3_mk_quantifier_const_ex', AST, (_in(CONTEXT), _in(BOOL), _in(UINT), _in(SYMBOL), _in(SYMBOL), _in(UINT), _in_array(5, APP), _in(UINT), _in_array(7, PATTERN), _in(UINT), _in_array(9, AST), _in(AST)))
  Z3_ast mk_quantifier_const_ex(
    Z3_context c,
    bool is_forall,
    int weight,
    Z3_symbol quantifier_id,
    Z3_symbol skolem_id,
    int num_bound,
    ffi.Pointer<Z3_app> bound,
    int num_patterns,
    ffi.Pointer<Z3_pattern> patterns,
    int num_no_patterns,
    ffi.Pointer<Z3_ast> no_patterns,
    Z3_ast body,
  ) {
    return _mk_quantifier_const_ex(
      c,
      is_forall,
      weight,
      quantifier_id,
      skolem_id,
      num_bound,
      bound,
      num_patterns,
      patterns,
      num_no_patterns,
      no_patterns,
      body,
    );
  }

  late final _mk_quantifier_const_exPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context,
              ffi.Bool,
              ffi.UnsignedInt,
              Z3_symbol,
              Z3_symbol,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_app>,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_pattern>,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>,
              Z3_ast)>>('Z3_mk_quantifier_const_ex');
  late final _mk_quantifier_const_ex = _mk_quantifier_const_exPtr.asFunction<
      Z3_ast Function(
          Z3_context,
          bool,
          int,
          Z3_symbol,
          Z3_symbol,
          int,
          ffi.Pointer<Z3_app>,
          int,
          ffi.Pointer<Z3_pattern>,
          int,
          ffi.Pointer<Z3_ast>,
          Z3_ast)>();

  /// \brief Create a lambda expression. It takes an expression \c body that contains bound variables
  /// of the same sorts as the sorts listed in the array \c sorts. The bound variables are de-Bruijn indices created
  /// using #Z3_mk_bound. The array \c decl_names contains the names that the quantified formula uses for the
  /// bound variables. Z3 applies the convention that the last element in the \c decl_names and \c sorts array
  /// refers to the variable with index 0, the second to last element of \c decl_names and \c sorts refers
  /// to the variable with index 1, etc.
  /// The sort of the resulting expression is \c (Array sorts range) where \c range is the sort of \c body.
  /// For example, if the lambda binds two variables of sort \c Int and \c Bool, and the \c body has sort \c Real,
  /// the sort of the expression is \c (Array Int Bool Real).
  ///
  /// \param c logical context
  /// \param num_decls number of variables to be bound.
  /// \param sorts the sorts of the bound variables.
  /// \param decl_names names of the bound variables
  /// \param body the body of the lambda expression.
  ///
  /// \sa Z3_mk_bound
  /// \sa Z3_mk_forall
  /// \sa Z3_mk_lambda_const
  ///
  /// def_API('Z3_mk_lambda', AST, (_in(CONTEXT), _in(UINT), _in_array(1, SORT), _in_array(1, SYMBOL), _in(AST)))
  Z3_ast mk_lambda(
    Z3_context c,
    int num_decls,
    ffi.Pointer<Z3_sort> sorts,
    ffi.Pointer<Z3_symbol> decl_names,
    Z3_ast body,
  ) {
    return _mk_lambda(
      c,
      num_decls,
      sorts,
      decl_names,
      body,
    );
  }

  late final _mk_lambdaPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt, ffi.Pointer<Z3_sort>,
              ffi.Pointer<Z3_symbol>, Z3_ast)>>('Z3_mk_lambda');
  late final _mk_lambda = _mk_lambdaPtr.asFunction<
      Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_sort>,
          ffi.Pointer<Z3_symbol>, Z3_ast)>();

  /// \brief Create a lambda expression using a list of constants that form the set
  /// of bound variables
  ///
  /// \param c logical context.
  /// \param num_bound number of constants to be abstracted into bound variables.
  /// \param bound array of constants to be abstracted into bound variables.
  /// \param body the body of the lambda expression.
  ///
  /// \sa Z3_mk_bound
  /// \sa Z3_mk_forall
  /// \sa Z3_mk_lambda
  ///
  /// def_API('Z3_mk_lambda_const', AST, (_in(CONTEXT), _in(UINT), _in_array(1, APP), _in(AST)))
  Z3_ast mk_lambda_const(
    Z3_context c,
    int num_bound,
    ffi.Pointer<Z3_app> bound,
    Z3_ast body,
  ) {
    return _mk_lambda_const(
      c,
      num_bound,
      bound,
      body,
    );
  }

  late final _mk_lambda_constPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt, ffi.Pointer<Z3_app>,
              Z3_ast)>>('Z3_mk_lambda_const');
  late final _mk_lambda_const = _mk_lambda_constPtr.asFunction<
      Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_app>, Z3_ast)>();

  /// @name Accessors */
  /// /**@{*/
  /// /**
  /// \brief Return \c Z3_INT_SYMBOL if the symbol was constructed
  /// using #Z3_mk_int_symbol, and \c Z3_STRING_SYMBOL if the symbol
  /// was constructed using #Z3_mk_string_symbol.
  ///
  /// def_API('Z3_get_symbol_kind', UINT, (_in(CONTEXT), _in(SYMBOL)))
  int get_symbol_kind(
    Z3_context c,
    Z3_symbol s,
  ) {
    return _get_symbol_kind(
      c,
      s,
    );
  }

  late final _get_symbol_kindPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(Z3_context, Z3_symbol)>>(
          'Z3_get_symbol_kind');
  late final _get_symbol_kind =
      _get_symbol_kindPtr.asFunction<int Function(Z3_context, Z3_symbol)>();

  /// \brief Return the symbol int value.
  ///
  /// \pre Z3_get_symbol_kind(s) == Z3_INT_SYMBOL
  ///
  /// \sa Z3_mk_int_symbol
  ///
  /// def_API('Z3_get_symbol_int', INT, (_in(CONTEXT), _in(SYMBOL)))
  int get_symbol_int(
    Z3_context c,
    Z3_symbol s,
  ) {
    return _get_symbol_int(
      c,
      s,
    );
  }

  late final _get_symbol_intPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_symbol)>>(
          'Z3_get_symbol_int');
  late final _get_symbol_int =
      _get_symbol_intPtr.asFunction<int Function(Z3_context, Z3_symbol)>();

  /// \brief Return the symbol name.
  ///
  /// \pre Z3_get_symbol_kind(s) == Z3_STRING_SYMBOL
  ///
  /// \warning The returned buffer is statically allocated by Z3. It will
  /// be automatically deallocated when #Z3_del_context is invoked.
  /// So, the buffer is invalidated in the next call to \c Z3_get_symbol_string.
  ///
  /// \sa Z3_mk_string_symbol
  ///
  /// def_API('Z3_get_symbol_string', STRING, (_in(CONTEXT), _in(SYMBOL)))
  Z3_string get_symbol_string(
    Z3_context c,
    Z3_symbol s,
  ) {
    return _get_symbol_string(
      c,
      s,
    );
  }

  late final _get_symbol_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_symbol)>>(
          'Z3_get_symbol_string');
  late final _get_symbol_string = _get_symbol_stringPtr
      .asFunction<Z3_string Function(Z3_context, Z3_symbol)>();

  /// \brief Return the sort name as a symbol.
  ///
  /// def_API('Z3_get_sort_name', SYMBOL, (_in(CONTEXT), _in(SORT)))
  Z3_symbol get_sort_name(
    Z3_context c,
    Z3_sort d,
  ) {
    return _get_sort_name(
      c,
      d,
    );
  }

  late final _get_sort_namePtr =
      _lookup<ffi.NativeFunction<Z3_symbol Function(Z3_context, Z3_sort)>>(
          'Z3_get_sort_name');
  late final _get_sort_name =
      _get_sort_namePtr.asFunction<Z3_symbol Function(Z3_context, Z3_sort)>();

  /// \brief Return a unique identifier for \c s.
  ///
  /// def_API('Z3_get_sort_id', UINT, (_in(CONTEXT), _in(SORT)))
  int get_sort_id(
    Z3_context c,
    Z3_sort s,
  ) {
    return _get_sort_id(
      c,
      s,
    );
  }

  late final _get_sort_idPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_sort)>>(
      'Z3_get_sort_id');
  late final _get_sort_id =
      _get_sort_idPtr.asFunction<int Function(Z3_context, Z3_sort)>();

  /// \brief Convert a \c Z3_sort into \c Z3_ast. This is just type casting.
  ///
  /// def_API('Z3_sort_to_ast', AST, (_in(CONTEXT), _in(SORT)))
  Z3_ast sort_to_ast(
    Z3_context c,
    Z3_sort s,
  ) {
    return _sort_to_ast(
      c,
      s,
    );
  }

  late final _sort_to_astPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_sort)>>(
          'Z3_sort_to_ast');
  late final _sort_to_ast =
      _sort_to_astPtr.asFunction<Z3_ast Function(Z3_context, Z3_sort)>();

  /// \brief compare sorts.
  ///
  /// def_API('Z3_is_eq_sort', BOOL, (_in(CONTEXT), _in(SORT), _in(SORT)))
  bool is_eq_sort(
    Z3_context c,
    Z3_sort s1,
    Z3_sort s2,
  ) {
    return _is_eq_sort(
      c,
      s1,
      s2,
    );
  }

  late final _is_eq_sortPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_sort, Z3_sort)>>(
      'Z3_is_eq_sort');
  late final _is_eq_sort =
      _is_eq_sortPtr.asFunction<bool Function(Z3_context, Z3_sort, Z3_sort)>();

  /// \brief Return the sort kind (e.g., array, tuple, int, bool, etc).
  ///
  /// \sa Z3_sort_kind
  ///
  /// def_API('Z3_get_sort_kind', UINT, (_in(CONTEXT), _in(SORT)))
  int get_sort_kind(
    Z3_context c,
    Z3_sort t,
  ) {
    return _get_sort_kind(
      c,
      t,
    );
  }

  late final _get_sort_kindPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(Z3_context, Z3_sort)>>(
          'Z3_get_sort_kind');
  late final _get_sort_kind =
      _get_sort_kindPtr.asFunction<int Function(Z3_context, Z3_sort)>();

  /// \brief Return the size of the given bit-vector sort.
  ///
  /// \pre Z3_get_sort_kind(c, t) == Z3_BV_SORT
  ///
  /// \sa Z3_mk_bv_sort
  /// \sa Z3_get_sort_kind
  ///
  /// def_API('Z3_get_bv_sort_size', UINT, (_in(CONTEXT), _in(SORT)))
  int get_bv_sort_size(
    Z3_context c,
    Z3_sort t,
  ) {
    return _get_bv_sort_size(
      c,
      t,
    );
  }

  late final _get_bv_sort_sizePtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_sort)>>(
      'Z3_get_bv_sort_size');
  late final _get_bv_sort_size =
      _get_bv_sort_sizePtr.asFunction<int Function(Z3_context, Z3_sort)>();

  /// \brief Store the size of the sort in \c r. Return \c false if the call failed.
  /// That is, Z3_get_sort_kind(s) == Z3_FINITE_DOMAIN_SORT
  ///
  /// def_API('Z3_get_finite_domain_sort_size', BOOL, (_in(CONTEXT), _in(SORT), _out(UINT64)))
  bool get_finite_domain_sort_size(
    Z3_context c,
    Z3_sort s,
    ffi.Pointer<ffi.Uint64> r,
  ) {
    return _get_finite_domain_sort_size(
      c,
      s,
      r,
    );
  }

  late final _get_finite_domain_sort_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(Z3_context, Z3_sort,
              ffi.Pointer<ffi.Uint64>)>>('Z3_get_finite_domain_sort_size');
  late final _get_finite_domain_sort_size =
      _get_finite_domain_sort_sizePtr.asFunction<
          bool Function(Z3_context, Z3_sort, ffi.Pointer<ffi.Uint64>)>();

  /// \brief Return the domain of the given array sort.
  /// In the case of a multi-dimensional array, this function returns the sort of the first dimension.
  ///
  /// \pre Z3_get_sort_kind(c, t) == Z3_ARRAY_SORT
  ///
  /// \sa Z3_mk_array_sort
  /// \sa Z3_get_sort_kind
  /// \sa Z3_get_array_sort_domain_n
  ///
  /// def_API('Z3_get_array_sort_domain', SORT, (_in(CONTEXT), _in(SORT)))
  Z3_sort get_array_sort_domain(
    Z3_context c,
    Z3_sort t,
  ) {
    return _get_array_sort_domain(
      c,
      t,
    );
  }

  late final _get_array_sort_domainPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context, Z3_sort)>>(
          'Z3_get_array_sort_domain');
  late final _get_array_sort_domain = _get_array_sort_domainPtr
      .asFunction<Z3_sort Function(Z3_context, Z3_sort)>();

  /// \brief Return the i'th domain sort of an n-dimensional array.
  ///
  /// \pre Z3_get_sort_kind(c, t) == Z3_ARRAY_SORT
  ///
  /// \sa Z3_mk_array_sort
  /// \sa Z3_get_sort_kind
  /// \sa Z3_get_array_sort_domain
  ///
  /// def_API('Z3_get_array_sort_domain_n', SORT, (_in(CONTEXT), _in(SORT), _in(UINT)))
  Z3_sort get_array_sort_domain_n(
    Z3_context c,
    Z3_sort t,
    int idx,
  ) {
    return _get_array_sort_domain_n(
      c,
      t,
      idx,
    );
  }

  late final _get_array_sort_domain_nPtr = _lookup<
      ffi.NativeFunction<
          Z3_sort Function(Z3_context, Z3_sort,
              ffi.UnsignedInt)>>('Z3_get_array_sort_domain_n');
  late final _get_array_sort_domain_n = _get_array_sort_domain_nPtr
      .asFunction<Z3_sort Function(Z3_context, Z3_sort, int)>();

  /// \brief Return the range of the given array sort.
  ///
  /// \pre Z3_get_sort_kind(c, t) == Z3_ARRAY_SORT
  ///
  /// \sa Z3_mk_array_sort
  /// \sa Z3_get_sort_kind
  ///
  /// def_API('Z3_get_array_sort_range', SORT, (_in(CONTEXT), _in(SORT)))
  Z3_sort get_array_sort_range(
    Z3_context c,
    Z3_sort t,
  ) {
    return _get_array_sort_range(
      c,
      t,
    );
  }

  late final _get_array_sort_rangePtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context, Z3_sort)>>(
          'Z3_get_array_sort_range');
  late final _get_array_sort_range = _get_array_sort_rangePtr
      .asFunction<Z3_sort Function(Z3_context, Z3_sort)>();

  /// \brief Return the constructor declaration of the given tuple
  /// sort.
  ///
  /// \pre Z3_get_sort_kind(c, t) == Z3_DATATYPE_SORT
  ///
  /// \sa Z3_mk_tuple_sort
  /// \sa Z3_get_sort_kind
  ///
  /// def_API('Z3_get_tuple_sort_mk_decl', FUNC_DECL, (_in(CONTEXT), _in(SORT)))
  Z3_func_decl get_tuple_sort_mk_decl(
    Z3_context c,
    Z3_sort t,
  ) {
    return _get_tuple_sort_mk_decl(
      c,
      t,
    );
  }

  late final _get_tuple_sort_mk_declPtr =
      _lookup<ffi.NativeFunction<Z3_func_decl Function(Z3_context, Z3_sort)>>(
          'Z3_get_tuple_sort_mk_decl');
  late final _get_tuple_sort_mk_decl = _get_tuple_sort_mk_declPtr
      .asFunction<Z3_func_decl Function(Z3_context, Z3_sort)>();

  /// \brief Return the number of fields of the given tuple sort.
  ///
  /// \pre Z3_get_sort_kind(c, t) == Z3_DATATYPE_SORT
  ///
  /// \sa Z3_mk_tuple_sort
  /// \sa Z3_get_sort_kind
  ///
  /// def_API('Z3_get_tuple_sort_num_fields', UINT, (_in(CONTEXT), _in(SORT)))
  int get_tuple_sort_num_fields(
    Z3_context c,
    Z3_sort t,
  ) {
    return _get_tuple_sort_num_fields(
      c,
      t,
    );
  }

  late final _get_tuple_sort_num_fieldsPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_sort)>>(
      'Z3_get_tuple_sort_num_fields');
  late final _get_tuple_sort_num_fields = _get_tuple_sort_num_fieldsPtr
      .asFunction<int Function(Z3_context, Z3_sort)>();

  /// \brief Return the i-th field declaration (i.e., projection function declaration)
  /// of the given tuple sort.
  ///
  /// \pre Z3_get_sort_kind(t) == Z3_DATATYPE_SORT
  /// \pre i < Z3_get_tuple_sort_num_fields(c, t)
  ///
  /// \sa Z3_mk_tuple_sort
  /// \sa Z3_get_sort_kind
  ///
  /// def_API('Z3_get_tuple_sort_field_decl', FUNC_DECL, (_in(CONTEXT), _in(SORT), _in(UINT)))
  Z3_func_decl get_tuple_sort_field_decl(
    Z3_context c,
    Z3_sort t,
    int i,
  ) {
    return _get_tuple_sort_field_decl(
      c,
      t,
      i,
    );
  }

  late final _get_tuple_sort_field_declPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_decl Function(Z3_context, Z3_sort,
              ffi.UnsignedInt)>>('Z3_get_tuple_sort_field_decl');
  late final _get_tuple_sort_field_decl = _get_tuple_sort_field_declPtr
      .asFunction<Z3_func_decl Function(Z3_context, Z3_sort, int)>();

  /// \brief Return number of constructors for datatype.
  ///
  /// \pre Z3_get_sort_kind(t) == Z3_DATATYPE_SORT
  ///
  /// \sa Z3_get_datatype_sort_constructor
  /// \sa Z3_get_datatype_sort_recognizer
  /// \sa Z3_get_datatype_sort_constructor_accessor
  ///
  /// def_API('Z3_get_datatype_sort_num_constructors', UINT, (_in(CONTEXT), _in(SORT)))
  int get_datatype_sort_num_constructors(
    Z3_context c,
    Z3_sort t,
  ) {
    return _get_datatype_sort_num_constructors(
      c,
      t,
    );
  }

  late final _get_datatype_sort_num_constructorsPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_sort)>>(
      'Z3_get_datatype_sort_num_constructors');
  late final _get_datatype_sort_num_constructors =
      _get_datatype_sort_num_constructorsPtr
          .asFunction<int Function(Z3_context, Z3_sort)>();

  /// \brief Return idx'th constructor.
  ///
  /// \pre Z3_get_sort_kind(t) == Z3_DATATYPE_SORT
  /// \pre idx < Z3_get_datatype_sort_num_constructors(c, t)
  ///
  /// \sa Z3_get_datatype_sort_num_constructors
  /// \sa Z3_get_datatype_sort_recognizer
  /// \sa Z3_get_datatype_sort_constructor_accessor
  ///
  /// def_API('Z3_get_datatype_sort_constructor', FUNC_DECL, (_in(CONTEXT), _in(SORT), _in(UINT)))
  Z3_func_decl get_datatype_sort_constructor(
    Z3_context c,
    Z3_sort t,
    int idx,
  ) {
    return _get_datatype_sort_constructor(
      c,
      t,
      idx,
    );
  }

  late final _get_datatype_sort_constructorPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_decl Function(Z3_context, Z3_sort,
              ffi.UnsignedInt)>>('Z3_get_datatype_sort_constructor');
  late final _get_datatype_sort_constructor = _get_datatype_sort_constructorPtr
      .asFunction<Z3_func_decl Function(Z3_context, Z3_sort, int)>();

  /// \brief Return idx'th recognizer.
  ///
  /// \pre Z3_get_sort_kind(t) == Z3_DATATYPE_SORT
  /// \pre idx < Z3_get_datatype_sort_num_constructors(c, t)
  ///
  /// \sa Z3_get_datatype_sort_num_constructors
  /// \sa Z3_get_datatype_sort_constructor
  /// \sa Z3_get_datatype_sort_constructor_accessor
  ///
  /// def_API('Z3_get_datatype_sort_recognizer', FUNC_DECL, (_in(CONTEXT), _in(SORT), _in(UINT)))
  Z3_func_decl get_datatype_sort_recognizer(
    Z3_context c,
    Z3_sort t,
    int idx,
  ) {
    return _get_datatype_sort_recognizer(
      c,
      t,
      idx,
    );
  }

  late final _get_datatype_sort_recognizerPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_decl Function(Z3_context, Z3_sort,
              ffi.UnsignedInt)>>('Z3_get_datatype_sort_recognizer');
  late final _get_datatype_sort_recognizer = _get_datatype_sort_recognizerPtr
      .asFunction<Z3_func_decl Function(Z3_context, Z3_sort, int)>();

  /// \brief Return idx_a'th accessor for the idx_c'th constructor.
  ///
  /// \pre Z3_get_sort_kind(t) == Z3_DATATYPE_SORT
  /// \pre idx_c < Z3_get_datatype_sort_num_constructors(c, t)
  /// \pre idx_a < Z3_get_domain_size(c, Z3_get_datatype_sort_constructor(c, idx_c))
  ///
  /// \sa Z3_get_datatype_sort_num_constructors
  /// \sa Z3_get_datatype_sort_constructor
  /// \sa Z3_get_datatype_sort_recognizer
  ///
  /// def_API('Z3_get_datatype_sort_constructor_accessor', FUNC_DECL, (_in(CONTEXT), _in(SORT), _in(UINT), _in(UINT)))
  Z3_func_decl get_datatype_sort_constructor_accessor(
    Z3_context c,
    Z3_sort t,
    int idx_c,
    int idx_a,
  ) {
    return _get_datatype_sort_constructor_accessor(
      c,
      t,
      idx_c,
      idx_a,
    );
  }

  late final _get_datatype_sort_constructor_accessorPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_decl Function(Z3_context, Z3_sort, ffi.UnsignedInt,
              ffi.UnsignedInt)>>('Z3_get_datatype_sort_constructor_accessor');
  late final _get_datatype_sort_constructor_accessor =
      _get_datatype_sort_constructor_accessorPtr
          .asFunction<Z3_func_decl Function(Z3_context, Z3_sort, int, int)>();

  /// \brief Update record field with a value.
  ///
  /// This corresponds to the 'with' construct in OCaml.
  /// It has the effect of updating a record field with a given value.
  /// The remaining fields are left unchanged. It is the record
  /// equivalent of an array store (see \sa Z3_mk_store).
  /// If the datatype has more than one constructor, then the update function
  /// behaves as identity if there is a mismatch between the accessor and
  /// constructor. For example ((_ update-field car) nil 1) is nil,
  /// while ((_ update-field car) (cons 2 nil) 1) is (cons 1 nil).
  ///
  ///
  /// \pre Z3_get_sort_kind(Z3_get_sort(c, t)) == Z3_get_domain(c, field_access, 1) == Z3_DATATYPE_SORT
  /// \pre Z3_get_sort(c, value) == Z3_get_range(c, field_access)
  ///
  ///
  /// def_API('Z3_datatype_update_field', AST, (_in(CONTEXT), _in(FUNC_DECL), _in(AST), _in(AST)))
  Z3_ast datatype_update_field(
    Z3_context c,
    Z3_func_decl field_access,
    Z3_ast t,
    Z3_ast value,
  ) {
    return _datatype_update_field(
      c,
      field_access,
      t,
      value,
    );
  }

  late final _datatype_update_fieldPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_func_decl, Z3_ast,
              Z3_ast)>>('Z3_datatype_update_field');
  late final _datatype_update_field = _datatype_update_fieldPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_func_decl, Z3_ast, Z3_ast)>();

  /// \brief Return arity of relation.
  ///
  /// \pre Z3_get_sort_kind(s) == Z3_RELATION_SORT
  ///
  /// \sa Z3_get_relation_column
  ///
  /// def_API('Z3_get_relation_arity', UINT, (_in(CONTEXT), _in(SORT)))
  int get_relation_arity(
    Z3_context c,
    Z3_sort s,
  ) {
    return _get_relation_arity(
      c,
      s,
    );
  }

  late final _get_relation_arityPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_sort)>>(
      'Z3_get_relation_arity');
  late final _get_relation_arity =
      _get_relation_arityPtr.asFunction<int Function(Z3_context, Z3_sort)>();

  /// \brief Return sort at i'th column of relation sort.
  ///
  /// \pre Z3_get_sort_kind(c, s) == Z3_RELATION_SORT
  /// \pre col < Z3_get_relation_arity(c, s)
  ///
  /// \sa Z3_get_relation_arity
  ///
  /// def_API('Z3_get_relation_column', SORT, (_in(CONTEXT), _in(SORT), _in(UINT)))
  Z3_sort get_relation_column(
    Z3_context c,
    Z3_sort s,
    int col,
  ) {
    return _get_relation_column(
      c,
      s,
      col,
    );
  }

  late final _get_relation_columnPtr = _lookup<
      ffi.NativeFunction<
          Z3_sort Function(
              Z3_context, Z3_sort, ffi.UnsignedInt)>>('Z3_get_relation_column');
  late final _get_relation_column = _get_relation_columnPtr
      .asFunction<Z3_sort Function(Z3_context, Z3_sort, int)>();

  /// \brief Pseudo-Boolean relations.
  ///
  /// Encode p1 + p2 + ... + pn <= k
  ///
  /// def_API('Z3_mk_atmost', AST, (_in(CONTEXT), _in(UINT), _in_array(1,AST), _in(UINT)))
  Z3_ast mk_atmost(
    Z3_context c,
    int num_args,
    ffi.Pointer<Z3_ast> args,
    int k,
  ) {
    return _mk_atmost(
      c,
      num_args,
      args,
      k,
    );
  }

  late final _mk_atmostPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt, ffi.Pointer<Z3_ast>,
              ffi.UnsignedInt)>>('Z3_mk_atmost');
  late final _mk_atmost = _mk_atmostPtr
      .asFunction<Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_ast>, int)>();

  /// \brief Pseudo-Boolean relations.
  ///
  /// Encode p1 + p2 + ... + pn >= k
  ///
  /// def_API('Z3_mk_atleast', AST, (_in(CONTEXT), _in(UINT), _in_array(1,AST), _in(UINT)))
  Z3_ast mk_atleast(
    Z3_context c,
    int num_args,
    ffi.Pointer<Z3_ast> args,
    int k,
  ) {
    return _mk_atleast(
      c,
      num_args,
      args,
      k,
    );
  }

  late final _mk_atleastPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt, ffi.Pointer<Z3_ast>,
              ffi.UnsignedInt)>>('Z3_mk_atleast');
  late final _mk_atleast = _mk_atleastPtr
      .asFunction<Z3_ast Function(Z3_context, int, ffi.Pointer<Z3_ast>, int)>();

  /// \brief Pseudo-Boolean relations.
  ///
  /// Encode k1*p1 + k2*p2 + ... + kn*pn <= k
  ///
  /// def_API('Z3_mk_pble', AST, (_in(CONTEXT), _in(UINT), _in_array(1,AST), _in_array(1,INT), _in(INT)))
  Z3_ast mk_pble(
    Z3_context c,
    int num_args,
    ffi.Pointer<Z3_ast> args,
    ffi.Pointer<ffi.Int> coeffs,
    int k,
  ) {
    return _mk_pble(
      c,
      num_args,
      args,
      coeffs,
      k,
    );
  }

  late final _mk_pblePtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt, ffi.Pointer<Z3_ast>,
              ffi.Pointer<ffi.Int>, ffi.Int)>>('Z3_mk_pble');
  late final _mk_pble = _mk_pblePtr.asFunction<
      Z3_ast Function(
          Z3_context, int, ffi.Pointer<Z3_ast>, ffi.Pointer<ffi.Int>, int)>();

  /// \brief Pseudo-Boolean relations.
  ///
  /// Encode k1*p1 + k2*p2 + ... + kn*pn >= k
  ///
  /// def_API('Z3_mk_pbge', AST, (_in(CONTEXT), _in(UINT), _in_array(1,AST), _in_array(1,INT), _in(INT)))
  Z3_ast mk_pbge(
    Z3_context c,
    int num_args,
    ffi.Pointer<Z3_ast> args,
    ffi.Pointer<ffi.Int> coeffs,
    int k,
  ) {
    return _mk_pbge(
      c,
      num_args,
      args,
      coeffs,
      k,
    );
  }

  late final _mk_pbgePtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt, ffi.Pointer<Z3_ast>,
              ffi.Pointer<ffi.Int>, ffi.Int)>>('Z3_mk_pbge');
  late final _mk_pbge = _mk_pbgePtr.asFunction<
      Z3_ast Function(
          Z3_context, int, ffi.Pointer<Z3_ast>, ffi.Pointer<ffi.Int>, int)>();

  /// \brief Pseudo-Boolean relations.
  ///
  /// Encode k1*p1 + k2*p2 + ... + kn*pn = k
  ///
  /// def_API('Z3_mk_pbeq', AST, (_in(CONTEXT), _in(UINT), _in_array(1,AST), _in_array(1,INT), _in(INT)))
  Z3_ast mk_pbeq(
    Z3_context c,
    int num_args,
    ffi.Pointer<Z3_ast> args,
    ffi.Pointer<ffi.Int> coeffs,
    int k,
  ) {
    return _mk_pbeq(
      c,
      num_args,
      args,
      coeffs,
      k,
    );
  }

  late final _mk_pbeqPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.UnsignedInt, ffi.Pointer<Z3_ast>,
              ffi.Pointer<ffi.Int>, ffi.Int)>>('Z3_mk_pbeq');
  late final _mk_pbeq = _mk_pbeqPtr.asFunction<
      Z3_ast Function(
          Z3_context, int, ffi.Pointer<Z3_ast>, ffi.Pointer<ffi.Int>, int)>();

  /// \brief Convert a \c Z3_func_decl into \c Z3_ast. This is just type casting.
  ///
  /// def_API('Z3_func_decl_to_ast', AST, (_in(CONTEXT), _in(FUNC_DECL)))
  Z3_ast func_decl_to_ast(
    Z3_context c,
    Z3_func_decl f,
  ) {
    return _func_decl_to_ast(
      c,
      f,
    );
  }

  late final _func_decl_to_astPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_func_decl)>>(
          'Z3_func_decl_to_ast');
  late final _func_decl_to_ast = _func_decl_to_astPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_func_decl)>();

  /// \brief Compare terms.
  ///
  /// def_API('Z3_is_eq_func_decl', BOOL, (_in(CONTEXT), _in(FUNC_DECL), _in(FUNC_DECL)))
  bool is_eq_func_decl(
    Z3_context c,
    Z3_func_decl f1,
    Z3_func_decl f2,
  ) {
    return _is_eq_func_decl(
      c,
      f1,
      f2,
    );
  }

  late final _is_eq_func_declPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              Z3_context, Z3_func_decl, Z3_func_decl)>>('Z3_is_eq_func_decl');
  late final _is_eq_func_decl = _is_eq_func_declPtr
      .asFunction<bool Function(Z3_context, Z3_func_decl, Z3_func_decl)>();

  /// \brief Return a unique identifier for \c f.
  ///
  /// def_API('Z3_get_func_decl_id', UINT, (_in(CONTEXT), _in(FUNC_DECL)))
  int get_func_decl_id(
    Z3_context c,
    Z3_func_decl f,
  ) {
    return _get_func_decl_id(
      c,
      f,
    );
  }

  late final _get_func_decl_idPtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_func_decl)>>(
      'Z3_get_func_decl_id');
  late final _get_func_decl_id =
      _get_func_decl_idPtr.asFunction<int Function(Z3_context, Z3_func_decl)>();

  /// \brief Return the constant declaration name as a symbol.
  ///
  /// def_API('Z3_get_decl_name', SYMBOL, (_in(CONTEXT), _in(FUNC_DECL)))
  Z3_symbol get_decl_name(
    Z3_context c,
    Z3_func_decl d,
  ) {
    return _get_decl_name(
      c,
      d,
    );
  }

  late final _get_decl_namePtr =
      _lookup<ffi.NativeFunction<Z3_symbol Function(Z3_context, Z3_func_decl)>>(
          'Z3_get_decl_name');
  late final _get_decl_name = _get_decl_namePtr
      .asFunction<Z3_symbol Function(Z3_context, Z3_func_decl)>();

  /// \brief Return declaration kind corresponding to declaration.
  ///
  /// def_API('Z3_get_decl_kind', UINT, (_in(CONTEXT), _in(FUNC_DECL)))
  int get_decl_kind(
    Z3_context c,
    Z3_func_decl d,
  ) {
    return _get_decl_kind(
      c,
      d,
    );
  }

  late final _get_decl_kindPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(Z3_context, Z3_func_decl)>>(
          'Z3_get_decl_kind');
  late final _get_decl_kind =
      _get_decl_kindPtr.asFunction<int Function(Z3_context, Z3_func_decl)>();

  /// \brief Return the number of parameters of the given declaration.
  ///
  /// \sa Z3_get_arity
  ///
  /// def_API('Z3_get_domain_size', UINT, (_in(CONTEXT), _in(FUNC_DECL)))
  int get_domain_size(
    Z3_context c,
    Z3_func_decl d,
  ) {
    return _get_domain_size(
      c,
      d,
    );
  }

  late final _get_domain_sizePtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_func_decl)>>(
      'Z3_get_domain_size');
  late final _get_domain_size =
      _get_domain_sizePtr.asFunction<int Function(Z3_context, Z3_func_decl)>();

  /// \brief Alias for \c Z3_get_domain_size.
  ///
  /// \sa Z3_get_domain_size
  ///
  /// def_API('Z3_get_arity', UINT, (_in(CONTEXT), _in(FUNC_DECL)))
  int get_arity(
    Z3_context c,
    Z3_func_decl d,
  ) {
    return _get_arity(
      c,
      d,
    );
  }

  late final _get_arityPtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_func_decl)>>(
      'Z3_get_arity');
  late final _get_arity =
      _get_arityPtr.asFunction<int Function(Z3_context, Z3_func_decl)>();

  /// \brief Return the sort of the i-th parameter of the given function declaration.
  ///
  /// \pre i < Z3_get_domain_size(d)
  ///
  /// \sa Z3_get_domain_size
  ///
  /// def_API('Z3_get_domain', SORT, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT)))
  Z3_sort get_domain(
    Z3_context c,
    Z3_func_decl d,
    int i,
  ) {
    return _get_domain(
      c,
      d,
      i,
    );
  }

  late final _get_domainPtr = _lookup<
      ffi.NativeFunction<
          Z3_sort Function(
              Z3_context, Z3_func_decl, ffi.UnsignedInt)>>('Z3_get_domain');
  late final _get_domain = _get_domainPtr
      .asFunction<Z3_sort Function(Z3_context, Z3_func_decl, int)>();

  /// \brief Return the range of the given declaration.
  ///
  /// If \c d is a constant (i.e., has zero arguments), then this
  /// function returns the sort of the constant.
  ///
  /// def_API('Z3_get_range', SORT, (_in(CONTEXT), _in(FUNC_DECL)))
  Z3_sort get_range(
    Z3_context c,
    Z3_func_decl d,
  ) {
    return _get_range(
      c,
      d,
    );
  }

  late final _get_rangePtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context, Z3_func_decl)>>(
          'Z3_get_range');
  late final _get_range =
      _get_rangePtr.asFunction<Z3_sort Function(Z3_context, Z3_func_decl)>();

  /// \brief Return the number of parameters associated with a declaration.
  ///
  /// def_API('Z3_get_decl_num_parameters', UINT, (_in(CONTEXT), _in(FUNC_DECL)))
  int get_decl_num_parameters(
    Z3_context c,
    Z3_func_decl d,
  ) {
    return _get_decl_num_parameters(
      c,
      d,
    );
  }

  late final _get_decl_num_parametersPtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_func_decl)>>(
      'Z3_get_decl_num_parameters');
  late final _get_decl_num_parameters = _get_decl_num_parametersPtr
      .asFunction<int Function(Z3_context, Z3_func_decl)>();

  /// \brief Return the parameter type associated with a declaration.
  ///
  /// \param c the context
  /// \param d the function declaration
  /// \param idx is the index of the named parameter it should be between 0 and the number of parameters.
  ///
  /// def_API('Z3_get_decl_parameter_kind', UINT, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT)))
  int get_decl_parameter_kind(
    Z3_context c,
    Z3_func_decl d,
    int idx,
  ) {
    return _get_decl_parameter_kind(
      c,
      d,
      idx,
    );
  }

  late final _get_decl_parameter_kindPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(Z3_context, Z3_func_decl,
              ffi.UnsignedInt)>>('Z3_get_decl_parameter_kind');
  late final _get_decl_parameter_kind = _get_decl_parameter_kindPtr
      .asFunction<int Function(Z3_context, Z3_func_decl, int)>();

  /// \brief Return the integer value associated with an integer parameter.
  ///
  /// \pre Z3_get_decl_parameter_kind(c, d, idx) == Z3_PARAMETER_INT
  ///
  /// def_API('Z3_get_decl_int_parameter', INT, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT)))
  int get_decl_int_parameter(
    Z3_context c,
    Z3_func_decl d,
    int idx,
  ) {
    return _get_decl_int_parameter(
      c,
      d,
      idx,
    );
  }

  late final _get_decl_int_parameterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(Z3_context, Z3_func_decl,
              ffi.UnsignedInt)>>('Z3_get_decl_int_parameter');
  late final _get_decl_int_parameter = _get_decl_int_parameterPtr
      .asFunction<int Function(Z3_context, Z3_func_decl, int)>();

  /// \brief Return the double value associated with an double parameter.
  ///
  /// \pre Z3_get_decl_parameter_kind(c, d, idx) == Z3_PARAMETER_DOUBLE
  ///
  /// def_API('Z3_get_decl_double_parameter', DOUBLE, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT)))
  double get_decl_double_parameter(
    Z3_context c,
    Z3_func_decl d,
    int idx,
  ) {
    return _get_decl_double_parameter(
      c,
      d,
      idx,
    );
  }

  late final _get_decl_double_parameterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(Z3_context, Z3_func_decl,
              ffi.UnsignedInt)>>('Z3_get_decl_double_parameter');
  late final _get_decl_double_parameter = _get_decl_double_parameterPtr
      .asFunction<double Function(Z3_context, Z3_func_decl, int)>();

  /// \brief Return the double value associated with an double parameter.
  ///
  /// \pre Z3_get_decl_parameter_kind(c, d, idx) == Z3_PARAMETER_SYMBOL
  ///
  /// def_API('Z3_get_decl_symbol_parameter', SYMBOL, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT)))
  Z3_symbol get_decl_symbol_parameter(
    Z3_context c,
    Z3_func_decl d,
    int idx,
  ) {
    return _get_decl_symbol_parameter(
      c,
      d,
      idx,
    );
  }

  late final _get_decl_symbol_parameterPtr = _lookup<
      ffi.NativeFunction<
          Z3_symbol Function(Z3_context, Z3_func_decl,
              ffi.UnsignedInt)>>('Z3_get_decl_symbol_parameter');
  late final _get_decl_symbol_parameter = _get_decl_symbol_parameterPtr
      .asFunction<Z3_symbol Function(Z3_context, Z3_func_decl, int)>();

  /// \brief Return the sort value associated with a sort parameter.
  ///
  /// \pre Z3_get_decl_parameter_kind(c, d, idx) == Z3_PARAMETER_SORT
  ///
  /// def_API('Z3_get_decl_sort_parameter', SORT, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT)))
  Z3_sort get_decl_sort_parameter(
    Z3_context c,
    Z3_func_decl d,
    int idx,
  ) {
    return _get_decl_sort_parameter(
      c,
      d,
      idx,
    );
  }

  late final _get_decl_sort_parameterPtr = _lookup<
      ffi.NativeFunction<
          Z3_sort Function(Z3_context, Z3_func_decl,
              ffi.UnsignedInt)>>('Z3_get_decl_sort_parameter');
  late final _get_decl_sort_parameter = _get_decl_sort_parameterPtr
      .asFunction<Z3_sort Function(Z3_context, Z3_func_decl, int)>();

  /// \brief Return the expression value associated with an expression parameter.
  ///
  /// \pre Z3_get_decl_parameter_kind(c, d, idx) == Z3_PARAMETER_AST
  ///
  /// def_API('Z3_get_decl_ast_parameter', AST, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT)))
  Z3_ast get_decl_ast_parameter(
    Z3_context c,
    Z3_func_decl d,
    int idx,
  ) {
    return _get_decl_ast_parameter(
      c,
      d,
      idx,
    );
  }

  late final _get_decl_ast_parameterPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_func_decl,
              ffi.UnsignedInt)>>('Z3_get_decl_ast_parameter');
  late final _get_decl_ast_parameter = _get_decl_ast_parameterPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_func_decl, int)>();

  /// \brief Return the expression value associated with an expression parameter.
  ///
  /// \pre Z3_get_decl_parameter_kind(c, d, idx) == Z3_PARAMETER_FUNC_DECL
  ///
  /// def_API('Z3_get_decl_func_decl_parameter', FUNC_DECL, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT)))
  Z3_func_decl get_decl_func_decl_parameter(
    Z3_context c,
    Z3_func_decl d,
    int idx,
  ) {
    return _get_decl_func_decl_parameter(
      c,
      d,
      idx,
    );
  }

  late final _get_decl_func_decl_parameterPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_decl Function(Z3_context, Z3_func_decl,
              ffi.UnsignedInt)>>('Z3_get_decl_func_decl_parameter');
  late final _get_decl_func_decl_parameter = _get_decl_func_decl_parameterPtr
      .asFunction<Z3_func_decl Function(Z3_context, Z3_func_decl, int)>();

  /// \brief Return the rational value, as a string, associated with a rational parameter.
  ///
  /// \pre Z3_get_decl_parameter_kind(c, d, idx) == Z3_PARAMETER_RATIONAL
  ///
  /// def_API('Z3_get_decl_rational_parameter', STRING, (_in(CONTEXT), _in(FUNC_DECL), _in(UINT)))
  Z3_string get_decl_rational_parameter(
    Z3_context c,
    Z3_func_decl d,
    int idx,
  ) {
    return _get_decl_rational_parameter(
      c,
      d,
      idx,
    );
  }

  late final _get_decl_rational_parameterPtr = _lookup<
      ffi.NativeFunction<
          Z3_string Function(Z3_context, Z3_func_decl,
              ffi.UnsignedInt)>>('Z3_get_decl_rational_parameter');
  late final _get_decl_rational_parameter = _get_decl_rational_parameterPtr
      .asFunction<Z3_string Function(Z3_context, Z3_func_decl, int)>();

  /// \brief Convert a \c Z3_app into \c Z3_ast. This is just type casting.
  ///
  /// def_API('Z3_app_to_ast', AST, (_in(CONTEXT), _in(APP)))
  Z3_ast app_to_ast(
    Z3_context c,
    Z3_app a,
  ) {
    return _app_to_ast(
      c,
      a,
    );
  }

  late final _app_to_astPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_app)>>(
          'Z3_app_to_ast');
  late final _app_to_ast =
      _app_to_astPtr.asFunction<Z3_ast Function(Z3_context, Z3_app)>();

  /// \brief Return the declaration of a constant or function application.
  ///
  /// def_API('Z3_get_app_decl', FUNC_DECL, (_in(CONTEXT), _in(APP)))
  Z3_func_decl get_app_decl(
    Z3_context c,
    Z3_app a,
  ) {
    return _get_app_decl(
      c,
      a,
    );
  }

  late final _get_app_declPtr =
      _lookup<ffi.NativeFunction<Z3_func_decl Function(Z3_context, Z3_app)>>(
          'Z3_get_app_decl');
  late final _get_app_decl =
      _get_app_declPtr.asFunction<Z3_func_decl Function(Z3_context, Z3_app)>();

  /// \brief Return the number of argument of an application. If \c t
  /// is an constant, then the number of arguments is 0.
  ///
  /// \sa Z3_get_app_arg
  ///
  /// def_API('Z3_get_app_num_args', UINT, (_in(CONTEXT), _in(APP)))
  int get_app_num_args(
    Z3_context c,
    Z3_app a,
  ) {
    return _get_app_num_args(
      c,
      a,
    );
  }

  late final _get_app_num_argsPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_app)>>(
          'Z3_get_app_num_args');
  late final _get_app_num_args =
      _get_app_num_argsPtr.asFunction<int Function(Z3_context, Z3_app)>();

  /// \brief Return the i-th argument of the given application.
  ///
  /// \pre i < Z3_get_app_num_args(c, a)
  ///
  /// \sa Z3_get_app_num_args
  ///
  /// def_API('Z3_get_app_arg', AST, (_in(CONTEXT), _in(APP), _in(UINT)))
  Z3_ast get_app_arg(
    Z3_context c,
    Z3_app a,
    int i,
  ) {
    return _get_app_arg(
      c,
      a,
      i,
    );
  }

  late final _get_app_argPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, Z3_app, ffi.UnsignedInt)>>('Z3_get_app_arg');
  late final _get_app_arg =
      _get_app_argPtr.asFunction<Z3_ast Function(Z3_context, Z3_app, int)>();

  /// \brief Compare terms.
  ///
  /// def_API('Z3_is_eq_ast', BOOL, (_in(CONTEXT), _in(AST), _in(AST)))
  bool is_eq_ast(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _is_eq_ast(
      c,
      t1,
      t2,
    );
  }

  late final _is_eq_astPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_ast, Z3_ast)>>(
      'Z3_is_eq_ast');
  late final _is_eq_ast =
      _is_eq_astPtr.asFunction<bool Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Return a unique identifier for \c t.
  /// The identifier is unique up to structural equality. Thus, two ast nodes
  /// created by the same context and having the same children and same function symbols
  /// have the same identifiers. Ast nodes created in the same context, but having
  /// different children or different functions have different identifiers.
  /// Variables and quantifiers are also assigned different identifiers according to
  /// their structure.
  ///
  /// def_API('Z3_get_ast_id', UINT, (_in(CONTEXT), _in(AST)))
  int get_ast_id(
    Z3_context c,
    Z3_ast t,
  ) {
    return _get_ast_id(
      c,
      t,
    );
  }

  late final _get_ast_idPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_ast)>>(
          'Z3_get_ast_id');
  late final _get_ast_id =
      _get_ast_idPtr.asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Return a hash code for the given AST.
  /// The hash code is structural but two different AST objects can map to the same hash.
  /// The result of \c Z3_get_ast_id returns an identifier that is unique over the
  /// set of live AST objects.
  ///
  /// def_API('Z3_get_ast_hash', UINT, (_in(CONTEXT), _in(AST)))
  int get_ast_hash(
    Z3_context c,
    Z3_ast a,
  ) {
    return _get_ast_hash(
      c,
      a,
    );
  }

  late final _get_ast_hashPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_ast)>>(
          'Z3_get_ast_hash');
  late final _get_ast_hash =
      _get_ast_hashPtr.asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Return the sort of an AST node.
  ///
  /// The AST node must be a constant, application, numeral, bound variable, or quantifier.
  ///
  /// def_API('Z3_get_sort', SORT, (_in(CONTEXT), _in(AST)))
  Z3_sort get_sort(
    Z3_context c,
    Z3_ast a,
  ) {
    return _get_sort(
      c,
      a,
    );
  }

  late final _get_sortPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context, Z3_ast)>>(
          'Z3_get_sort');
  late final _get_sort =
      _get_sortPtr.asFunction<Z3_sort Function(Z3_context, Z3_ast)>();

  /// \brief Return \c true if the given expression \c t is well sorted.
  ///
  /// def_API('Z3_is_well_sorted', BOOL, (_in(CONTEXT), _in(AST)))
  bool is_well_sorted(
    Z3_context c,
    Z3_ast t,
  ) {
    return _is_well_sorted(
      c,
      t,
    );
  }

  late final _is_well_sortedPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_ast)>>(
          'Z3_is_well_sorted');
  late final _is_well_sorted =
      _is_well_sortedPtr.asFunction<bool Function(Z3_context, Z3_ast)>();

  /// \brief Return \c Z3_L_TRUE if \c a is true, \c Z3_L_FALSE if it is false, and \c Z3_L_UNDEF otherwise.
  ///
  /// def_API('Z3_get_bool_value', LBOOL, (_in(CONTEXT), _in(AST)))
  int get_bool_value(
    Z3_context c,
    Z3_ast a,
  ) {
    return _get_bool_value(
      c,
      a,
    );
  }

  late final _get_bool_valuePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(Z3_context, Z3_ast)>>(
          'Z3_get_bool_value');
  late final _get_bool_value =
      _get_bool_valuePtr.asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Return the kind of the given AST.
  ///
  /// def_API('Z3_get_ast_kind', UINT, (_in(CONTEXT), _in(AST)))
  int get_ast_kind(
    Z3_context c,
    Z3_ast a,
  ) {
    return _get_ast_kind(
      c,
      a,
    );
  }

  late final _get_ast_kindPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(Z3_context, Z3_ast)>>(
          'Z3_get_ast_kind');
  late final _get_ast_kind =
      _get_ast_kindPtr.asFunction<int Function(Z3_context, Z3_ast)>();

  /// def_API('Z3_is_app', BOOL, (_in(CONTEXT), _in(AST)))
  bool is_app(
    Z3_context c,
    Z3_ast a,
  ) {
    return _is_app(
      c,
      a,
    );
  }

  late final _is_appPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_ast)>>(
          'Z3_is_app');
  late final _is_app =
      _is_appPtr.asFunction<bool Function(Z3_context, Z3_ast)>();

  /// def_API('Z3_is_numeral_ast', BOOL, (_in(CONTEXT), _in(AST)))
  bool is_numeral_ast(
    Z3_context c,
    Z3_ast a,
  ) {
    return _is_numeral_ast(
      c,
      a,
    );
  }

  late final _is_numeral_astPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_ast)>>(
          'Z3_is_numeral_ast');
  late final _is_numeral_ast =
      _is_numeral_astPtr.asFunction<bool Function(Z3_context, Z3_ast)>();

  /// \brief Return \c true if the given AST is a real algebraic number.
  ///
  /// def_API('Z3_is_algebraic_number', BOOL, (_in(CONTEXT), _in(AST)))
  bool is_algebraic_number(
    Z3_context c,
    Z3_ast a,
  ) {
    return _is_algebraic_number(
      c,
      a,
    );
  }

  late final _is_algebraic_numberPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_ast)>>(
          'Z3_is_algebraic_number');
  late final _is_algebraic_number =
      _is_algebraic_numberPtr.asFunction<bool Function(Z3_context, Z3_ast)>();

  /// \brief Convert an \c ast into an \c APP_AST. This is just type casting.
  ///
  /// \pre \code Z3_get_ast_kind(c, a) == \c Z3_APP_AST \endcode
  ///
  /// def_API('Z3_to_app', APP, (_in(CONTEXT), _in(AST)))
  Z3_app to_app(
    Z3_context c,
    Z3_ast a,
  ) {
    return _to_app(
      c,
      a,
    );
  }

  late final _to_appPtr =
      _lookup<ffi.NativeFunction<Z3_app Function(Z3_context, Z3_ast)>>(
          'Z3_to_app');
  late final _to_app =
      _to_appPtr.asFunction<Z3_app Function(Z3_context, Z3_ast)>();

  /// \brief Convert an AST into a FUNC_DECL_AST. This is just type casting.
  ///
  /// \pre \code Z3_get_ast_kind(c, a) == Z3_FUNC_DECL_AST \endcode
  ///
  /// def_API('Z3_to_func_decl', FUNC_DECL, (_in(CONTEXT), _in(AST)))
  Z3_func_decl to_func_decl(
    Z3_context c,
    Z3_ast a,
  ) {
    return _to_func_decl(
      c,
      a,
    );
  }

  late final _to_func_declPtr =
      _lookup<ffi.NativeFunction<Z3_func_decl Function(Z3_context, Z3_ast)>>(
          'Z3_to_func_decl');
  late final _to_func_decl =
      _to_func_declPtr.asFunction<Z3_func_decl Function(Z3_context, Z3_ast)>();

  /// \brief Return numeral value, as a decimal string of a numeric constant term
  ///
  /// \pre Z3_get_ast_kind(c, a) == Z3_NUMERAL_AST
  ///
  /// def_API('Z3_get_numeral_string', STRING, (_in(CONTEXT), _in(AST)))
  Z3_string get_numeral_string(
    Z3_context c,
    Z3_ast a,
  ) {
    return _get_numeral_string(
      c,
      a,
    );
  }

  late final _get_numeral_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_ast)>>(
          'Z3_get_numeral_string');
  late final _get_numeral_string = _get_numeral_stringPtr
      .asFunction<Z3_string Function(Z3_context, Z3_ast)>();

  /// \brief Return numeral value, as a binary string of a numeric constant term
  ///
  /// \pre Z3_get_ast_kind(c, a) == Z3_NUMERAL_AST
  /// \pre a represents a non-negative integer
  ///
  /// def_API('Z3_get_numeral_binary_string', STRING, (_in(CONTEXT), _in(AST)))
  Z3_string get_numeral_binary_string(
    Z3_context c,
    Z3_ast a,
  ) {
    return _get_numeral_binary_string(
      c,
      a,
    );
  }

  late final _get_numeral_binary_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_ast)>>(
          'Z3_get_numeral_binary_string');
  late final _get_numeral_binary_string = _get_numeral_binary_stringPtr
      .asFunction<Z3_string Function(Z3_context, Z3_ast)>();

  /// \brief Return numeral as a string in decimal notation.
  /// The result has at most \c precision decimal places.
  ///
  /// \pre Z3_get_ast_kind(c, a) == Z3_NUMERAL_AST || Z3_is_algebraic_number(c, a)
  ///
  /// def_API('Z3_get_numeral_decimal_string', STRING, (_in(CONTEXT), _in(AST), _in(UINT)))
  Z3_string get_numeral_decimal_string(
    Z3_context c,
    Z3_ast a,
    int precision,
  ) {
    return _get_numeral_decimal_string(
      c,
      a,
      precision,
    );
  }

  late final _get_numeral_decimal_stringPtr = _lookup<
      ffi.NativeFunction<
          Z3_string Function(Z3_context, Z3_ast,
              ffi.UnsignedInt)>>('Z3_get_numeral_decimal_string');
  late final _get_numeral_decimal_string = _get_numeral_decimal_stringPtr
      .asFunction<Z3_string Function(Z3_context, Z3_ast, int)>();

  /// \brief Return numeral as a double.
  ///
  /// \pre Z3_get_ast_kind(c, a) == Z3_NUMERAL_AST || Z3_is_algebraic_number(c, a)
  ///
  /// def_API('Z3_get_numeral_double', DOUBLE, (_in(CONTEXT), _in(AST)))
  double get_numeral_double(
    Z3_context c,
    Z3_ast a,
  ) {
    return _get_numeral_double(
      c,
      a,
    );
  }

  late final _get_numeral_doublePtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(Z3_context, Z3_ast)>>(
          'Z3_get_numeral_double');
  late final _get_numeral_double =
      _get_numeral_doublePtr.asFunction<double Function(Z3_context, Z3_ast)>();

  /// \brief Return the numerator (as a numeral AST) of a numeral AST of sort Real.
  ///
  /// \pre Z3_get_ast_kind(c, a) == Z3_NUMERAL_AST
  ///
  /// def_API('Z3_get_numerator', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast get_numerator(
    Z3_context c,
    Z3_ast a,
  ) {
    return _get_numerator(
      c,
      a,
    );
  }

  late final _get_numeratorPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_get_numerator');
  late final _get_numerator =
      _get_numeratorPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Return the denominator (as a numeral AST) of a numeral AST of sort Real.
  ///
  /// \pre Z3_get_ast_kind(c, a) == Z3_NUMERAL_AST
  ///
  /// def_API('Z3_get_denominator', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast get_denominator(
    Z3_context c,
    Z3_ast a,
  ) {
    return _get_denominator(
      c,
      a,
    );
  }

  late final _get_denominatorPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_get_denominator');
  late final _get_denominator =
      _get_denominatorPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Return numeral value, as a pair of 64 bit numbers if the representation fits.
  ///
  /// \param c logical context.
  /// \param a term.
  /// \param num numerator.
  /// \param den denominator.
  ///
  /// Return \c true if the numeral value fits in 64 bit numerals, \c false otherwise.
  ///
  /// \pre Z3_get_ast_kind(a) == Z3_NUMERAL_AST
  ///
  /// def_API('Z3_get_numeral_small', BOOL, (_in(CONTEXT), _in(AST), _out(INT64), _out(INT64)))
  bool get_numeral_small(
    Z3_context c,
    Z3_ast a,
    ffi.Pointer<ffi.Int64> num,
    ffi.Pointer<ffi.Int64> den,
  ) {
    return _get_numeral_small(
      c,
      a,
      num,
      den,
    );
  }

  late final _get_numeral_smallPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(Z3_context, Z3_ast, ffi.Pointer<ffi.Int64>,
              ffi.Pointer<ffi.Int64>)>>('Z3_get_numeral_small');
  late final _get_numeral_small = _get_numeral_smallPtr.asFunction<
      bool Function(Z3_context, Z3_ast, ffi.Pointer<ffi.Int64>,
          ffi.Pointer<ffi.Int64>)>();

  /// \brief Similar to #Z3_get_numeral_string, but only succeeds if
  /// the value can fit in a machine int. Return \c true if the call succeeded.
  ///
  /// \pre Z3_get_ast_kind(c, v) == Z3_NUMERAL_AST
  ///
  /// \sa Z3_get_numeral_string
  ///
  /// def_API('Z3_get_numeral_int', BOOL, (_in(CONTEXT), _in(AST), _out(INT)))
  bool get_numeral_int(
    Z3_context c,
    Z3_ast v,
    ffi.Pointer<ffi.Int> i,
  ) {
    return _get_numeral_int(
      c,
      v,
      i,
    );
  }

  late final _get_numeral_intPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              Z3_context, Z3_ast, ffi.Pointer<ffi.Int>)>>('Z3_get_numeral_int');
  late final _get_numeral_int = _get_numeral_intPtr
      .asFunction<bool Function(Z3_context, Z3_ast, ffi.Pointer<ffi.Int>)>();

  /// \brief Similar to #Z3_get_numeral_string, but only succeeds if
  /// the value can fit in a machine unsigned int. Return \c true if the call succeeded.
  ///
  /// \pre Z3_get_ast_kind(c, v) == Z3_NUMERAL_AST
  ///
  /// \sa Z3_get_numeral_string
  ///
  /// def_API('Z3_get_numeral_uint', BOOL, (_in(CONTEXT), _in(AST), _out(UINT)))
  bool get_numeral_uint(
    Z3_context c,
    Z3_ast v,
    ffi.Pointer<ffi.UnsignedInt> u,
  ) {
    return _get_numeral_uint(
      c,
      v,
      u,
    );
  }

  late final _get_numeral_uintPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(Z3_context, Z3_ast,
              ffi.Pointer<ffi.UnsignedInt>)>>('Z3_get_numeral_uint');
  late final _get_numeral_uint = _get_numeral_uintPtr.asFunction<
      bool Function(Z3_context, Z3_ast, ffi.Pointer<ffi.UnsignedInt>)>();

  /// \brief Similar to #Z3_get_numeral_string, but only succeeds if
  /// the value can fit in a machine \c uint64_t int. Return \c true if the call succeeded.
  ///
  /// \pre Z3_get_ast_kind(c, v) == Z3_NUMERAL_AST
  ///
  /// \sa Z3_get_numeral_string
  ///
  /// def_API('Z3_get_numeral_uint64', BOOL, (_in(CONTEXT), _in(AST), _out(UINT64)))
  bool get_numeral_uint64(
    Z3_context c,
    Z3_ast v,
    ffi.Pointer<ffi.Uint64> u,
  ) {
    return _get_numeral_uint64(
      c,
      v,
      u,
    );
  }

  late final _get_numeral_uint64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(Z3_context, Z3_ast,
              ffi.Pointer<ffi.Uint64>)>>('Z3_get_numeral_uint64');
  late final _get_numeral_uint64 = _get_numeral_uint64Ptr
      .asFunction<bool Function(Z3_context, Z3_ast, ffi.Pointer<ffi.Uint64>)>();

  /// \brief Similar to #Z3_get_numeral_string, but only succeeds if
  /// the value can fit in a machine \c int64_t int. Return \c true if the call succeeded.
  ///
  /// \pre Z3_get_ast_kind(c, v) == Z3_NUMERAL_AST
  ///
  /// \sa Z3_get_numeral_string
  ///
  /// def_API('Z3_get_numeral_int64', BOOL, (_in(CONTEXT), _in(AST), _out(INT64)))
  bool get_numeral_int64(
    Z3_context c,
    Z3_ast v,
    ffi.Pointer<ffi.Int64> i,
  ) {
    return _get_numeral_int64(
      c,
      v,
      i,
    );
  }

  late final _get_numeral_int64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(Z3_context, Z3_ast,
              ffi.Pointer<ffi.Int64>)>>('Z3_get_numeral_int64');
  late final _get_numeral_int64 = _get_numeral_int64Ptr
      .asFunction<bool Function(Z3_context, Z3_ast, ffi.Pointer<ffi.Int64>)>();

  /// \brief Similar to #Z3_get_numeral_string, but only succeeds if
  /// the value can fit as a rational number as machine \c int64_t int. Return \c true if the call succeeded.
  ///
  /// \pre Z3_get_ast_kind(c, v) == Z3_NUMERAL_AST
  ///
  /// \sa Z3_get_numeral_string
  ///
  /// def_API('Z3_get_numeral_rational_int64', BOOL, (_in(CONTEXT), _in(AST), _out(INT64), _out(INT64)))
  bool get_numeral_rational_int64(
    Z3_context c,
    Z3_ast v,
    ffi.Pointer<ffi.Int64> num,
    ffi.Pointer<ffi.Int64> den,
  ) {
    return _get_numeral_rational_int64(
      c,
      v,
      num,
      den,
    );
  }

  late final _get_numeral_rational_int64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(Z3_context, Z3_ast, ffi.Pointer<ffi.Int64>,
              ffi.Pointer<ffi.Int64>)>>('Z3_get_numeral_rational_int64');
  late final _get_numeral_rational_int64 =
      _get_numeral_rational_int64Ptr.asFunction<
          bool Function(Z3_context, Z3_ast, ffi.Pointer<ffi.Int64>,
              ffi.Pointer<ffi.Int64>)>();

  /// \brief Return a lower bound for the given real algebraic number.
  /// The interval isolating the number is smaller than 1/10^precision.
  /// The result is a numeral AST of sort Real.
  ///
  /// \pre Z3_is_algebraic_number(c, a)
  ///
  /// def_API('Z3_get_algebraic_number_lower', AST, (_in(CONTEXT), _in(AST), _in(UINT)))
  Z3_ast get_algebraic_number_lower(
    Z3_context c,
    Z3_ast a,
    int precision,
  ) {
    return _get_algebraic_number_lower(
      c,
      a,
      precision,
    );
  }

  late final _get_algebraic_number_lowerPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast,
              ffi.UnsignedInt)>>('Z3_get_algebraic_number_lower');
  late final _get_algebraic_number_lower = _get_algebraic_number_lowerPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, int)>();

  /// \brief Return a upper bound for the given real algebraic number.
  /// The interval isolating the number is smaller than 1/10^precision.
  /// The result is a numeral AST of sort Real.
  ///
  /// \pre Z3_is_algebraic_number(c, a)
  ///
  /// def_API('Z3_get_algebraic_number_upper', AST, (_in(CONTEXT), _in(AST), _in(UINT)))
  Z3_ast get_algebraic_number_upper(
    Z3_context c,
    Z3_ast a,
    int precision,
  ) {
    return _get_algebraic_number_upper(
      c,
      a,
      precision,
    );
  }

  late final _get_algebraic_number_upperPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast,
              ffi.UnsignedInt)>>('Z3_get_algebraic_number_upper');
  late final _get_algebraic_number_upper = _get_algebraic_number_upperPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, int)>();

  /// \brief Convert a Z3_pattern into Z3_ast. This is just type casting.
  ///
  /// def_API('Z3_pattern_to_ast', AST, (_in(CONTEXT), _in(PATTERN)))
  Z3_ast pattern_to_ast(
    Z3_context c,
    Z3_pattern p,
  ) {
    return _pattern_to_ast(
      c,
      p,
    );
  }

  late final _pattern_to_astPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_pattern)>>(
          'Z3_pattern_to_ast');
  late final _pattern_to_ast =
      _pattern_to_astPtr.asFunction<Z3_ast Function(Z3_context, Z3_pattern)>();

  /// \brief Return number of terms in pattern.
  ///
  /// def_API('Z3_get_pattern_num_terms', UINT, (_in(CONTEXT), _in(PATTERN)))
  int get_pattern_num_terms(
    Z3_context c,
    Z3_pattern p,
  ) {
    return _get_pattern_num_terms(
      c,
      p,
    );
  }

  late final _get_pattern_num_termsPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_pattern)>>(
      'Z3_get_pattern_num_terms');
  late final _get_pattern_num_terms = _get_pattern_num_termsPtr
      .asFunction<int Function(Z3_context, Z3_pattern)>();

  /// \brief Return i'th ast in pattern.
  ///
  /// def_API('Z3_get_pattern', AST, (_in(CONTEXT), _in(PATTERN), _in(UINT)))
  Z3_ast get_pattern(
    Z3_context c,
    Z3_pattern p,
    int idx,
  ) {
    return _get_pattern(
      c,
      p,
      idx,
    );
  }

  late final _get_patternPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, Z3_pattern, ffi.UnsignedInt)>>('Z3_get_pattern');
  late final _get_pattern = _get_patternPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_pattern, int)>();

  /// \brief Return index of de-Bruijn bound variable.
  ///
  /// \pre Z3_get_ast_kind(a) == Z3_VAR_AST
  ///
  /// def_API('Z3_get_index_value', UINT, (_in(CONTEXT), _in(AST)))
  int get_index_value(
    Z3_context c,
    Z3_ast a,
  ) {
    return _get_index_value(
      c,
      a,
    );
  }

  late final _get_index_valuePtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_ast)>>(
          'Z3_get_index_value');
  late final _get_index_value =
      _get_index_valuePtr.asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Determine if an ast is a universal quantifier.
  ///
  /// def_API('Z3_is_quantifier_forall', BOOL, (_in(CONTEXT), _in(AST)))
  bool is_quantifier_forall(
    Z3_context c,
    Z3_ast a,
  ) {
    return _is_quantifier_forall(
      c,
      a,
    );
  }

  late final _is_quantifier_forallPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_ast)>>(
          'Z3_is_quantifier_forall');
  late final _is_quantifier_forall =
      _is_quantifier_forallPtr.asFunction<bool Function(Z3_context, Z3_ast)>();

  /// \brief Determine if ast is an existential quantifier.
  ///
  ///
  /// def_API('Z3_is_quantifier_exists', BOOL, (_in(CONTEXT), _in(AST)))
  bool is_quantifier_exists(
    Z3_context c,
    Z3_ast a,
  ) {
    return _is_quantifier_exists(
      c,
      a,
    );
  }

  late final _is_quantifier_existsPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_ast)>>(
          'Z3_is_quantifier_exists');
  late final _is_quantifier_exists =
      _is_quantifier_existsPtr.asFunction<bool Function(Z3_context, Z3_ast)>();

  /// \brief Determine if ast is a lambda expression.
  ///
  /// \pre Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
  ///
  /// def_API('Z3_is_lambda', BOOL, (_in(CONTEXT), _in(AST)))
  bool is_lambda(
    Z3_context c,
    Z3_ast a,
  ) {
    return _is_lambda(
      c,
      a,
    );
  }

  late final _is_lambdaPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_ast)>>(
          'Z3_is_lambda');
  late final _is_lambda =
      _is_lambdaPtr.asFunction<bool Function(Z3_context, Z3_ast)>();

  /// \brief Obtain weight of quantifier.
  ///
  /// \pre Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
  ///
  /// def_API('Z3_get_quantifier_weight', UINT, (_in(CONTEXT), _in(AST)))
  int get_quantifier_weight(
    Z3_context c,
    Z3_ast a,
  ) {
    return _get_quantifier_weight(
      c,
      a,
    );
  }

  late final _get_quantifier_weightPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_ast)>>(
          'Z3_get_quantifier_weight');
  late final _get_quantifier_weight =
      _get_quantifier_weightPtr.asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Return number of patterns used in quantifier.
  ///
  /// \pre Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
  ///
  /// def_API('Z3_get_quantifier_num_patterns', UINT, (_in(CONTEXT), _in(AST)))
  int get_quantifier_num_patterns(
    Z3_context c,
    Z3_ast a,
  ) {
    return _get_quantifier_num_patterns(
      c,
      a,
    );
  }

  late final _get_quantifier_num_patternsPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_ast)>>(
          'Z3_get_quantifier_num_patterns');
  late final _get_quantifier_num_patterns = _get_quantifier_num_patternsPtr
      .asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Return i'th pattern.
  ///
  /// \pre Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
  ///
  /// def_API('Z3_get_quantifier_pattern_ast', PATTERN, (_in(CONTEXT), _in(AST), _in(UINT)))
  Z3_pattern get_quantifier_pattern_ast(
    Z3_context c,
    Z3_ast a,
    int i,
  ) {
    return _get_quantifier_pattern_ast(
      c,
      a,
      i,
    );
  }

  late final _get_quantifier_pattern_astPtr = _lookup<
      ffi.NativeFunction<
          Z3_pattern Function(Z3_context, Z3_ast,
              ffi.UnsignedInt)>>('Z3_get_quantifier_pattern_ast');
  late final _get_quantifier_pattern_ast = _get_quantifier_pattern_astPtr
      .asFunction<Z3_pattern Function(Z3_context, Z3_ast, int)>();

  /// \brief Return number of no_patterns used in quantifier.
  ///
  /// \pre Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
  ///
  /// def_API('Z3_get_quantifier_num_no_patterns', UINT, (_in(CONTEXT), _in(AST)))
  int get_quantifier_num_no_patterns(
    Z3_context c,
    Z3_ast a,
  ) {
    return _get_quantifier_num_no_patterns(
      c,
      a,
    );
  }

  late final _get_quantifier_num_no_patternsPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_ast)>>(
          'Z3_get_quantifier_num_no_patterns');
  late final _get_quantifier_num_no_patterns =
      _get_quantifier_num_no_patternsPtr
          .asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Return i'th no_pattern.
  ///
  /// \pre Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
  ///
  /// def_API('Z3_get_quantifier_no_pattern_ast', AST, (_in(CONTEXT), _in(AST), _in(UINT)))
  Z3_ast get_quantifier_no_pattern_ast(
    Z3_context c,
    Z3_ast a,
    int i,
  ) {
    return _get_quantifier_no_pattern_ast(
      c,
      a,
      i,
    );
  }

  late final _get_quantifier_no_pattern_astPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast,
              ffi.UnsignedInt)>>('Z3_get_quantifier_no_pattern_ast');
  late final _get_quantifier_no_pattern_ast = _get_quantifier_no_pattern_astPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, int)>();

  /// \brief Return number of bound variables of quantifier.
  ///
  /// \pre Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
  ///
  /// def_API('Z3_get_quantifier_num_bound', UINT, (_in(CONTEXT), _in(AST)))
  int get_quantifier_num_bound(
    Z3_context c,
    Z3_ast a,
  ) {
    return _get_quantifier_num_bound(
      c,
      a,
    );
  }

  late final _get_quantifier_num_boundPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_ast)>>(
          'Z3_get_quantifier_num_bound');
  late final _get_quantifier_num_bound = _get_quantifier_num_boundPtr
      .asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Return symbol of the i'th bound variable.
  ///
  /// \pre Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
  ///
  /// def_API('Z3_get_quantifier_bound_name', SYMBOL, (_in(CONTEXT), _in(AST), _in(UINT)))
  Z3_symbol get_quantifier_bound_name(
    Z3_context c,
    Z3_ast a,
    int i,
  ) {
    return _get_quantifier_bound_name(
      c,
      a,
      i,
    );
  }

  late final _get_quantifier_bound_namePtr = _lookup<
      ffi.NativeFunction<
          Z3_symbol Function(Z3_context, Z3_ast,
              ffi.UnsignedInt)>>('Z3_get_quantifier_bound_name');
  late final _get_quantifier_bound_name = _get_quantifier_bound_namePtr
      .asFunction<Z3_symbol Function(Z3_context, Z3_ast, int)>();

  /// \brief Return sort of the i'th bound variable.
  ///
  /// \pre Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
  ///
  /// def_API('Z3_get_quantifier_bound_sort', SORT, (_in(CONTEXT), _in(AST), _in(UINT)))
  Z3_sort get_quantifier_bound_sort(
    Z3_context c,
    Z3_ast a,
    int i,
  ) {
    return _get_quantifier_bound_sort(
      c,
      a,
      i,
    );
  }

  late final _get_quantifier_bound_sortPtr = _lookup<
      ffi.NativeFunction<
          Z3_sort Function(Z3_context, Z3_ast,
              ffi.UnsignedInt)>>('Z3_get_quantifier_bound_sort');
  late final _get_quantifier_bound_sort = _get_quantifier_bound_sortPtr
      .asFunction<Z3_sort Function(Z3_context, Z3_ast, int)>();

  /// \brief Return body of quantifier.
  ///
  /// \pre Z3_get_ast_kind(a) == Z3_QUANTIFIER_AST
  ///
  /// def_API('Z3_get_quantifier_body', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast get_quantifier_body(
    Z3_context c,
    Z3_ast a,
  ) {
    return _get_quantifier_body(
      c,
      a,
    );
  }

  late final _get_quantifier_bodyPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_get_quantifier_body');
  late final _get_quantifier_body =
      _get_quantifier_bodyPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Interface to simplifier.
  ///
  /// Provides an interface to the AST simplifier used by Z3.
  /// It returns an AST object which is equal to the argument.
  /// The returned AST is simplified using algebraic simplification rules,
  /// such as constant propagation (propagating true/false over logical connectives).
  ///
  /// \sa Z3_simplify_ex
  ///
  /// def_API('Z3_simplify', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast simplify(
    Z3_context c,
    Z3_ast a,
  ) {
    return _simplify(
      c,
      a,
    );
  }

  late final _simplifyPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_simplify');
  late final _simplify =
      _simplifyPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Interface to simplifier.
  ///
  /// Provides an interface to the AST simplifier used by Z3.
  /// This procedure is similar to #Z3_simplify, but the behavior of the simplifier
  /// can be configured using the given parameter set.
  ///
  /// \sa Z3_simplify
  /// \sa Z3_simplify_get_help
  /// \sa Z3_simplify_get_param_descrs
  ///
  /// def_API('Z3_simplify_ex', AST, (_in(CONTEXT), _in(AST), _in(PARAMS)))
  Z3_ast simplify_ex(
    Z3_context c,
    Z3_ast a,
    Z3_params p,
  ) {
    return _simplify_ex(
      c,
      a,
      p,
    );
  }

  late final _simplify_exPtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_params)>>(
      'Z3_simplify_ex');
  late final _simplify_ex = _simplify_exPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_params)>();

  /// \brief Return a string describing all available parameters.
  ///
  /// \sa Z3_simplify_ex
  /// \sa Z3_simplify_get_param_descrs
  ///
  /// def_API('Z3_simplify_get_help', STRING, (_in(CONTEXT),))
  Z3_string simplify_get_help(
    Z3_context c,
  ) {
    return _simplify_get_help(
      c,
    );
  }

  late final _simplify_get_helpPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context)>>(
          'Z3_simplify_get_help');
  late final _simplify_get_help =
      _simplify_get_helpPtr.asFunction<Z3_string Function(Z3_context)>();

  /// \brief Return the parameter description set for the simplify procedure.
  ///
  /// \sa Z3_simplify_ex
  /// \sa Z3_simplify_get_help
  ///
  /// def_API('Z3_simplify_get_param_descrs', PARAM_DESCRS, (_in(CONTEXT),))
  Z3_param_descrs simplify_get_param_descrs(
    Z3_context c,
  ) {
    return _simplify_get_param_descrs(
      c,
    );
  }

  late final _simplify_get_param_descrsPtr =
      _lookup<ffi.NativeFunction<Z3_param_descrs Function(Z3_context)>>(
          'Z3_simplify_get_param_descrs');
  late final _simplify_get_param_descrs = _simplify_get_param_descrsPtr
      .asFunction<Z3_param_descrs Function(Z3_context)>();

  /// @name Modifiers */
  /// /**@{*/
  /// /**
  /// \brief Update the arguments of term \c a using the arguments \c args.
  /// The number of arguments \c num_args should coincide
  /// with the number of arguments to \c a.
  /// If \c a is a quantifier, then num_args has to be 1.
  ///
  /// def_API('Z3_update_term', AST, (_in(CONTEXT), _in(AST), _in(UINT), _in_array(2, AST)))
  Z3_ast update_term(
    Z3_context c,
    Z3_ast a,
    int num_args,
    ffi.Pointer<Z3_ast> args,
  ) {
    return _update_term(
      c,
      a,
      num_args,
      args,
    );
  }

  late final _update_termPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_update_term');
  late final _update_term = _update_termPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Substitute every occurrence of \ccode{from[i]} in \c a with \ccode{to[i]}, for \c i smaller than \c num_exprs.
  /// The result is the new AST. The arrays \c from and \c to must have size \c num_exprs.
  /// For every \c i smaller than \c num_exprs, we must have that sort of \ccode{from[i]} must be equal to sort of \ccode{to[i]}.
  ///
  /// def_API('Z3_substitute', AST, (_in(CONTEXT), _in(AST), _in(UINT), _in_array(2, AST), _in_array(2, AST)))
  Z3_ast substitute(
    Z3_context c,
    Z3_ast a,
    int num_exprs,
    ffi.Pointer<Z3_ast> from,
    ffi.Pointer<Z3_ast> to,
  ) {
    return _substitute(
      c,
      a,
      num_exprs,
      from,
      to,
    );
  }

  late final _substitutePtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>, ffi.Pointer<Z3_ast>)>>('Z3_substitute');
  late final _substitute = _substitutePtr.asFunction<
      Z3_ast Function(
          Z3_context, Z3_ast, int, ffi.Pointer<Z3_ast>, ffi.Pointer<Z3_ast>)>();

  /// \brief Substitute the variables in \c a with the expressions in \c to.
  /// For every \c i smaller than \c num_exprs, the variable with de-Bruijn index \c i is replaced with term \ccode{to[i]}.
  /// Note that a variable is created using the function \ref Z3_mk_bound.
  ///
  /// def_API('Z3_substitute_vars', AST, (_in(CONTEXT), _in(AST), _in(UINT), _in_array(2, AST)))
  Z3_ast substitute_vars(
    Z3_context c,
    Z3_ast a,
    int num_exprs,
    ffi.Pointer<Z3_ast> to,
  ) {
    return _substitute_vars(
      c,
      a,
      num_exprs,
      to,
    );
  }

  late final _substitute_varsPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_substitute_vars');
  late final _substitute_vars = _substitute_varsPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Substitute functions in \c from with new expressions in \c to.
  ///
  /// The expressions in \c to can have free variables. The free variable in \c to at index 0
  /// refers to the first argument of \c from, the free variable at index 1 corresponds to the second argument.
  ///
  /// def_API('Z3_substitute_funs', AST, (_in(CONTEXT), _in(AST), _in(UINT), _in_array(2, FUNC_DECL), _in_array(2, AST)))
  Z3_ast substitute_funs(
    Z3_context c,
    Z3_ast a,
    int num_funs,
    ffi.Pointer<Z3_func_decl> from,
    ffi.Pointer<Z3_ast> to,
  ) {
    return _substitute_funs(
      c,
      a,
      num_funs,
      from,
      to,
    );
  }

  late final _substitute_funsPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context,
              Z3_ast,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_func_decl>,
              ffi.Pointer<Z3_ast>)>>('Z3_substitute_funs');
  late final _substitute_funs = _substitute_funsPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, int, ffi.Pointer<Z3_func_decl>,
          ffi.Pointer<Z3_ast>)>();

  /// \brief Translate/Copy the AST \c a from context \c source to context \c target.
  /// AST \c a must have been created using context \c source.
  /// \pre source != target
  ///
  /// def_API('Z3_translate', AST, (_in(CONTEXT), _in(AST), _in(CONTEXT)))
  Z3_ast translate(
    Z3_context source,
    Z3_ast a,
    Z3_context target,
  ) {
    return _translate(
      source,
      a,
      target,
    );
  }

  late final _translatePtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_context)>>(
      'Z3_translate');
  late final _translate = _translatePtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_context)>();

  /// \brief Create a fresh model object. It has reference count 0.
  ///
  /// def_API('Z3_mk_model', MODEL, (_in(CONTEXT),))
  Z3_model mk_model(
    Z3_context c,
  ) {
    return _mk_model(
      c,
    );
  }

  late final _mk_modelPtr =
      _lookup<ffi.NativeFunction<Z3_model Function(Z3_context)>>('Z3_mk_model');
  late final _mk_model =
      _mk_modelPtr.asFunction<Z3_model Function(Z3_context)>();

  /// \brief Increment the reference counter of the given model.
  ///
  /// def_API('Z3_model_inc_ref', VOID, (_in(CONTEXT), _in(MODEL)))
  void model_inc_ref(
    Z3_context c,
    Z3_model m,
  ) {
    return _model_inc_ref(
      c,
      m,
    );
  }

  late final _model_inc_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_model)>>(
          'Z3_model_inc_ref');
  late final _model_inc_ref =
      _model_inc_refPtr.asFunction<void Function(Z3_context, Z3_model)>();

  /// \brief Decrement the reference counter of the given model.
  ///
  /// def_API('Z3_model_dec_ref', VOID, (_in(CONTEXT), _in(MODEL)))
  void model_dec_ref(
    Z3_context c,
    Z3_model m,
  ) {
    return _model_dec_ref(
      c,
      m,
    );
  }

  late final _model_dec_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_model)>>(
          'Z3_model_dec_ref');
  late final _model_dec_ref =
      _model_dec_refPtr.asFunction<void Function(Z3_context, Z3_model)>();

  /// \brief Evaluate the AST node \c t in the given model.
  /// Return \c true if succeeded, and store the result in \c v.
  ///
  /// If \c model_completion is \c true, then Z3 will assign an interpretation for any constant or function that does
  /// not have an interpretation in \c m. These constants and functions were essentially don't cares.
  ///
  /// If \c model_completion is \c false, then Z3 will not assign interpretations to constants for functions that do
  /// not have interpretations in \c m. Evaluation behaves as the identify function in this case.
  ///
  /// The evaluation may fail for the following reasons:
  ///
  /// - \c t contains a quantifier.
  ///
  /// - the model \c m is partial, that is, it doesn't have a complete interpretation for uninterpreted functions.
  /// That is, the option \ccode{MODEL_PARTIAL=true} was used.
  ///
  /// - \c t is type incorrect.
  ///
  /// - \c Z3_interrupt was invoked during evaluation.
  ///
  /// def_API('Z3_model_eval', BOOL, (_in(CONTEXT), _in(MODEL), _in(AST), _in(BOOL), _out(AST)))
  bool model_eval(
    Z3_context c,
    Z3_model m,
    Z3_ast t,
    bool model_completion,
    ffi.Pointer<Z3_ast> v,
  ) {
    return _model_eval(
      c,
      m,
      t,
      model_completion,
      v,
    );
  }

  late final _model_evalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(Z3_context, Z3_model, Z3_ast, ffi.Bool,
              ffi.Pointer<Z3_ast>)>>('Z3_model_eval');
  late final _model_eval = _model_evalPtr.asFunction<
      bool Function(Z3_context, Z3_model, Z3_ast, bool, ffi.Pointer<Z3_ast>)>();

  /// \brief Return the interpretation (i.e., assignment) of constant \c a in the model \c m.
  /// Return \c NULL, if the model does not assign an interpretation for \c a.
  /// That should be interpreted as: the value of \c a does not matter.
  ///
  /// \pre Z3_get_arity(c, a) == 0
  ///
  /// def_API('Z3_model_get_const_interp', AST, (_in(CONTEXT), _in(MODEL), _in(FUNC_DECL)))
  Z3_ast model_get_const_interp(
    Z3_context c,
    Z3_model m,
    Z3_func_decl a,
  ) {
    return _model_get_const_interp(
      c,
      m,
      a,
    );
  }

  late final _model_get_const_interpPtr = _lookup<
          ffi
          .NativeFunction<Z3_ast Function(Z3_context, Z3_model, Z3_func_decl)>>(
      'Z3_model_get_const_interp');
  late final _model_get_const_interp = _model_get_const_interpPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_model, Z3_func_decl)>();

  /// \brief Test if there exists an interpretation (i.e., assignment) for \c a in the model \c m.
  ///
  /// def_API('Z3_model_has_interp', BOOL, (_in(CONTEXT), _in(MODEL), _in(FUNC_DECL)))
  bool model_has_interp(
    Z3_context c,
    Z3_model m,
    Z3_func_decl a,
  ) {
    return _model_has_interp(
      c,
      m,
      a,
    );
  }

  late final _model_has_interpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              Z3_context, Z3_model, Z3_func_decl)>>('Z3_model_has_interp');
  late final _model_has_interp = _model_has_interpPtr
      .asFunction<bool Function(Z3_context, Z3_model, Z3_func_decl)>();

  /// \brief Return the interpretation of the function \c f in the model \c m.
  /// Return \c NULL, if the model does not assign an interpretation for \c f.
  /// That should be interpreted as: the \c f does not matter.
  ///
  /// \pre Z3_get_arity(c, f) > 0
  ///
  /// \remark Reference counting must be used to manage Z3_func_interp objects, even when the Z3_context was
  /// created using #Z3_mk_context instead of #Z3_mk_context_rc.
  ///
  /// def_API('Z3_model_get_func_interp', FUNC_INTERP, (_in(CONTEXT), _in(MODEL), _in(FUNC_DECL)))
  Z3_func_interp model_get_func_interp(
    Z3_context c,
    Z3_model m,
    Z3_func_decl f,
  ) {
    return _model_get_func_interp(
      c,
      m,
      f,
    );
  }

  late final _model_get_func_interpPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_interp Function(
              Z3_context, Z3_model, Z3_func_decl)>>('Z3_model_get_func_interp');
  late final _model_get_func_interp = _model_get_func_interpPtr.asFunction<
      Z3_func_interp Function(Z3_context, Z3_model, Z3_func_decl)>();

  /// \brief Return the number of constants assigned by the given model.
  ///
  /// \sa Z3_model_get_const_decl
  ///
  /// def_API('Z3_model_get_num_consts', UINT, (_in(CONTEXT), _in(MODEL)))
  int model_get_num_consts(
    Z3_context c,
    Z3_model m,
  ) {
    return _model_get_num_consts(
      c,
      m,
    );
  }

  late final _model_get_num_constsPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_model)>>(
      'Z3_model_get_num_consts');
  late final _model_get_num_consts =
      _model_get_num_constsPtr.asFunction<int Function(Z3_context, Z3_model)>();

  /// \brief Return the i-th constant in the given model.
  ///
  /// \pre i < Z3_model_get_num_consts(c, m)
  ///
  /// \sa Z3_model_eval
  /// \sa Z3_model_get_num_consts
  ///
  /// def_API('Z3_model_get_const_decl', FUNC_DECL, (_in(CONTEXT), _in(MODEL), _in(UINT)))
  Z3_func_decl model_get_const_decl(
    Z3_context c,
    Z3_model m,
    int i,
  ) {
    return _model_get_const_decl(
      c,
      m,
      i,
    );
  }

  late final _model_get_const_declPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_decl Function(Z3_context, Z3_model,
              ffi.UnsignedInt)>>('Z3_model_get_const_decl');
  late final _model_get_const_decl = _model_get_const_declPtr
      .asFunction<Z3_func_decl Function(Z3_context, Z3_model, int)>();

  /// \brief Return the number of function interpretations in the given model.
  ///
  /// A function interpretation is represented as a finite map and an 'else' value.
  /// Each entry in the finite map represents the value of a function given a set of arguments.
  ///
  /// \sa Z3_model_get_func_decl
  ///
  /// def_API('Z3_model_get_num_funcs', UINT, (_in(CONTEXT), _in(MODEL)))
  int model_get_num_funcs(
    Z3_context c,
    Z3_model m,
  ) {
    return _model_get_num_funcs(
      c,
      m,
    );
  }

  late final _model_get_num_funcsPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_model)>>(
      'Z3_model_get_num_funcs');
  late final _model_get_num_funcs =
      _model_get_num_funcsPtr.asFunction<int Function(Z3_context, Z3_model)>();

  /// \brief Return the declaration of the i-th function in the given model.
  ///
  /// \pre i < Z3_model_get_num_funcs(c, m)
  ///
  /// \sa Z3_model_get_num_funcs
  ///
  /// def_API('Z3_model_get_func_decl', FUNC_DECL, (_in(CONTEXT), _in(MODEL), _in(UINT)))
  Z3_func_decl model_get_func_decl(
    Z3_context c,
    Z3_model m,
    int i,
  ) {
    return _model_get_func_decl(
      c,
      m,
      i,
    );
  }

  late final _model_get_func_declPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_decl Function(Z3_context, Z3_model,
              ffi.UnsignedInt)>>('Z3_model_get_func_decl');
  late final _model_get_func_decl = _model_get_func_declPtr
      .asFunction<Z3_func_decl Function(Z3_context, Z3_model, int)>();

  /// \brief Return the number of uninterpreted sorts that \c m assigns an interpretation to.
  ///
  /// Z3 also provides an interpretation for uninterpreted sorts used in a formula.
  /// The interpretation for a sort \c s is a finite set of distinct values. We say this finite set is
  /// the "universe" of \c s.
  ///
  /// \sa Z3_model_get_sort
  /// \sa Z3_model_get_sort_universe
  ///
  /// def_API('Z3_model_get_num_sorts', UINT, (_in(CONTEXT), _in(MODEL)))
  int model_get_num_sorts(
    Z3_context c,
    Z3_model m,
  ) {
    return _model_get_num_sorts(
      c,
      m,
    );
  }

  late final _model_get_num_sortsPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_model)>>(
      'Z3_model_get_num_sorts');
  late final _model_get_num_sorts =
      _model_get_num_sortsPtr.asFunction<int Function(Z3_context, Z3_model)>();

  /// \brief Return a uninterpreted sort that \c m assigns an interpretation.
  ///
  /// \pre i < Z3_model_get_num_sorts(c, m)
  ///
  /// \sa Z3_model_get_num_sorts
  /// \sa Z3_model_get_sort_universe
  ///
  /// def_API('Z3_model_get_sort', SORT, (_in(CONTEXT), _in(MODEL), _in(UINT)))
  Z3_sort model_get_sort(
    Z3_context c,
    Z3_model m,
    int i,
  ) {
    return _model_get_sort(
      c,
      m,
      i,
    );
  }

  late final _model_get_sortPtr = _lookup<
      ffi.NativeFunction<
          Z3_sort Function(
              Z3_context, Z3_model, ffi.UnsignedInt)>>('Z3_model_get_sort');
  late final _model_get_sort = _model_get_sortPtr
      .asFunction<Z3_sort Function(Z3_context, Z3_model, int)>();

  /// \brief Return the finite set of distinct values that represent the interpretation for sort \c s.
  ///
  /// \sa Z3_model_get_num_sorts
  /// \sa Z3_model_get_sort
  ///
  /// def_API('Z3_model_get_sort_universe', AST_VECTOR, (_in(CONTEXT), _in(MODEL), _in(SORT)))
  Z3_ast_vector model_get_sort_universe(
    Z3_context c,
    Z3_model m,
    Z3_sort s,
  ) {
    return _model_get_sort_universe(
      c,
      m,
      s,
    );
  }

  late final _model_get_sort_universePtr = _lookup<
      ffi.NativeFunction<
          Z3_ast_vector Function(
              Z3_context, Z3_model, Z3_sort)>>('Z3_model_get_sort_universe');
  late final _model_get_sort_universe = _model_get_sort_universePtr
      .asFunction<Z3_ast_vector Function(Z3_context, Z3_model, Z3_sort)>();

  /// \brief translate model from context \c c to context \c dst.
  ///
  /// \remark Use this method for cloning state between contexts. Note that
  /// operations on contexts are not thread safe and therefore all operations
  /// that related to a given context have to be synchronized (or run in the same thread).
  ///
  /// def_API('Z3_model_translate', MODEL, (_in(CONTEXT), _in(MODEL), _in(CONTEXT)))
  Z3_model model_translate(
    Z3_context c,
    Z3_model m,
    Z3_context dst,
  ) {
    return _model_translate(
      c,
      m,
      dst,
    );
  }

  late final _model_translatePtr = _lookup<
          ffi
          .NativeFunction<Z3_model Function(Z3_context, Z3_model, Z3_context)>>(
      'Z3_model_translate');
  late final _model_translate = _model_translatePtr
      .asFunction<Z3_model Function(Z3_context, Z3_model, Z3_context)>();

  /// \brief The \ccode{(_ as-array f)} AST node is a construct for assigning interpretations for arrays in Z3.
  /// It is the array such that forall indices \c i we have that \ccode{(select (_ as-array f) i)} is equal to \ccode{(f i)}.
  /// This procedure returns \c true if the \c a is an \c as-array AST node.
  ///
  /// Z3 current solvers have minimal support for \c as_array nodes.
  ///
  /// \sa Z3_get_as_array_func_decl
  ///
  /// def_API('Z3_is_as_array', BOOL, (_in(CONTEXT), _in(AST)))
  bool is_as_array(
    Z3_context c,
    Z3_ast a,
  ) {
    return _is_as_array(
      c,
      a,
    );
  }

  late final _is_as_arrayPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_ast)>>(
          'Z3_is_as_array');
  late final _is_as_array =
      _is_as_arrayPtr.asFunction<bool Function(Z3_context, Z3_ast)>();

  /// \brief Return the function declaration \c f associated with a \ccode{(_ as_array f)} node.
  ///
  /// \sa Z3_is_as_array
  ///
  /// def_API('Z3_get_as_array_func_decl', FUNC_DECL, (_in(CONTEXT), _in(AST)))
  Z3_func_decl get_as_array_func_decl(
    Z3_context c,
    Z3_ast a,
  ) {
    return _get_as_array_func_decl(
      c,
      a,
    );
  }

  late final _get_as_array_func_declPtr =
      _lookup<ffi.NativeFunction<Z3_func_decl Function(Z3_context, Z3_ast)>>(
          'Z3_get_as_array_func_decl');
  late final _get_as_array_func_decl = _get_as_array_func_declPtr
      .asFunction<Z3_func_decl Function(Z3_context, Z3_ast)>();

  /// \brief Create a fresh func_interp object, add it to a model for a specified function.
  /// It has reference count 0.
  ///
  /// \param c context
  /// \param m model
  /// \param f function declaration
  /// \param default_value default value for function interpretation
  ///
  /// def_API('Z3_add_func_interp', FUNC_INTERP, (_in(CONTEXT), _in(MODEL), _in(FUNC_DECL), _in(AST)))
  Z3_func_interp add_func_interp(
    Z3_context c,
    Z3_model m,
    Z3_func_decl f,
    Z3_ast default_value,
  ) {
    return _add_func_interp(
      c,
      m,
      f,
      default_value,
    );
  }

  late final _add_func_interpPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_interp Function(Z3_context, Z3_model, Z3_func_decl,
              Z3_ast)>>('Z3_add_func_interp');
  late final _add_func_interp = _add_func_interpPtr.asFunction<
      Z3_func_interp Function(Z3_context, Z3_model, Z3_func_decl, Z3_ast)>();

  /// \brief Add a constant interpretation.
  ///
  /// def_API('Z3_add_const_interp', VOID, (_in(CONTEXT), _in(MODEL), _in(FUNC_DECL), _in(AST)))
  void add_const_interp(
    Z3_context c,
    Z3_model m,
    Z3_func_decl f,
    Z3_ast a,
  ) {
    return _add_const_interp(
      c,
      m,
      f,
      a,
    );
  }

  late final _add_const_interpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_model, Z3_func_decl,
              Z3_ast)>>('Z3_add_const_interp');
  late final _add_const_interp = _add_const_interpPtr
      .asFunction<void Function(Z3_context, Z3_model, Z3_func_decl, Z3_ast)>();

  /// \brief Increment the reference counter of the given Z3_func_interp object.
  ///
  /// def_API('Z3_func_interp_inc_ref', VOID, (_in(CONTEXT), _in(FUNC_INTERP)))
  void func_interp_inc_ref(
    Z3_context c,
    Z3_func_interp f,
  ) {
    return _func_interp_inc_ref(
      c,
      f,
    );
  }

  late final _func_interp_inc_refPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_func_interp)>>(
      'Z3_func_interp_inc_ref');
  late final _func_interp_inc_ref = _func_interp_inc_refPtr
      .asFunction<void Function(Z3_context, Z3_func_interp)>();

  /// \brief Decrement the reference counter of the given Z3_func_interp object.
  ///
  /// def_API('Z3_func_interp_dec_ref', VOID, (_in(CONTEXT), _in(FUNC_INTERP)))
  void func_interp_dec_ref(
    Z3_context c,
    Z3_func_interp f,
  ) {
    return _func_interp_dec_ref(
      c,
      f,
    );
  }

  late final _func_interp_dec_refPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_func_interp)>>(
      'Z3_func_interp_dec_ref');
  late final _func_interp_dec_ref = _func_interp_dec_refPtr
      .asFunction<void Function(Z3_context, Z3_func_interp)>();

  /// \brief Return the number of entries in the given function interpretation.
  ///
  /// A function interpretation is represented as a finite map and an 'else' value.
  /// Each entry in the finite map represents the value of a function given a set of arguments.
  /// This procedure return the number of element in the finite map of \c f.
  ///
  /// \sa Z3_func_interp_get_entry
  ///
  /// def_API('Z3_func_interp_get_num_entries', UINT, (_in(CONTEXT), _in(FUNC_INTERP)))
  int func_interp_get_num_entries(
    Z3_context c,
    Z3_func_interp f,
  ) {
    return _func_interp_get_num_entries(
      c,
      f,
    );
  }

  late final _func_interp_get_num_entriesPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              Z3_context, Z3_func_interp)>>('Z3_func_interp_get_num_entries');
  late final _func_interp_get_num_entries = _func_interp_get_num_entriesPtr
      .asFunction<int Function(Z3_context, Z3_func_interp)>();

  /// \brief Return a "point" of the given function interpretation. It represents the
  /// value of \c f in a particular point.
  ///
  /// \pre i < Z3_func_interp_get_num_entries(c, f)
  ///
  /// \sa Z3_func_interp_get_num_entries
  ///
  /// def_API('Z3_func_interp_get_entry', FUNC_ENTRY, (_in(CONTEXT), _in(FUNC_INTERP), _in(UINT)))
  Z3_func_entry func_interp_get_entry(
    Z3_context c,
    Z3_func_interp f,
    int i,
  ) {
    return _func_interp_get_entry(
      c,
      f,
      i,
    );
  }

  late final _func_interp_get_entryPtr = _lookup<
      ffi.NativeFunction<
          Z3_func_entry Function(Z3_context, Z3_func_interp,
              ffi.UnsignedInt)>>('Z3_func_interp_get_entry');
  late final _func_interp_get_entry = _func_interp_get_entryPtr
      .asFunction<Z3_func_entry Function(Z3_context, Z3_func_interp, int)>();

  /// \brief Return the 'else' value of the given function interpretation.
  ///
  /// A function interpretation is represented as a finite map and an 'else' value.
  /// This procedure returns the 'else' value.
  ///
  /// def_API('Z3_func_interp_get_else', AST, (_in(CONTEXT), _in(FUNC_INTERP)))
  Z3_ast func_interp_get_else(
    Z3_context c,
    Z3_func_interp f,
  ) {
    return _func_interp_get_else(
      c,
      f,
    );
  }

  late final _func_interp_get_elsePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_func_interp)>>(
          'Z3_func_interp_get_else');
  late final _func_interp_get_else = _func_interp_get_elsePtr
      .asFunction<Z3_ast Function(Z3_context, Z3_func_interp)>();

  /// \brief Return the 'else' value of the given function interpretation.
  ///
  /// A function interpretation is represented as a finite map and an 'else' value.
  /// This procedure can be used to update the 'else' value.
  ///
  /// def_API('Z3_func_interp_set_else', VOID, (_in(CONTEXT), _in(FUNC_INTERP), _in(AST)))
  void func_interp_set_else(
    Z3_context c,
    Z3_func_interp f,
    Z3_ast else_value,
  ) {
    return _func_interp_set_else(
      c,
      f,
      else_value,
    );
  }

  late final _func_interp_set_elsePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context, Z3_func_interp, Z3_ast)>>('Z3_func_interp_set_else');
  late final _func_interp_set_else = _func_interp_set_elsePtr
      .asFunction<void Function(Z3_context, Z3_func_interp, Z3_ast)>();

  /// \brief Return the arity (number of arguments) of the given function interpretation.
  ///
  /// def_API('Z3_func_interp_get_arity', UINT, (_in(CONTEXT), _in(FUNC_INTERP)))
  int func_interp_get_arity(
    Z3_context c,
    Z3_func_interp f,
  ) {
    return _func_interp_get_arity(
      c,
      f,
    );
  }

  late final _func_interp_get_arityPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              Z3_context, Z3_func_interp)>>('Z3_func_interp_get_arity');
  late final _func_interp_get_arity = _func_interp_get_arityPtr
      .asFunction<int Function(Z3_context, Z3_func_interp)>();

  /// \brief add a function entry to a function interpretation.
  ///
  /// \param c logical context
  /// \param fi a function interpretation to be updated.
  /// \param args list of arguments. They should be constant values (such as integers) and be of the same types as the domain of the function.
  /// \param value value of the function when the parameters match args.
  ///
  /// It is assumed that entries added to a function cover disjoint arguments.
  /// If an two entries are added with the same arguments, only the second insertion survives and the
  /// first inserted entry is removed.
  ///
  /// def_API('Z3_func_interp_add_entry', VOID, (_in(CONTEXT), _in(FUNC_INTERP), _in(AST_VECTOR), _in(AST)))
  void func_interp_add_entry(
    Z3_context c,
    Z3_func_interp fi,
    Z3_ast_vector args,
    Z3_ast value,
  ) {
    return _func_interp_add_entry(
      c,
      fi,
      args,
      value,
    );
  }

  late final _func_interp_add_entryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_func_interp, Z3_ast_vector,
              Z3_ast)>>('Z3_func_interp_add_entry');
  late final _func_interp_add_entry = _func_interp_add_entryPtr.asFunction<
      void Function(Z3_context, Z3_func_interp, Z3_ast_vector, Z3_ast)>();

  /// \brief Increment the reference counter of the given \c Z3_func_entry object.
  ///
  /// def_API('Z3_func_entry_inc_ref', VOID, (_in(CONTEXT), _in(FUNC_ENTRY)))
  void func_entry_inc_ref(
    Z3_context c,
    Z3_func_entry e,
  ) {
    return _func_entry_inc_ref(
      c,
      e,
    );
  }

  late final _func_entry_inc_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_func_entry)>>(
          'Z3_func_entry_inc_ref');
  late final _func_entry_inc_ref = _func_entry_inc_refPtr
      .asFunction<void Function(Z3_context, Z3_func_entry)>();

  /// \brief Decrement the reference counter of the given \c Z3_func_entry object.
  ///
  /// def_API('Z3_func_entry_dec_ref', VOID, (_in(CONTEXT), _in(FUNC_ENTRY)))
  void func_entry_dec_ref(
    Z3_context c,
    Z3_func_entry e,
  ) {
    return _func_entry_dec_ref(
      c,
      e,
    );
  }

  late final _func_entry_dec_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_func_entry)>>(
          'Z3_func_entry_dec_ref');
  late final _func_entry_dec_ref = _func_entry_dec_refPtr
      .asFunction<void Function(Z3_context, Z3_func_entry)>();

  /// \brief Return the value of this point.
  ///
  /// A \c Z3_func_entry object represents an element in the finite map used to encode
  /// a function interpretation.
  ///
  /// \sa Z3_func_interp_get_entry
  ///
  /// def_API('Z3_func_entry_get_value', AST, (_in(CONTEXT), _in(FUNC_ENTRY)))
  Z3_ast func_entry_get_value(
    Z3_context c,
    Z3_func_entry e,
  ) {
    return _func_entry_get_value(
      c,
      e,
    );
  }

  late final _func_entry_get_valuePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_func_entry)>>(
          'Z3_func_entry_get_value');
  late final _func_entry_get_value = _func_entry_get_valuePtr
      .asFunction<Z3_ast Function(Z3_context, Z3_func_entry)>();

  /// \brief Return the number of arguments in a \c Z3_func_entry object.
  ///
  /// \sa Z3_func_entry_get_arg
  /// \sa Z3_func_interp_get_entry
  ///
  /// def_API('Z3_func_entry_get_num_args', UINT, (_in(CONTEXT), _in(FUNC_ENTRY)))
  int func_entry_get_num_args(
    Z3_context c,
    Z3_func_entry e,
  ) {
    return _func_entry_get_num_args(
      c,
      e,
    );
  }

  late final _func_entry_get_num_argsPtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_func_entry)>>(
      'Z3_func_entry_get_num_args');
  late final _func_entry_get_num_args = _func_entry_get_num_argsPtr
      .asFunction<int Function(Z3_context, Z3_func_entry)>();

  /// \brief Return an argument of a \c Z3_func_entry object.
  ///
  /// \pre i < Z3_func_entry_get_num_args(c, e)
  ///
  /// \sa Z3_func_entry_get_num_args
  /// \sa Z3_func_interp_get_entry
  ///
  /// def_API('Z3_func_entry_get_arg', AST, (_in(CONTEXT), _in(FUNC_ENTRY), _in(UINT)))
  Z3_ast func_entry_get_arg(
    Z3_context c,
    Z3_func_entry e,
    int i,
  ) {
    return _func_entry_get_arg(
      c,
      e,
      i,
    );
  }

  late final _func_entry_get_argPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_func_entry,
              ffi.UnsignedInt)>>('Z3_func_entry_get_arg');
  late final _func_entry_get_arg = _func_entry_get_argPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_func_entry, int)>();

  /// @name Interaction logging */
  /// /**@{*/
  /// /**
  /// \brief Log interaction to a file.
  ///
  /// \sa Z3_append_log
  /// \sa Z3_close_log
  ///
  /// extra_API('Z3_open_log', INT, (_in(STRING),))
  bool open_log(
    Z3_string filename,
  ) {
    return _open_log(
      filename,
    );
  }

  late final _open_logPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Z3_string)>>('Z3_open_log');
  late final _open_log = _open_logPtr.asFunction<bool Function(Z3_string)>();

  /// \brief Append user-defined string to interaction log.
  ///
  /// The interaction log is opened using #Z3_open_log.
  /// It contains the formulas that are checked using Z3.
  /// You can use this command to append comments, for instance.
  ///
  /// \sa Z3_open_log
  /// \sa Z3_close_log
  ///
  /// extra_API('Z3_append_log', VOID, (_in(STRING),))
  void append_log(
    Z3_string string,
  ) {
    return _append_log(
      string,
    );
  }

  late final _append_logPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_string)>>(
          'Z3_append_log');
  late final _append_log =
      _append_logPtr.asFunction<void Function(Z3_string)>();

  /// \brief Close interaction log.
  ///
  /// \sa Z3_open_log
  /// \sa Z3_append_log
  ///
  /// extra_API('Z3_close_log', VOID, ())
  void close_log() {
    return _close_log();
  }

  late final _close_logPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Z3_close_log');
  late final _close_log = _close_logPtr.asFunction<void Function()>();

  /// \brief Enable/disable printing warning messages to the console.
  ///
  /// Warnings are printed after passing \c true, warning messages are
  /// suppressed after calling this method with \c false.
  ///
  /// def_API('Z3_toggle_warning_messages', VOID, (_in(BOOL),))
  void toggle_warning_messages(
    bool enabled,
  ) {
    return _toggle_warning_messages(
      enabled,
    );
  }

  late final _toggle_warning_messagesPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>(
          'Z3_toggle_warning_messages');
  late final _toggle_warning_messages =
      _toggle_warning_messagesPtr.asFunction<void Function(bool)>();

  /// @name String conversion */
  /// /**@{*/
  /// /**
  /// \brief Select mode for the format used for pretty-printing AST nodes.
  ///
  /// The default mode for pretty printing AST nodes is to produce
  /// SMT-LIB style output where common subexpressions are printed
  /// at each occurrence. The mode is called \c Z3_PRINT_SMTLIB_FULL.
  /// To print shared common subexpressions only once,
  /// use the \c Z3_PRINT_LOW_LEVEL mode.
  /// To print in way that conforms to SMT-LIB standards and uses let
  /// expressions to share common sub-expressions use \c Z3_PRINT_SMTLIB2_COMPLIANT.
  ///
  /// \sa Z3_ast_to_string
  /// \sa Z3_pattern_to_string
  /// \sa Z3_func_decl_to_string
  ///
  /// def_API('Z3_set_ast_print_mode', VOID, (_in(CONTEXT), _in(PRINT_MODE)))
  void set_ast_print_mode(
    Z3_context c,
    int mode,
  ) {
    return _set_ast_print_mode(
      c,
      mode,
    );
  }

  late final _set_ast_print_modePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, ffi.Int32)>>(
          'Z3_set_ast_print_mode');
  late final _set_ast_print_mode =
      _set_ast_print_modePtr.asFunction<void Function(Z3_context, int)>();

  /// \brief Convert the given AST node into a string.
  ///
  /// \warning The result buffer is statically allocated by Z3. It will
  /// be automatically deallocated when #Z3_del_context is invoked.
  /// So, the buffer is invalidated in the next call to \c Z3_ast_to_string.
  ///
  /// \sa Z3_pattern_to_string
  /// \sa Z3_sort_to_string
  ///
  /// def_API('Z3_ast_to_string', STRING, (_in(CONTEXT), _in(AST)))
  Z3_string ast_to_string(
    Z3_context c,
    Z3_ast a,
  ) {
    return _ast_to_string(
      c,
      a,
    );
  }

  late final _ast_to_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_ast)>>(
          'Z3_ast_to_string');
  late final _ast_to_string =
      _ast_to_stringPtr.asFunction<Z3_string Function(Z3_context, Z3_ast)>();

  /// def_API('Z3_pattern_to_string', STRING, (_in(CONTEXT), _in(PATTERN)))
  Z3_string pattern_to_string(
    Z3_context c,
    Z3_pattern p,
  ) {
    return _pattern_to_string(
      c,
      p,
    );
  }

  late final _pattern_to_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_pattern)>>(
          'Z3_pattern_to_string');
  late final _pattern_to_string = _pattern_to_stringPtr
      .asFunction<Z3_string Function(Z3_context, Z3_pattern)>();

  /// def_API('Z3_sort_to_string', STRING, (_in(CONTEXT), _in(SORT)))
  Z3_string sort_to_string(
    Z3_context c,
    Z3_sort s,
  ) {
    return _sort_to_string(
      c,
      s,
    );
  }

  late final _sort_to_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_sort)>>(
          'Z3_sort_to_string');
  late final _sort_to_string =
      _sort_to_stringPtr.asFunction<Z3_string Function(Z3_context, Z3_sort)>();

  /// def_API('Z3_func_decl_to_string', STRING, (_in(CONTEXT), _in(FUNC_DECL)))
  Z3_string func_decl_to_string(
    Z3_context c,
    Z3_func_decl d,
  ) {
    return _func_decl_to_string(
      c,
      d,
    );
  }

  late final _func_decl_to_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_func_decl)>>(
          'Z3_func_decl_to_string');
  late final _func_decl_to_string = _func_decl_to_stringPtr
      .asFunction<Z3_string Function(Z3_context, Z3_func_decl)>();

  /// \brief Convert the given model into a string.
  ///
  /// \warning The result buffer is statically allocated by Z3. It will
  /// be automatically deallocated when #Z3_del_context is invoked.
  /// So, the buffer is invalidated in the next call to \c Z3_model_to_string.
  ///
  /// def_API('Z3_model_to_string', STRING, (_in(CONTEXT), _in(MODEL)))
  Z3_string model_to_string(
    Z3_context c,
    Z3_model m,
  ) {
    return _model_to_string(
      c,
      m,
    );
  }

  late final _model_to_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_model)>>(
          'Z3_model_to_string');
  late final _model_to_string = _model_to_stringPtr
      .asFunction<Z3_string Function(Z3_context, Z3_model)>();

  /// \brief Convert the given benchmark into SMT-LIB formatted string.
  ///
  /// \warning The result buffer is statically allocated by Z3. It will
  /// be automatically deallocated when #Z3_del_context is invoked.
  /// So, the buffer is invalidated in the next call to \c Z3_benchmark_to_smtlib_string.
  ///
  /// \param c - context.
  /// \param name - name of benchmark. The argument is optional.
  /// \param logic - the benchmark logic.
  /// \param status - the status string (sat, unsat, or unknown)
  /// \param attributes - other attributes, such as source, difficulty or category.
  /// \param num_assumptions - number of assumptions.
  /// \param assumptions - auxiliary assumptions.
  /// \param formula - formula to be checked for consistency in conjunction with assumptions.
  ///
  /// def_API('Z3_benchmark_to_smtlib_string', STRING, (_in(CONTEXT), _in(STRING), _in(STRING), _in(STRING), _in(STRING), _in(UINT), _in_array(5, AST), _in(AST)))
  Z3_string benchmark_to_smtlib_string(
    Z3_context c,
    Z3_string name,
    Z3_string logic,
    Z3_string status,
    Z3_string attributes,
    int num_assumptions,
    ffi.Pointer<Z3_ast> assumptions,
    Z3_ast formula,
  ) {
    return _benchmark_to_smtlib_string(
      c,
      name,
      logic,
      status,
      attributes,
      num_assumptions,
      assumptions,
      formula,
    );
  }

  late final _benchmark_to_smtlib_stringPtr = _lookup<
      ffi.NativeFunction<
          Z3_string Function(
              Z3_context,
              Z3_string,
              Z3_string,
              Z3_string,
              Z3_string,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>,
              Z3_ast)>>('Z3_benchmark_to_smtlib_string');
  late final _benchmark_to_smtlib_string =
      _benchmark_to_smtlib_stringPtr.asFunction<
          Z3_string Function(Z3_context, Z3_string, Z3_string, Z3_string,
              Z3_string, int, ffi.Pointer<Z3_ast>, Z3_ast)>();

  /// @name Parser interface */
  /// /**@{*/
  /// /**
  /// \brief Parse the given string using the SMT-LIB2 parser.
  ///
  /// It returns a formula comprising of the conjunction of assertions in the scope
  /// (up to push/pop) at the end of the string.
  ///
  /// def_API('Z3_parse_smtlib2_string', AST_VECTOR, (_in(CONTEXT), _in(STRING), _in(UINT), _in_array(2, SYMBOL), _in_array(2, SORT), _in(UINT), _in_array(5, SYMBOL), _in_array(5, FUNC_DECL)))
  Z3_ast_vector parse_smtlib2_string(
    Z3_context c,
    Z3_string str,
    int num_sorts,
    ffi.Pointer<Z3_symbol> sort_names,
    ffi.Pointer<Z3_sort> sorts,
    int num_decls,
    ffi.Pointer<Z3_symbol> decl_names,
    ffi.Pointer<Z3_func_decl> decls,
  ) {
    return _parse_smtlib2_string(
      c,
      str,
      num_sorts,
      sort_names,
      sorts,
      num_decls,
      decl_names,
      decls,
    );
  }

  late final _parse_smtlib2_stringPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast_vector Function(
              Z3_context,
              Z3_string,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_symbol>,
              ffi.Pointer<Z3_sort>,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_symbol>,
              ffi.Pointer<Z3_func_decl>)>>('Z3_parse_smtlib2_string');
  late final _parse_smtlib2_string = _parse_smtlib2_stringPtr.asFunction<
      Z3_ast_vector Function(
          Z3_context,
          Z3_string,
          int,
          ffi.Pointer<Z3_symbol>,
          ffi.Pointer<Z3_sort>,
          int,
          ffi.Pointer<Z3_symbol>,
          ffi.Pointer<Z3_func_decl>)>();

  /// \brief Similar to #Z3_parse_smtlib2_string, but reads the benchmark from a file.
  ///
  /// def_API('Z3_parse_smtlib2_file', AST_VECTOR, (_in(CONTEXT), _in(STRING), _in(UINT), _in_array(2, SYMBOL), _in_array(2, SORT), _in(UINT), _in_array(5, SYMBOL), _in_array(5, FUNC_DECL)))
  Z3_ast_vector parse_smtlib2_file(
    Z3_context c,
    Z3_string file_name,
    int num_sorts,
    ffi.Pointer<Z3_symbol> sort_names,
    ffi.Pointer<Z3_sort> sorts,
    int num_decls,
    ffi.Pointer<Z3_symbol> decl_names,
    ffi.Pointer<Z3_func_decl> decls,
  ) {
    return _parse_smtlib2_file(
      c,
      file_name,
      num_sorts,
      sort_names,
      sorts,
      num_decls,
      decl_names,
      decls,
    );
  }

  late final _parse_smtlib2_filePtr = _lookup<
      ffi.NativeFunction<
          Z3_ast_vector Function(
              Z3_context,
              Z3_string,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_symbol>,
              ffi.Pointer<Z3_sort>,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_symbol>,
              ffi.Pointer<Z3_func_decl>)>>('Z3_parse_smtlib2_file');
  late final _parse_smtlib2_file = _parse_smtlib2_filePtr.asFunction<
      Z3_ast_vector Function(
          Z3_context,
          Z3_string,
          int,
          ffi.Pointer<Z3_symbol>,
          ffi.Pointer<Z3_sort>,
          int,
          ffi.Pointer<Z3_symbol>,
          ffi.Pointer<Z3_func_decl>)>();

  /// \brief Parse and evaluate and SMT-LIB2 command sequence. The state from a previous call is saved so the next
  /// evaluation builds on top of the previous call.
  ///
  /// \returns output generated from processing commands.
  ///
  /// def_API('Z3_eval_smtlib2_string', STRING, (_in(CONTEXT), _in(STRING),))
  Z3_string eval_smtlib2_string(
    Z3_context c,
    Z3_string str,
  ) {
    return _eval_smtlib2_string(
      c,
      str,
    );
  }

  late final _eval_smtlib2_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_string)>>(
          'Z3_eval_smtlib2_string');
  late final _eval_smtlib2_string = _eval_smtlib2_stringPtr
      .asFunction<Z3_string Function(Z3_context, Z3_string)>();

  /// \brief Create a parser context.
  ///
  /// A parser context maintains state between calls to \c Z3_parser_context_parse_string
  /// where the caller can pass in a set of SMTLIB2 commands.
  /// It maintains all the declarations from previous calls together with
  /// of sorts and function declarations (including 0-ary) that are added directly to the context.
  ///
  /// def_API('Z3_mk_parser_context', PARSER_CONTEXT, (_in(CONTEXT),))
  Z3_parser_context mk_parser_context(
    Z3_context c,
  ) {
    return _mk_parser_context(
      c,
    );
  }

  late final _mk_parser_contextPtr =
      _lookup<ffi.NativeFunction<Z3_parser_context Function(Z3_context)>>(
          'Z3_mk_parser_context');
  late final _mk_parser_context = _mk_parser_contextPtr
      .asFunction<Z3_parser_context Function(Z3_context)>();

  /// \brief Increment the reference counter of the given \c Z3_parser_context object.
  ///
  /// def_API('Z3_parser_context_inc_ref', VOID, (_in(CONTEXT), _in(PARSER_CONTEXT)))
  void parser_context_inc_ref(
    Z3_context c,
    Z3_parser_context pc,
  ) {
    return _parser_context_inc_ref(
      c,
      pc,
    );
  }

  late final _parser_context_inc_refPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_parser_context)>>(
      'Z3_parser_context_inc_ref');
  late final _parser_context_inc_ref = _parser_context_inc_refPtr
      .asFunction<void Function(Z3_context, Z3_parser_context)>();

  /// \brief Decrement the reference counter of the given \c Z3_parser_context object.
  ///
  /// def_API('Z3_parser_context_dec_ref', VOID, (_in(CONTEXT), _in(PARSER_CONTEXT)))
  void parser_context_dec_ref(
    Z3_context c,
    Z3_parser_context pc,
  ) {
    return _parser_context_dec_ref(
      c,
      pc,
    );
  }

  late final _parser_context_dec_refPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_parser_context)>>(
      'Z3_parser_context_dec_ref');
  late final _parser_context_dec_ref = _parser_context_dec_refPtr
      .asFunction<void Function(Z3_context, Z3_parser_context)>();

  /// \brief Add a sort declaration.
  ///
  /// def_API('Z3_parser_context_add_sort', VOID, (_in(CONTEXT), _in(PARSER_CONTEXT), _in(SORT)))
  void parser_context_add_sort(
    Z3_context c,
    Z3_parser_context pc,
    Z3_sort s,
  ) {
    return _parser_context_add_sort(
      c,
      pc,
      s,
    );
  }

  late final _parser_context_add_sortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_parser_context,
              Z3_sort)>>('Z3_parser_context_add_sort');
  late final _parser_context_add_sort = _parser_context_add_sortPtr
      .asFunction<void Function(Z3_context, Z3_parser_context, Z3_sort)>();

  /// \brief Add a function declaration.
  ///
  /// def_API('Z3_parser_context_add_decl', VOID, (_in(CONTEXT), _in(PARSER_CONTEXT), _in(FUNC_DECL)))
  void parser_context_add_decl(
    Z3_context c,
    Z3_parser_context pc,
    Z3_func_decl f,
  ) {
    return _parser_context_add_decl(
      c,
      pc,
      f,
    );
  }

  late final _parser_context_add_declPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_parser_context,
              Z3_func_decl)>>('Z3_parser_context_add_decl');
  late final _parser_context_add_decl = _parser_context_add_declPtr
      .asFunction<void Function(Z3_context, Z3_parser_context, Z3_func_decl)>();

  /// \brief Parse a string of SMTLIB2 commands. Return assertions.
  ///
  /// def_API('Z3_parser_context_from_string', AST_VECTOR, (_in(CONTEXT), _in(PARSER_CONTEXT), _in(STRING)))
  Z3_ast_vector parser_context_from_string(
    Z3_context c,
    Z3_parser_context pc,
    Z3_string s,
  ) {
    return _parser_context_from_string(
      c,
      pc,
      s,
    );
  }

  late final _parser_context_from_stringPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast_vector Function(Z3_context, Z3_parser_context,
              Z3_string)>>('Z3_parser_context_from_string');
  late final _parser_context_from_string =
      _parser_context_from_stringPtr.asFunction<
          Z3_ast_vector Function(Z3_context, Z3_parser_context, Z3_string)>();

  /// \brief Return the error code for the last API call.
  ///
  /// A call to a Z3 function may return a non Z3_OK error code,
  /// when it is not used correctly.
  ///
  /// \sa Z3_set_error_handler
  ///
  /// def_API('Z3_get_error_code', UINT, (_in(CONTEXT), ))
  int get_error_code(
    Z3_context c,
  ) {
    return _get_error_code(
      c,
    );
  }

  late final _get_error_codePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(Z3_context)>>(
          'Z3_get_error_code');
  late final _get_error_code =
      _get_error_codePtr.asFunction<int Function(Z3_context)>();

  /// \brief Register a Z3 error handler.
  ///
  /// A call to a Z3 function may return a non \c Z3_OK error code, when
  /// it is not used correctly.  An error handler can be registered
  /// and will be called in this case.  To disable the use of the
  /// error handler, simply register with \c h=NULL.
  ///
  /// \warning Log files, created using #Z3_open_log, may be potentially incomplete/incorrect if error handlers are used.
  ///
  /// \sa Z3_get_error_code
  void set_error_handler(
    Z3_context c,
    ffi.Pointer<Z3_error_handler> h,
  ) {
    return _set_error_handler(
      c,
      h,
    );
  }

  late final _set_error_handlerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context,
              ffi.Pointer<Z3_error_handler>)>>('Z3_set_error_handler');
  late final _set_error_handler = _set_error_handlerPtr
      .asFunction<void Function(Z3_context, ffi.Pointer<Z3_error_handler>)>();

  /// \brief Set an error.
  ///
  /// def_API('Z3_set_error', VOID, (_in(CONTEXT), _in(ERROR_CODE)))
  void set_error(
    Z3_context c,
    int e,
  ) {
    return _set_error(
      c,
      e,
    );
  }

  late final _set_errorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, ffi.Int32)>>(
          'Z3_set_error');
  late final _set_error =
      _set_errorPtr.asFunction<void Function(Z3_context, int)>();

  /// \brief Return a string describing the given error code.
  ///
  /// def_API('Z3_get_error_msg', STRING, (_in(CONTEXT), _in(ERROR_CODE)))
  Z3_string get_error_msg(
    Z3_context c,
    int err,
  ) {
    return _get_error_msg(
      c,
      err,
    );
  }

  late final _get_error_msgPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, ffi.Int32)>>(
          'Z3_get_error_msg');
  late final _get_error_msg =
      _get_error_msgPtr.asFunction<Z3_string Function(Z3_context, int)>();

  /// \brief Return Z3 version number information.
  ///
  /// \sa Z3_get_full_version
  ///
  /// def_API('Z3_get_version', VOID, (_out(UINT), _out(UINT), _out(UINT), _out(UINT)))
  void get_version(
    ffi.Pointer<ffi.UnsignedInt> major,
    ffi.Pointer<ffi.UnsignedInt> minor,
    ffi.Pointer<ffi.UnsignedInt> build_number,
    ffi.Pointer<ffi.UnsignedInt> revision_number,
  ) {
    return _get_version(
      major,
      minor,
      build_number,
      revision_number,
    );
  }

  late final _get_versionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.UnsignedInt>)>>('Z3_get_version');
  late final _get_version = _get_versionPtr.asFunction<
      void Function(ffi.Pointer<ffi.UnsignedInt>, ffi.Pointer<ffi.UnsignedInt>,
          ffi.Pointer<ffi.UnsignedInt>, ffi.Pointer<ffi.UnsignedInt>)>();

  /// \brief Return a string that fully describes the version of Z3 in use.
  ///
  /// \sa Z3_get_version
  ///
  /// def_API('Z3_get_full_version', STRING, ())
  Z3_string get_full_version() {
    return _get_full_version();
  }

  late final _get_full_versionPtr =
      _lookup<ffi.NativeFunction<Z3_string Function()>>('Z3_get_full_version');
  late final _get_full_version =
      _get_full_versionPtr.asFunction<Z3_string Function()>();

  /// \brief Enable tracing messages tagged as \c tag when Z3 is compiled in debug mode.
  /// It is a NOOP otherwise
  ///
  /// \sa Z3_disable_trace
  ///
  /// def_API('Z3_enable_trace', VOID, (_in(STRING),))
  void enable_trace(
    Z3_string tag,
  ) {
    return _enable_trace(
      tag,
    );
  }

  late final _enable_tracePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_string)>>(
          'Z3_enable_trace');
  late final _enable_trace =
      _enable_tracePtr.asFunction<void Function(Z3_string)>();

  /// \brief Disable tracing messages tagged as \c tag when Z3 is compiled in debug mode.
  /// It is a NOOP otherwise
  ///
  /// \sa Z3_enable_trace
  ///
  /// def_API('Z3_disable_trace', VOID, (_in(STRING),))
  void disable_trace(
    Z3_string tag,
  ) {
    return _disable_trace(
      tag,
    );
  }

  late final _disable_tracePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_string)>>(
          'Z3_disable_trace');
  late final _disable_trace =
      _disable_tracePtr.asFunction<void Function(Z3_string)>();

  /// \brief Reset all allocated resources.
  ///
  /// Use this facility on out-of memory errors.
  /// It allows discharging the previous state and resuming afresh.
  /// Any pointers previously returned by the API
  /// become invalid.
  ///
  /// def_API('Z3_reset_memory', VOID, ())
  void reset_memory() {
    return _reset_memory();
  }

  late final _reset_memoryPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Z3_reset_memory');
  late final _reset_memory = _reset_memoryPtr.asFunction<void Function()>();

  /// \brief Destroy all allocated resources.
  ///
  /// Any pointers previously returned by the API become invalid.
  /// Can be used for memory leak detection.
  ///
  /// def_API('Z3_finalize_memory', VOID, ())
  void finalize_memory() {
    return _finalize_memory();
  }

  late final _finalize_memoryPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('Z3_finalize_memory');
  late final _finalize_memory =
      _finalize_memoryPtr.asFunction<void Function()>();

  /// @name Goals */
  /// /**@{*/
  /// /**
  /// \brief Create a goal (aka problem). A goal is essentially a set
  /// of formulas, that can be solved and/or transformed using
  /// tactics and solvers.
  ///
  /// If \c models is \c true, then model generation is enabled for the new goal.
  ///
  /// If \c unsat_cores is \c true, then unsat core generation is enabled for the new goal.
  ///
  /// If \c proofs is \c true, then proof generation is enabled for the new goal. Remark, the
  /// Z3 context \c c must have been created with proof generation support.
  ///
  /// \remark Reference counting must be used to manage goals, even when the \c Z3_context was
  /// created using #Z3_mk_context instead of #Z3_mk_context_rc.
  ///
  /// def_API('Z3_mk_goal', GOAL, (_in(CONTEXT), _in(BOOL), _in(BOOL), _in(BOOL)))
  Z3_goal mk_goal(
    Z3_context c,
    bool models,
    bool unsat_cores,
    bool proofs,
  ) {
    return _mk_goal(
      c,
      models,
      unsat_cores,
      proofs,
    );
  }

  late final _mk_goalPtr = _lookup<
      ffi.NativeFunction<
          Z3_goal Function(
              Z3_context, ffi.Bool, ffi.Bool, ffi.Bool)>>('Z3_mk_goal');
  late final _mk_goal =
      _mk_goalPtr.asFunction<Z3_goal Function(Z3_context, bool, bool, bool)>();

  /// \brief Increment the reference counter of the given goal.
  ///
  /// def_API('Z3_goal_inc_ref', VOID, (_in(CONTEXT), _in(GOAL)))
  void goal_inc_ref(
    Z3_context c,
    Z3_goal g,
  ) {
    return _goal_inc_ref(
      c,
      g,
    );
  }

  late final _goal_inc_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_goal)>>(
          'Z3_goal_inc_ref');
  late final _goal_inc_ref =
      _goal_inc_refPtr.asFunction<void Function(Z3_context, Z3_goal)>();

  /// \brief Decrement the reference counter of the given goal.
  ///
  /// def_API('Z3_goal_dec_ref', VOID, (_in(CONTEXT), _in(GOAL)))
  void goal_dec_ref(
    Z3_context c,
    Z3_goal g,
  ) {
    return _goal_dec_ref(
      c,
      g,
    );
  }

  late final _goal_dec_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_goal)>>(
          'Z3_goal_dec_ref');
  late final _goal_dec_ref =
      _goal_dec_refPtr.asFunction<void Function(Z3_context, Z3_goal)>();

  /// \brief Return the "precision" of the given goal. Goals can be transformed using over and under approximations.
  /// A under approximation is applied when the objective is to find a model for a given goal.
  /// An over approximation is applied when the objective is to find a proof for a given goal.
  ///
  /// def_API('Z3_goal_precision', UINT, (_in(CONTEXT), _in(GOAL)))
  int goal_precision(
    Z3_context c,
    Z3_goal g,
  ) {
    return _goal_precision(
      c,
      g,
    );
  }

  late final _goal_precisionPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(Z3_context, Z3_goal)>>(
          'Z3_goal_precision');
  late final _goal_precision =
      _goal_precisionPtr.asFunction<int Function(Z3_context, Z3_goal)>();

  /// \brief Add a new formula \c a to the given goal.
  /// The formula is split according to the following procedure that is applied
  /// until a fixed-point:
  /// Conjunctions are split into separate formulas.
  /// Negations are distributed over disjunctions, resulting in separate formulas.
  /// If the goal is \c false, adding new formulas is a no-op.
  /// If the formula \c a is \c true, then nothing is added.
  /// If the formula \c a is \c false, then the entire goal is replaced by the formula \c false.
  ///
  /// def_API('Z3_goal_assert', VOID, (_in(CONTEXT), _in(GOAL), _in(AST)))
  void goal_assert(
    Z3_context c,
    Z3_goal g,
    Z3_ast a,
  ) {
    return _goal_assert(
      c,
      g,
      a,
    );
  }

  late final _goal_assertPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_goal, Z3_ast)>>(
      'Z3_goal_assert');
  late final _goal_assert =
      _goal_assertPtr.asFunction<void Function(Z3_context, Z3_goal, Z3_ast)>();

  /// \brief Return \c true if the given goal contains the formula \c false.
  ///
  /// def_API('Z3_goal_inconsistent', BOOL, (_in(CONTEXT), _in(GOAL)))
  bool goal_inconsistent(
    Z3_context c,
    Z3_goal g,
  ) {
    return _goal_inconsistent(
      c,
      g,
    );
  }

  late final _goal_inconsistentPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_goal)>>(
          'Z3_goal_inconsistent');
  late final _goal_inconsistent =
      _goal_inconsistentPtr.asFunction<bool Function(Z3_context, Z3_goal)>();

  /// \brief Return the depth of the given goal. It tracks how many transformations were applied to it.
  ///
  /// def_API('Z3_goal_depth', UINT, (_in(CONTEXT), _in(GOAL)))
  int goal_depth(
    Z3_context c,
    Z3_goal g,
  ) {
    return _goal_depth(
      c,
      g,
    );
  }

  late final _goal_depthPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_goal)>>(
      'Z3_goal_depth');
  late final _goal_depth =
      _goal_depthPtr.asFunction<int Function(Z3_context, Z3_goal)>();

  /// \brief Erase all formulas from the given goal.
  ///
  /// def_API('Z3_goal_reset', VOID, (_in(CONTEXT), _in(GOAL)))
  void goal_reset(
    Z3_context c,
    Z3_goal g,
  ) {
    return _goal_reset(
      c,
      g,
    );
  }

  late final _goal_resetPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_goal)>>(
          'Z3_goal_reset');
  late final _goal_reset =
      _goal_resetPtr.asFunction<void Function(Z3_context, Z3_goal)>();

  /// \brief Return the number of formulas in the given goal.
  ///
  /// def_API('Z3_goal_size', UINT, (_in(CONTEXT), _in(GOAL)))
  int goal_size(
    Z3_context c,
    Z3_goal g,
  ) {
    return _goal_size(
      c,
      g,
    );
  }

  late final _goal_sizePtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_goal)>>(
      'Z3_goal_size');
  late final _goal_size =
      _goal_sizePtr.asFunction<int Function(Z3_context, Z3_goal)>();

  /// \brief Return a formula from the given goal.
  ///
  /// \pre idx < Z3_goal_size(c, g)
  ///
  /// def_API('Z3_goal_formula', AST, (_in(CONTEXT), _in(GOAL), _in(UINT)))
  Z3_ast goal_formula(
    Z3_context c,
    Z3_goal g,
    int idx,
  ) {
    return _goal_formula(
      c,
      g,
      idx,
    );
  }

  late final _goal_formulaPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, Z3_goal, ffi.UnsignedInt)>>('Z3_goal_formula');
  late final _goal_formula =
      _goal_formulaPtr.asFunction<Z3_ast Function(Z3_context, Z3_goal, int)>();

  /// \brief Return the number of formulas, subformulas and terms in the given goal.
  ///
  /// def_API('Z3_goal_num_exprs', UINT, (_in(CONTEXT), _in(GOAL)))
  int goal_num_exprs(
    Z3_context c,
    Z3_goal g,
  ) {
    return _goal_num_exprs(
      c,
      g,
    );
  }

  late final _goal_num_exprsPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_goal)>>(
      'Z3_goal_num_exprs');
  late final _goal_num_exprs =
      _goal_num_exprsPtr.asFunction<int Function(Z3_context, Z3_goal)>();

  /// \brief Return \c true if the goal is empty, and it is precise or the product of a under approximation.
  ///
  /// def_API('Z3_goal_is_decided_sat', BOOL, (_in(CONTEXT), _in(GOAL)))
  bool goal_is_decided_sat(
    Z3_context c,
    Z3_goal g,
  ) {
    return _goal_is_decided_sat(
      c,
      g,
    );
  }

  late final _goal_is_decided_satPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_goal)>>(
          'Z3_goal_is_decided_sat');
  late final _goal_is_decided_sat =
      _goal_is_decided_satPtr.asFunction<bool Function(Z3_context, Z3_goal)>();

  /// \brief Return \c true if the goal contains false, and it is precise or the product of an over approximation.
  ///
  /// def_API('Z3_goal_is_decided_unsat', BOOL, (_in(CONTEXT), _in(GOAL)))
  bool goal_is_decided_unsat(
    Z3_context c,
    Z3_goal g,
  ) {
    return _goal_is_decided_unsat(
      c,
      g,
    );
  }

  late final _goal_is_decided_unsatPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_goal)>>(
          'Z3_goal_is_decided_unsat');
  late final _goal_is_decided_unsat = _goal_is_decided_unsatPtr
      .asFunction<bool Function(Z3_context, Z3_goal)>();

  /// \brief Copy a goal \c g from the context \c source to the context \c target.
  ///
  /// def_API('Z3_goal_translate', GOAL, (_in(CONTEXT), _in(GOAL), _in(CONTEXT)))
  Z3_goal goal_translate(
    Z3_context source,
    Z3_goal g,
    Z3_context target,
  ) {
    return _goal_translate(
      source,
      g,
      target,
    );
  }

  late final _goal_translatePtr = _lookup<
          ffi
          .NativeFunction<Z3_goal Function(Z3_context, Z3_goal, Z3_context)>>(
      'Z3_goal_translate');
  late final _goal_translate = _goal_translatePtr
      .asFunction<Z3_goal Function(Z3_context, Z3_goal, Z3_context)>();

  /// \brief Convert a model of the formulas of a goal to a model of an original goal.
  /// The model may be null, in which case the returned model is valid if the goal was
  /// established satisfiable.
  ///
  /// def_API('Z3_goal_convert_model', MODEL, (_in(CONTEXT), _in(GOAL), _in(MODEL)))
  Z3_model goal_convert_model(
    Z3_context c,
    Z3_goal g,
    Z3_model m,
  ) {
    return _goal_convert_model(
      c,
      g,
      m,
    );
  }

  late final _goal_convert_modelPtr = _lookup<
          ffi.NativeFunction<Z3_model Function(Z3_context, Z3_goal, Z3_model)>>(
      'Z3_goal_convert_model');
  late final _goal_convert_model = _goal_convert_modelPtr
      .asFunction<Z3_model Function(Z3_context, Z3_goal, Z3_model)>();

  /// \brief Convert a goal into a string.
  ///
  /// def_API('Z3_goal_to_string', STRING, (_in(CONTEXT), _in(GOAL)))
  Z3_string goal_to_string(
    Z3_context c,
    Z3_goal g,
  ) {
    return _goal_to_string(
      c,
      g,
    );
  }

  late final _goal_to_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_goal)>>(
          'Z3_goal_to_string');
  late final _goal_to_string =
      _goal_to_stringPtr.asFunction<Z3_string Function(Z3_context, Z3_goal)>();

  /// \brief Convert a goal into a DIMACS formatted string.
  /// The goal must be in CNF. You can convert a goal to CNF
  /// by applying the tseitin-cnf tactic. Bit-vectors are not automatically
  /// converted to Booleans either, so if the caller intends to
  /// preserve satisfiability, it should apply bit-blasting tactics.
  /// Quantifiers and theory atoms will not be encoded.
  ///
  /// def_API('Z3_goal_to_dimacs_string', STRING, (_in(CONTEXT), _in(GOAL), _in(BOOL)))
  Z3_string goal_to_dimacs_string(
    Z3_context c,
    Z3_goal g,
    bool include_names,
  ) {
    return _goal_to_dimacs_string(
      c,
      g,
      include_names,
    );
  }

  late final _goal_to_dimacs_stringPtr = _lookup<
          ffi
          .NativeFunction<Z3_string Function(Z3_context, Z3_goal, ffi.Bool)>>(
      'Z3_goal_to_dimacs_string');
  late final _goal_to_dimacs_string = _goal_to_dimacs_stringPtr
      .asFunction<Z3_string Function(Z3_context, Z3_goal, bool)>();

  /// @name Tactics, Simplifiers and Probes */
  /// /**@{*/
  /// /**
  /// \brief Return a tactic associated with the given name.
  /// The complete list of tactics may be obtained using the procedures #Z3_get_num_tactics and #Z3_get_tactic_name.
  /// It may also be obtained using the command \ccode{(help-tactic)} in the SMT 2.0 front-end.
  ///
  /// Tactics are the basic building block for creating custom solvers for specific problem domains.
  ///
  /// def_API('Z3_mk_tactic', TACTIC, (_in(CONTEXT), _in(STRING)))
  Z3_tactic mk_tactic(
    Z3_context c,
    Z3_string name,
  ) {
    return _mk_tactic(
      c,
      name,
    );
  }

  late final _mk_tacticPtr =
      _lookup<ffi.NativeFunction<Z3_tactic Function(Z3_context, Z3_string)>>(
          'Z3_mk_tactic');
  late final _mk_tactic =
      _mk_tacticPtr.asFunction<Z3_tactic Function(Z3_context, Z3_string)>();

  /// \brief Increment the reference counter of the given tactic.
  ///
  /// def_API('Z3_tactic_inc_ref', VOID, (_in(CONTEXT), _in(TACTIC)))
  void tactic_inc_ref(
    Z3_context c,
    Z3_tactic t,
  ) {
    return _tactic_inc_ref(
      c,
      t,
    );
  }

  late final _tactic_inc_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_tactic)>>(
          'Z3_tactic_inc_ref');
  late final _tactic_inc_ref =
      _tactic_inc_refPtr.asFunction<void Function(Z3_context, Z3_tactic)>();

  /// \brief Decrement the reference counter of the given tactic.
  ///
  /// def_API('Z3_tactic_dec_ref', VOID, (_in(CONTEXT), _in(TACTIC)))
  void tactic_dec_ref(
    Z3_context c,
    Z3_tactic g,
  ) {
    return _tactic_dec_ref(
      c,
      g,
    );
  }

  late final _tactic_dec_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_tactic)>>(
          'Z3_tactic_dec_ref');
  late final _tactic_dec_ref =
      _tactic_dec_refPtr.asFunction<void Function(Z3_context, Z3_tactic)>();

  /// \brief Return a probe associated with the given name.
  /// The complete list of probes may be obtained using the procedures #Z3_get_num_probes and #Z3_get_probe_name.
  /// It may also be obtained using the command \ccode{(help-tactic)} in the SMT 2.0 front-end.
  ///
  /// Probes are used to inspect a goal (aka problem) and collect information that may be used to decide
  /// which solver and/or preprocessing step will be used.
  ///
  /// def_API('Z3_mk_probe', PROBE, (_in(CONTEXT), _in(STRING)))
  Z3_probe mk_probe(
    Z3_context c,
    Z3_string name,
  ) {
    return _mk_probe(
      c,
      name,
    );
  }

  late final _mk_probePtr =
      _lookup<ffi.NativeFunction<Z3_probe Function(Z3_context, Z3_string)>>(
          'Z3_mk_probe');
  late final _mk_probe =
      _mk_probePtr.asFunction<Z3_probe Function(Z3_context, Z3_string)>();

  /// \brief Increment the reference counter of the given probe.
  ///
  /// def_API('Z3_probe_inc_ref', VOID, (_in(CONTEXT), _in(PROBE)))
  void probe_inc_ref(
    Z3_context c,
    Z3_probe p,
  ) {
    return _probe_inc_ref(
      c,
      p,
    );
  }

  late final _probe_inc_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_probe)>>(
          'Z3_probe_inc_ref');
  late final _probe_inc_ref =
      _probe_inc_refPtr.asFunction<void Function(Z3_context, Z3_probe)>();

  /// \brief Decrement the reference counter of the given probe.
  ///
  /// def_API('Z3_probe_dec_ref', VOID, (_in(CONTEXT), _in(PROBE)))
  void probe_dec_ref(
    Z3_context c,
    Z3_probe p,
  ) {
    return _probe_dec_ref(
      c,
      p,
    );
  }

  late final _probe_dec_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_probe)>>(
          'Z3_probe_dec_ref');
  late final _probe_dec_ref =
      _probe_dec_refPtr.asFunction<void Function(Z3_context, Z3_probe)>();

  /// \brief Return a tactic that applies \c t1 to a given goal and \c t2
  /// to every subgoal produced by \c t1.
  ///
  /// def_API('Z3_tactic_and_then', TACTIC, (_in(CONTEXT), _in(TACTIC), _in(TACTIC)))
  Z3_tactic tactic_and_then(
    Z3_context c,
    Z3_tactic t1,
    Z3_tactic t2,
  ) {
    return _tactic_and_then(
      c,
      t1,
      t2,
    );
  }

  late final _tactic_and_thenPtr = _lookup<
      ffi.NativeFunction<
          Z3_tactic Function(
              Z3_context, Z3_tactic, Z3_tactic)>>('Z3_tactic_and_then');
  late final _tactic_and_then = _tactic_and_thenPtr
      .asFunction<Z3_tactic Function(Z3_context, Z3_tactic, Z3_tactic)>();

  /// \brief Return a tactic that first applies \c t1 to a given goal,
  /// if it fails then returns the result of \c t2 applied to the given goal.
  ///
  /// def_API('Z3_tactic_or_else', TACTIC, (_in(CONTEXT), _in(TACTIC), _in(TACTIC)))
  Z3_tactic tactic_or_else(
    Z3_context c,
    Z3_tactic t1,
    Z3_tactic t2,
  ) {
    return _tactic_or_else(
      c,
      t1,
      t2,
    );
  }

  late final _tactic_or_elsePtr = _lookup<
      ffi.NativeFunction<
          Z3_tactic Function(
              Z3_context, Z3_tactic, Z3_tactic)>>('Z3_tactic_or_else');
  late final _tactic_or_else = _tactic_or_elsePtr
      .asFunction<Z3_tactic Function(Z3_context, Z3_tactic, Z3_tactic)>();

  /// \brief Return a tactic that applies the given tactics in parallel.
  ///
  /// def_API('Z3_tactic_par_or', TACTIC, (_in(CONTEXT), _in(UINT), _in_array(1, TACTIC)))
  Z3_tactic tactic_par_or(
    Z3_context c,
    int num,
    ffi.Pointer<Z3_tactic> ts,
  ) {
    return _tactic_par_or(
      c,
      num,
      ts,
    );
  }

  late final _tactic_par_orPtr = _lookup<
      ffi.NativeFunction<
          Z3_tactic Function(Z3_context, ffi.UnsignedInt,
              ffi.Pointer<Z3_tactic>)>>('Z3_tactic_par_or');
  late final _tactic_par_or = _tactic_par_orPtr.asFunction<
      Z3_tactic Function(Z3_context, int, ffi.Pointer<Z3_tactic>)>();

  /// \brief Return a tactic that applies \c t1 to a given goal and then \c t2
  /// to every subgoal produced by \c t1. The subgoals are processed in parallel.
  ///
  /// def_API('Z3_tactic_par_and_then', TACTIC, (_in(CONTEXT), _in(TACTIC), _in(TACTIC)))
  Z3_tactic tactic_par_and_then(
    Z3_context c,
    Z3_tactic t1,
    Z3_tactic t2,
  ) {
    return _tactic_par_and_then(
      c,
      t1,
      t2,
    );
  }

  late final _tactic_par_and_thenPtr = _lookup<
      ffi.NativeFunction<
          Z3_tactic Function(
              Z3_context, Z3_tactic, Z3_tactic)>>('Z3_tactic_par_and_then');
  late final _tactic_par_and_then = _tactic_par_and_thenPtr
      .asFunction<Z3_tactic Function(Z3_context, Z3_tactic, Z3_tactic)>();

  /// \brief Return a tactic that applies \c t to a given goal for \c ms milliseconds.
  /// If \c t does not terminate in \c ms milliseconds, then it fails.
  ///
  /// def_API('Z3_tactic_try_for', TACTIC, (_in(CONTEXT), _in(TACTIC), _in(UINT)))
  Z3_tactic tactic_try_for(
    Z3_context c,
    Z3_tactic t,
    int ms,
  ) {
    return _tactic_try_for(
      c,
      t,
      ms,
    );
  }

  late final _tactic_try_forPtr = _lookup<
      ffi.NativeFunction<
          Z3_tactic Function(
              Z3_context, Z3_tactic, ffi.UnsignedInt)>>('Z3_tactic_try_for');
  late final _tactic_try_for = _tactic_try_forPtr
      .asFunction<Z3_tactic Function(Z3_context, Z3_tactic, int)>();

  /// \brief Return a tactic that applies \c t to a given goal is the probe \c p evaluates to true.
  /// If \c p evaluates to false, then the new tactic behaves like the skip tactic.
  ///
  /// def_API('Z3_tactic_when', TACTIC, (_in(CONTEXT), _in(PROBE), _in(TACTIC)))
  Z3_tactic tactic_when(
    Z3_context c,
    Z3_probe p,
    Z3_tactic t,
  ) {
    return _tactic_when(
      c,
      p,
      t,
    );
  }

  late final _tactic_whenPtr = _lookup<
          ffi
          .NativeFunction<Z3_tactic Function(Z3_context, Z3_probe, Z3_tactic)>>(
      'Z3_tactic_when');
  late final _tactic_when = _tactic_whenPtr
      .asFunction<Z3_tactic Function(Z3_context, Z3_probe, Z3_tactic)>();

  /// \brief Return a tactic that applies \c t1 to a given goal if the probe \c p evaluates to true,
  /// and \c t2 if \c p evaluates to false.
  ///
  /// def_API('Z3_tactic_cond', TACTIC, (_in(CONTEXT), _in(PROBE), _in(TACTIC), _in(TACTIC)))
  Z3_tactic tactic_cond(
    Z3_context c,
    Z3_probe p,
    Z3_tactic t1,
    Z3_tactic t2,
  ) {
    return _tactic_cond(
      c,
      p,
      t1,
      t2,
    );
  }

  late final _tactic_condPtr = _lookup<
      ffi.NativeFunction<
          Z3_tactic Function(
              Z3_context, Z3_probe, Z3_tactic, Z3_tactic)>>('Z3_tactic_cond');
  late final _tactic_cond = _tactic_condPtr.asFunction<
      Z3_tactic Function(Z3_context, Z3_probe, Z3_tactic, Z3_tactic)>();

  /// \brief Return a tactic that keeps applying \c t until the goal is not modified anymore or the maximum
  /// number of iterations \c max is reached.
  ///
  /// def_API('Z3_tactic_repeat', TACTIC, (_in(CONTEXT), _in(TACTIC), _in(UINT)))
  Z3_tactic tactic_repeat(
    Z3_context c,
    Z3_tactic t,
    int max,
  ) {
    return _tactic_repeat(
      c,
      t,
      max,
    );
  }

  late final _tactic_repeatPtr = _lookup<
      ffi.NativeFunction<
          Z3_tactic Function(
              Z3_context, Z3_tactic, ffi.UnsignedInt)>>('Z3_tactic_repeat');
  late final _tactic_repeat = _tactic_repeatPtr
      .asFunction<Z3_tactic Function(Z3_context, Z3_tactic, int)>();

  /// \brief Return a tactic that just return the given goal.
  ///
  /// def_API('Z3_tactic_skip', TACTIC, (_in(CONTEXT),))
  Z3_tactic tactic_skip(
    Z3_context c,
  ) {
    return _tactic_skip(
      c,
    );
  }

  late final _tactic_skipPtr =
      _lookup<ffi.NativeFunction<Z3_tactic Function(Z3_context)>>(
          'Z3_tactic_skip');
  late final _tactic_skip =
      _tactic_skipPtr.asFunction<Z3_tactic Function(Z3_context)>();

  /// \brief Return a tactic that always fails.
  ///
  /// def_API('Z3_tactic_fail', TACTIC, (_in(CONTEXT),))
  Z3_tactic tactic_fail(
    Z3_context c,
  ) {
    return _tactic_fail(
      c,
    );
  }

  late final _tactic_failPtr =
      _lookup<ffi.NativeFunction<Z3_tactic Function(Z3_context)>>(
          'Z3_tactic_fail');
  late final _tactic_fail =
      _tactic_failPtr.asFunction<Z3_tactic Function(Z3_context)>();

  /// \brief Return a tactic that fails if the probe \c p evaluates to false.
  ///
  /// def_API('Z3_tactic_fail_if', TACTIC, (_in(CONTEXT), _in(PROBE)))
  Z3_tactic tactic_fail_if(
    Z3_context c,
    Z3_probe p,
  ) {
    return _tactic_fail_if(
      c,
      p,
    );
  }

  late final _tactic_fail_ifPtr =
      _lookup<ffi.NativeFunction<Z3_tactic Function(Z3_context, Z3_probe)>>(
          'Z3_tactic_fail_if');
  late final _tactic_fail_if =
      _tactic_fail_ifPtr.asFunction<Z3_tactic Function(Z3_context, Z3_probe)>();

  /// \brief Return a tactic that fails if the goal is not trivially satisfiable (i.e., empty) or
  /// trivially unsatisfiable (i.e., contains false).
  ///
  /// def_API('Z3_tactic_fail_if_not_decided', TACTIC, (_in(CONTEXT),))
  Z3_tactic tactic_fail_if_not_decided(
    Z3_context c,
  ) {
    return _tactic_fail_if_not_decided(
      c,
    );
  }

  late final _tactic_fail_if_not_decidedPtr =
      _lookup<ffi.NativeFunction<Z3_tactic Function(Z3_context)>>(
          'Z3_tactic_fail_if_not_decided');
  late final _tactic_fail_if_not_decided = _tactic_fail_if_not_decidedPtr
      .asFunction<Z3_tactic Function(Z3_context)>();

  /// \brief Return a tactic that applies \c t using the given set of parameters.
  ///
  /// def_API('Z3_tactic_using_params', TACTIC, (_in(CONTEXT), _in(TACTIC), _in(PARAMS)))
  Z3_tactic tactic_using_params(
    Z3_context c,
    Z3_tactic t,
    Z3_params p,
  ) {
    return _tactic_using_params(
      c,
      t,
      p,
    );
  }

  late final _tactic_using_paramsPtr = _lookup<
      ffi.NativeFunction<
          Z3_tactic Function(
              Z3_context, Z3_tactic, Z3_params)>>('Z3_tactic_using_params');
  late final _tactic_using_params = _tactic_using_paramsPtr
      .asFunction<Z3_tactic Function(Z3_context, Z3_tactic, Z3_params)>();

  /// \brief Return a simplifier associated with the given name.
  /// The complete list of simplifiers may be obtained using the procedures #Z3_get_num_simplifiers and #Z3_get_simplifier_name.
  /// It may also be obtained using the command \ccode{(help-simplifier)} in the SMT 2.0 front-end.
  ///
  /// Simplifiers are the basic building block for creating custom solvers for specific problem domains.
  ///
  /// def_API('Z3_mk_simplifier', SIMPLIFIER, (_in(CONTEXT), _in(STRING)))
  Z3_simplifier mk_simplifier(
    Z3_context c,
    Z3_string name,
  ) {
    return _mk_simplifier(
      c,
      name,
    );
  }

  late final _mk_simplifierPtr = _lookup<
          ffi.NativeFunction<Z3_simplifier Function(Z3_context, Z3_string)>>(
      'Z3_mk_simplifier');
  late final _mk_simplifier = _mk_simplifierPtr
      .asFunction<Z3_simplifier Function(Z3_context, Z3_string)>();

  /// \brief Increment the reference counter of the given simplifier.
  ///
  /// def_API('Z3_simplifier_inc_ref', VOID, (_in(CONTEXT), _in(SIMPLIFIER)))
  void simplifier_inc_ref(
    Z3_context c,
    Z3_simplifier t,
  ) {
    return _simplifier_inc_ref(
      c,
      t,
    );
  }

  late final _simplifier_inc_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_simplifier)>>(
          'Z3_simplifier_inc_ref');
  late final _simplifier_inc_ref = _simplifier_inc_refPtr
      .asFunction<void Function(Z3_context, Z3_simplifier)>();

  /// \brief Decrement the reference counter of the given simplifier.
  ///
  /// def_API('Z3_simplifier_dec_ref', VOID, (_in(CONTEXT), _in(SIMPLIFIER)))
  void simplifier_dec_ref(
    Z3_context c,
    Z3_simplifier g,
  ) {
    return _simplifier_dec_ref(
      c,
      g,
    );
  }

  late final _simplifier_dec_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_simplifier)>>(
          'Z3_simplifier_dec_ref');
  late final _simplifier_dec_ref = _simplifier_dec_refPtr
      .asFunction<void Function(Z3_context, Z3_simplifier)>();

  /// \brief Attach simplifier to a solver. The solver will use the simplifier for incremental pre-processing.
  ///
  /// def_API('Z3_solver_add_simplifier', SOLVER, (_in(CONTEXT), _in(SOLVER), _in(SIMPLIFIER)))
  Z3_solver solver_add_simplifier(
    Z3_context c,
    Z3_solver solver,
    Z3_simplifier simplifier,
  ) {
    return _solver_add_simplifier(
      c,
      solver,
      simplifier,
    );
  }

  late final _solver_add_simplifierPtr = _lookup<
      ffi.NativeFunction<
          Z3_solver Function(Z3_context, Z3_solver,
              Z3_simplifier)>>('Z3_solver_add_simplifier');
  late final _solver_add_simplifier = _solver_add_simplifierPtr
      .asFunction<Z3_solver Function(Z3_context, Z3_solver, Z3_simplifier)>();

  /// \brief Return a simplifier that applies \c t1 to a given goal and \c t2
  /// to every subgoal produced by \c t1.
  ///
  /// def_API('Z3_simplifier_and_then', SIMPLIFIER, (_in(CONTEXT), _in(SIMPLIFIER), _in(SIMPLIFIER)))
  Z3_simplifier simplifier_and_then(
    Z3_context c,
    Z3_simplifier t1,
    Z3_simplifier t2,
  ) {
    return _simplifier_and_then(
      c,
      t1,
      t2,
    );
  }

  late final _simplifier_and_thenPtr = _lookup<
      ffi.NativeFunction<
          Z3_simplifier Function(Z3_context, Z3_simplifier,
              Z3_simplifier)>>('Z3_simplifier_and_then');
  late final _simplifier_and_then = _simplifier_and_thenPtr.asFunction<
      Z3_simplifier Function(Z3_context, Z3_simplifier, Z3_simplifier)>();

  /// \brief Return a simplifier that applies \c t using the given set of parameters.
  ///
  /// def_API('Z3_simplifier_using_params', SIMPLIFIER, (_in(CONTEXT), _in(SIMPLIFIER), _in(PARAMS)))
  Z3_simplifier simplifier_using_params(
    Z3_context c,
    Z3_simplifier t,
    Z3_params p,
  ) {
    return _simplifier_using_params(
      c,
      t,
      p,
    );
  }

  late final _simplifier_using_paramsPtr = _lookup<
      ffi.NativeFunction<
          Z3_simplifier Function(Z3_context, Z3_simplifier,
              Z3_params)>>('Z3_simplifier_using_params');
  late final _simplifier_using_params = _simplifier_using_paramsPtr.asFunction<
      Z3_simplifier Function(Z3_context, Z3_simplifier, Z3_params)>();

  /// \brief Return the number of builtin simplifiers available in Z3.
  ///
  /// \sa Z3_get_simplifier_name
  ///
  /// def_API('Z3_get_num_simplifiers', UINT, (_in(CONTEXT),))
  int get_num_simplifiers(
    Z3_context c,
  ) {
    return _get_num_simplifiers(
      c,
    );
  }

  late final _get_num_simplifiersPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context)>>(
          'Z3_get_num_simplifiers');
  late final _get_num_simplifiers =
      _get_num_simplifiersPtr.asFunction<int Function(Z3_context)>();

  /// \brief Return the name of the idx simplifier.
  ///
  /// \pre i < Z3_get_num_simplifiers(c)
  ///
  /// \sa Z3_get_num_simplifiers
  ///
  /// def_API('Z3_get_simplifier_name', STRING, (_in(CONTEXT), _in(UINT)))
  Z3_string get_simplifier_name(
    Z3_context c,
    int i,
  ) {
    return _get_simplifier_name(
      c,
      i,
    );
  }

  late final _get_simplifier_namePtr = _lookup<
          ffi.NativeFunction<Z3_string Function(Z3_context, ffi.UnsignedInt)>>(
      'Z3_get_simplifier_name');
  late final _get_simplifier_name =
      _get_simplifier_namePtr.asFunction<Z3_string Function(Z3_context, int)>();

  /// \brief Return a string containing a description of parameters accepted by the given simplifier.
  ///
  /// def_API('Z3_simplifier_get_help', STRING, (_in(CONTEXT), _in(SIMPLIFIER)))
  Z3_string simplifier_get_help(
    Z3_context c,
    Z3_simplifier t,
  ) {
    return _simplifier_get_help(
      c,
      t,
    );
  }

  late final _simplifier_get_helpPtr = _lookup<
          ffi.NativeFunction<Z3_string Function(Z3_context, Z3_simplifier)>>(
      'Z3_simplifier_get_help');
  late final _simplifier_get_help = _simplifier_get_helpPtr
      .asFunction<Z3_string Function(Z3_context, Z3_simplifier)>();

  /// \brief Return the parameter description set for the given simplifier object.
  ///
  /// def_API('Z3_simplifier_get_param_descrs', PARAM_DESCRS, (_in(CONTEXT), _in(SIMPLIFIER)))
  Z3_param_descrs simplifier_get_param_descrs(
    Z3_context c,
    Z3_simplifier t,
  ) {
    return _simplifier_get_param_descrs(
      c,
      t,
    );
  }

  late final _simplifier_get_param_descrsPtr = _lookup<
          ffi
          .NativeFunction<Z3_param_descrs Function(Z3_context, Z3_simplifier)>>(
      'Z3_simplifier_get_param_descrs');
  late final _simplifier_get_param_descrs = _simplifier_get_param_descrsPtr
      .asFunction<Z3_param_descrs Function(Z3_context, Z3_simplifier)>();

  /// \brief Return a string containing a description of the simplifier with the given name.
  ///
  /// def_API('Z3_simplifier_get_descr', STRING, (_in(CONTEXT), _in(STRING)))
  Z3_string simplifier_get_descr(
    Z3_context c,
    Z3_string name,
  ) {
    return _simplifier_get_descr(
      c,
      name,
    );
  }

  late final _simplifier_get_descrPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_string)>>(
          'Z3_simplifier_get_descr');
  late final _simplifier_get_descr = _simplifier_get_descrPtr
      .asFunction<Z3_string Function(Z3_context, Z3_string)>();

  /// \brief Return a probe that always evaluates to val.
  ///
  /// def_API('Z3_probe_const', PROBE, (_in(CONTEXT), _in(DOUBLE)))
  Z3_probe probe_const(
    Z3_context x,
    double val,
  ) {
    return _probe_const(
      x,
      val,
    );
  }

  late final _probe_constPtr =
      _lookup<ffi.NativeFunction<Z3_probe Function(Z3_context, ffi.Double)>>(
          'Z3_probe_const');
  late final _probe_const =
      _probe_constPtr.asFunction<Z3_probe Function(Z3_context, double)>();

  /// \brief Return a probe that evaluates to "true" when the value returned by \c p1 is less than the value returned by \c p2.
  ///
  /// \remark For probes, "true" is any value different from 0.0.
  ///
  /// def_API('Z3_probe_lt', PROBE, (_in(CONTEXT), _in(PROBE), _in(PROBE)))
  Z3_probe probe_lt(
    Z3_context x,
    Z3_probe p1,
    Z3_probe p2,
  ) {
    return _probe_lt(
      x,
      p1,
      p2,
    );
  }

  late final _probe_ltPtr = _lookup<
          ffi
          .NativeFunction<Z3_probe Function(Z3_context, Z3_probe, Z3_probe)>>(
      'Z3_probe_lt');
  late final _probe_lt = _probe_ltPtr
      .asFunction<Z3_probe Function(Z3_context, Z3_probe, Z3_probe)>();

  /// \brief Return a probe that evaluates to "true" when the value returned by \c p1 is greater than the value returned by \c p2.
  ///
  /// \remark For probes, "true" is any value different from 0.0.
  ///
  /// def_API('Z3_probe_gt', PROBE, (_in(CONTEXT), _in(PROBE), _in(PROBE)))
  Z3_probe probe_gt(
    Z3_context x,
    Z3_probe p1,
    Z3_probe p2,
  ) {
    return _probe_gt(
      x,
      p1,
      p2,
    );
  }

  late final _probe_gtPtr = _lookup<
          ffi
          .NativeFunction<Z3_probe Function(Z3_context, Z3_probe, Z3_probe)>>(
      'Z3_probe_gt');
  late final _probe_gt = _probe_gtPtr
      .asFunction<Z3_probe Function(Z3_context, Z3_probe, Z3_probe)>();

  /// \brief Return a probe that evaluates to "true" when the value returned by \c p1 is less than or equal to the value returned by \c p2.
  ///
  /// \remark For probes, "true" is any value different from 0.0.
  ///
  /// def_API('Z3_probe_le', PROBE, (_in(CONTEXT), _in(PROBE), _in(PROBE)))
  Z3_probe probe_le(
    Z3_context x,
    Z3_probe p1,
    Z3_probe p2,
  ) {
    return _probe_le(
      x,
      p1,
      p2,
    );
  }

  late final _probe_lePtr = _lookup<
          ffi
          .NativeFunction<Z3_probe Function(Z3_context, Z3_probe, Z3_probe)>>(
      'Z3_probe_le');
  late final _probe_le = _probe_lePtr
      .asFunction<Z3_probe Function(Z3_context, Z3_probe, Z3_probe)>();

  /// \brief Return a probe that evaluates to "true" when the value returned by \c p1 is greater than or equal to the value returned by \c p2.
  ///
  /// \remark For probes, "true" is any value different from 0.0.
  ///
  /// def_API('Z3_probe_ge', PROBE, (_in(CONTEXT), _in(PROBE), _in(PROBE)))
  Z3_probe probe_ge(
    Z3_context x,
    Z3_probe p1,
    Z3_probe p2,
  ) {
    return _probe_ge(
      x,
      p1,
      p2,
    );
  }

  late final _probe_gePtr = _lookup<
          ffi
          .NativeFunction<Z3_probe Function(Z3_context, Z3_probe, Z3_probe)>>(
      'Z3_probe_ge');
  late final _probe_ge = _probe_gePtr
      .asFunction<Z3_probe Function(Z3_context, Z3_probe, Z3_probe)>();

  /// \brief Return a probe that evaluates to "true" when the value returned by \c p1 is equal to the value returned by \c p2.
  ///
  /// \remark For probes, "true" is any value different from 0.0.
  ///
  /// def_API('Z3_probe_eq', PROBE, (_in(CONTEXT), _in(PROBE), _in(PROBE)))
  Z3_probe probe_eq(
    Z3_context x,
    Z3_probe p1,
    Z3_probe p2,
  ) {
    return _probe_eq(
      x,
      p1,
      p2,
    );
  }

  late final _probe_eqPtr = _lookup<
          ffi
          .NativeFunction<Z3_probe Function(Z3_context, Z3_probe, Z3_probe)>>(
      'Z3_probe_eq');
  late final _probe_eq = _probe_eqPtr
      .asFunction<Z3_probe Function(Z3_context, Z3_probe, Z3_probe)>();

  /// \brief Return a probe that evaluates to "true" when \c p1 and \c p2 evaluates to true.
  ///
  /// \remark For probes, "true" is any value different from 0.0.
  ///
  /// def_API('Z3_probe_and', PROBE, (_in(CONTEXT), _in(PROBE), _in(PROBE)))
  Z3_probe probe_and(
    Z3_context x,
    Z3_probe p1,
    Z3_probe p2,
  ) {
    return _probe_and(
      x,
      p1,
      p2,
    );
  }

  late final _probe_andPtr = _lookup<
          ffi
          .NativeFunction<Z3_probe Function(Z3_context, Z3_probe, Z3_probe)>>(
      'Z3_probe_and');
  late final _probe_and = _probe_andPtr
      .asFunction<Z3_probe Function(Z3_context, Z3_probe, Z3_probe)>();

  /// \brief Return a probe that evaluates to "true" when \c p1 or \c p2 evaluates to true.
  ///
  /// \remark For probes, "true" is any value different from 0.0.
  ///
  /// def_API('Z3_probe_or', PROBE, (_in(CONTEXT), _in(PROBE), _in(PROBE)))
  Z3_probe probe_or(
    Z3_context x,
    Z3_probe p1,
    Z3_probe p2,
  ) {
    return _probe_or(
      x,
      p1,
      p2,
    );
  }

  late final _probe_orPtr = _lookup<
          ffi
          .NativeFunction<Z3_probe Function(Z3_context, Z3_probe, Z3_probe)>>(
      'Z3_probe_or');
  late final _probe_or = _probe_orPtr
      .asFunction<Z3_probe Function(Z3_context, Z3_probe, Z3_probe)>();

  /// \brief Return a probe that evaluates to "true" when \c p does not evaluate to true.
  ///
  /// \remark For probes, "true" is any value different from 0.0.
  ///
  /// def_API('Z3_probe_not', PROBE, (_in(CONTEXT), _in(PROBE)))
  Z3_probe probe_not(
    Z3_context x,
    Z3_probe p,
  ) {
    return _probe_not(
      x,
      p,
    );
  }

  late final _probe_notPtr =
      _lookup<ffi.NativeFunction<Z3_probe Function(Z3_context, Z3_probe)>>(
          'Z3_probe_not');
  late final _probe_not =
      _probe_notPtr.asFunction<Z3_probe Function(Z3_context, Z3_probe)>();

  /// \brief Return the number of builtin tactics available in Z3.
  ///
  /// \sa Z3_get_tactic_name
  ///
  /// def_API('Z3_get_num_tactics', UINT, (_in(CONTEXT),))
  int get_num_tactics(
    Z3_context c,
  ) {
    return _get_num_tactics(
      c,
    );
  }

  late final _get_num_tacticsPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context)>>(
          'Z3_get_num_tactics');
  late final _get_num_tactics =
      _get_num_tacticsPtr.asFunction<int Function(Z3_context)>();

  /// \brief Return the name of the idx tactic.
  ///
  /// \pre i < Z3_get_num_tactics(c)
  ///
  /// \sa Z3_get_num_tactics
  ///
  /// def_API('Z3_get_tactic_name', STRING, (_in(CONTEXT), _in(UINT)))
  Z3_string get_tactic_name(
    Z3_context c,
    int i,
  ) {
    return _get_tactic_name(
      c,
      i,
    );
  }

  late final _get_tactic_namePtr = _lookup<
          ffi.NativeFunction<Z3_string Function(Z3_context, ffi.UnsignedInt)>>(
      'Z3_get_tactic_name');
  late final _get_tactic_name =
      _get_tactic_namePtr.asFunction<Z3_string Function(Z3_context, int)>();

  /// \brief Return the number of builtin probes available in Z3.
  ///
  /// \sa Z3_get_probe_name
  ///
  /// def_API('Z3_get_num_probes', UINT, (_in(CONTEXT),))
  int get_num_probes(
    Z3_context c,
  ) {
    return _get_num_probes(
      c,
    );
  }

  late final _get_num_probesPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context)>>(
          'Z3_get_num_probes');
  late final _get_num_probes =
      _get_num_probesPtr.asFunction<int Function(Z3_context)>();

  /// \brief Return the name of the \c i probe.
  ///
  /// \pre i < Z3_get_num_probes(c)
  ///
  /// \sa Z3_get_num_probes
  ///
  /// def_API('Z3_get_probe_name', STRING, (_in(CONTEXT), _in(UINT)))
  Z3_string get_probe_name(
    Z3_context c,
    int i,
  ) {
    return _get_probe_name(
      c,
      i,
    );
  }

  late final _get_probe_namePtr = _lookup<
          ffi.NativeFunction<Z3_string Function(Z3_context, ffi.UnsignedInt)>>(
      'Z3_get_probe_name');
  late final _get_probe_name =
      _get_probe_namePtr.asFunction<Z3_string Function(Z3_context, int)>();

  /// \brief Return a string containing a description of parameters accepted by the given tactic.
  ///
  /// def_API('Z3_tactic_get_help', STRING, (_in(CONTEXT), _in(TACTIC)))
  Z3_string tactic_get_help(
    Z3_context c,
    Z3_tactic t,
  ) {
    return _tactic_get_help(
      c,
      t,
    );
  }

  late final _tactic_get_helpPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_tactic)>>(
          'Z3_tactic_get_help');
  late final _tactic_get_help = _tactic_get_helpPtr
      .asFunction<Z3_string Function(Z3_context, Z3_tactic)>();

  /// \brief Return the parameter description set for the given tactic object.
  ///
  /// def_API('Z3_tactic_get_param_descrs', PARAM_DESCRS, (_in(CONTEXT), _in(TACTIC)))
  Z3_param_descrs tactic_get_param_descrs(
    Z3_context c,
    Z3_tactic t,
  ) {
    return _tactic_get_param_descrs(
      c,
      t,
    );
  }

  late final _tactic_get_param_descrsPtr = _lookup<
          ffi.NativeFunction<Z3_param_descrs Function(Z3_context, Z3_tactic)>>(
      'Z3_tactic_get_param_descrs');
  late final _tactic_get_param_descrs = _tactic_get_param_descrsPtr
      .asFunction<Z3_param_descrs Function(Z3_context, Z3_tactic)>();

  /// \brief Return a string containing a description of the tactic with the given name.
  ///
  /// def_API('Z3_tactic_get_descr', STRING, (_in(CONTEXT), _in(STRING)))
  Z3_string tactic_get_descr(
    Z3_context c,
    Z3_string name,
  ) {
    return _tactic_get_descr(
      c,
      name,
    );
  }

  late final _tactic_get_descrPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_string)>>(
          'Z3_tactic_get_descr');
  late final _tactic_get_descr = _tactic_get_descrPtr
      .asFunction<Z3_string Function(Z3_context, Z3_string)>();

  /// \brief Return a string containing a description of the probe with the given name.
  ///
  /// def_API('Z3_probe_get_descr', STRING, (_in(CONTEXT), _in(STRING)))
  Z3_string probe_get_descr(
    Z3_context c,
    Z3_string name,
  ) {
    return _probe_get_descr(
      c,
      name,
    );
  }

  late final _probe_get_descrPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_string)>>(
          'Z3_probe_get_descr');
  late final _probe_get_descr = _probe_get_descrPtr
      .asFunction<Z3_string Function(Z3_context, Z3_string)>();

  /// \brief Execute the probe over the goal. The probe always produce a double value.
  /// "Boolean" probes return 0.0 for false, and a value different from 0.0 for true.
  ///
  /// def_API('Z3_probe_apply', DOUBLE, (_in(CONTEXT), _in(PROBE), _in(GOAL)))
  double probe_apply(
    Z3_context c,
    Z3_probe p,
    Z3_goal g,
  ) {
    return _probe_apply(
      c,
      p,
      g,
    );
  }

  late final _probe_applyPtr = _lookup<
          ffi
          .NativeFunction<ffi.Double Function(Z3_context, Z3_probe, Z3_goal)>>(
      'Z3_probe_apply');
  late final _probe_apply = _probe_applyPtr
      .asFunction<double Function(Z3_context, Z3_probe, Z3_goal)>();

  /// \brief Apply tactic \c t to the goal \c g.
  ///
  /// \sa Z3_tactic_apply_ex
  ///
  /// def_API('Z3_tactic_apply', APPLY_RESULT, (_in(CONTEXT), _in(TACTIC), _in(GOAL)))
  Z3_apply_result tactic_apply(
    Z3_context c,
    Z3_tactic t,
    Z3_goal g,
  ) {
    return _tactic_apply(
      c,
      t,
      g,
    );
  }

  late final _tactic_applyPtr = _lookup<
      ffi.NativeFunction<
          Z3_apply_result Function(
              Z3_context, Z3_tactic, Z3_goal)>>('Z3_tactic_apply');
  late final _tactic_apply = _tactic_applyPtr
      .asFunction<Z3_apply_result Function(Z3_context, Z3_tactic, Z3_goal)>();

  /// \brief Apply tactic \c t to the goal \c g using the parameter set \c p.
  ///
  /// \sa Z3_tactic_apply
  ///
  /// def_API('Z3_tactic_apply_ex', APPLY_RESULT, (_in(CONTEXT), _in(TACTIC), _in(GOAL), _in(PARAMS)))
  Z3_apply_result tactic_apply_ex(
    Z3_context c,
    Z3_tactic t,
    Z3_goal g,
    Z3_params p,
  ) {
    return _tactic_apply_ex(
      c,
      t,
      g,
      p,
    );
  }

  late final _tactic_apply_exPtr = _lookup<
      ffi.NativeFunction<
          Z3_apply_result Function(Z3_context, Z3_tactic, Z3_goal,
              Z3_params)>>('Z3_tactic_apply_ex');
  late final _tactic_apply_ex = _tactic_apply_exPtr.asFunction<
      Z3_apply_result Function(Z3_context, Z3_tactic, Z3_goal, Z3_params)>();

  /// \brief Increment the reference counter of the given \c Z3_apply_result object.
  ///
  /// def_API('Z3_apply_result_inc_ref', VOID, (_in(CONTEXT), _in(APPLY_RESULT)))
  void apply_result_inc_ref(
    Z3_context c,
    Z3_apply_result r,
  ) {
    return _apply_result_inc_ref(
      c,
      r,
    );
  }

  late final _apply_result_inc_refPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_apply_result)>>(
      'Z3_apply_result_inc_ref');
  late final _apply_result_inc_ref = _apply_result_inc_refPtr
      .asFunction<void Function(Z3_context, Z3_apply_result)>();

  /// \brief Decrement the reference counter of the given \c Z3_apply_result object.
  ///
  /// def_API('Z3_apply_result_dec_ref', VOID, (_in(CONTEXT), _in(APPLY_RESULT)))
  void apply_result_dec_ref(
    Z3_context c,
    Z3_apply_result r,
  ) {
    return _apply_result_dec_ref(
      c,
      r,
    );
  }

  late final _apply_result_dec_refPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_apply_result)>>(
      'Z3_apply_result_dec_ref');
  late final _apply_result_dec_ref = _apply_result_dec_refPtr
      .asFunction<void Function(Z3_context, Z3_apply_result)>();

  /// \brief Convert the \c Z3_apply_result object returned by #Z3_tactic_apply into a string.
  ///
  /// def_API('Z3_apply_result_to_string', STRING, (_in(CONTEXT), _in(APPLY_RESULT)))
  Z3_string apply_result_to_string(
    Z3_context c,
    Z3_apply_result r,
  ) {
    return _apply_result_to_string(
      c,
      r,
    );
  }

  late final _apply_result_to_stringPtr = _lookup<
          ffi.NativeFunction<Z3_string Function(Z3_context, Z3_apply_result)>>(
      'Z3_apply_result_to_string');
  late final _apply_result_to_string = _apply_result_to_stringPtr
      .asFunction<Z3_string Function(Z3_context, Z3_apply_result)>();

  /// \brief Return the number of subgoals in the \c Z3_apply_result object returned by #Z3_tactic_apply.
  ///
  /// \sa Z3_apply_result_get_subgoal
  ///
  /// def_API('Z3_apply_result_get_num_subgoals', UINT, (_in(CONTEXT), _in(APPLY_RESULT)))
  int apply_result_get_num_subgoals(
    Z3_context c,
    Z3_apply_result r,
  ) {
    return _apply_result_get_num_subgoals(
      c,
      r,
    );
  }

  late final _apply_result_get_num_subgoalsPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(Z3_context,
              Z3_apply_result)>>('Z3_apply_result_get_num_subgoals');
  late final _apply_result_get_num_subgoals = _apply_result_get_num_subgoalsPtr
      .asFunction<int Function(Z3_context, Z3_apply_result)>();

  /// \brief Return one of the subgoals in the \c Z3_apply_result object returned by #Z3_tactic_apply.
  ///
  /// \pre i < Z3_apply_result_get_num_subgoals(c, r)
  ///
  /// \sa Z3_apply_result_get_num_subgoals
  ///
  /// def_API('Z3_apply_result_get_subgoal', GOAL, (_in(CONTEXT), _in(APPLY_RESULT), _in(UINT)))
  Z3_goal apply_result_get_subgoal(
    Z3_context c,
    Z3_apply_result r,
    int i,
  ) {
    return _apply_result_get_subgoal(
      c,
      r,
      i,
    );
  }

  late final _apply_result_get_subgoalPtr = _lookup<
      ffi.NativeFunction<
          Z3_goal Function(Z3_context, Z3_apply_result,
              ffi.UnsignedInt)>>('Z3_apply_result_get_subgoal');
  late final _apply_result_get_subgoal = _apply_result_get_subgoalPtr
      .asFunction<Z3_goal Function(Z3_context, Z3_apply_result, int)>();

  /// @name Solvers*/
  /// /**@{*/
  /// /**
  /// \brief Create a new solver. This solver is a "combined solver" (see
  /// combined_solver module) that internally uses a non-incremental (solver1) and an
  /// incremental solver (solver2). This combined solver changes its behaviour based
  /// on how it is used and how its parameters are set.
  ///
  /// If the solver is used in a non incremental way (i.e. no calls to
  /// #Z3_solver_push() or #Z3_solver_pop(), and no calls to
  /// #Z3_solver_assert() or #Z3_solver_assert_and_track() after checking
  /// satisfiability without an intervening #Z3_solver_reset()) then solver1
  /// will be used. This solver will apply Z3's "default" tactic.
  ///
  /// The "default" tactic will attempt to probe the logic used by the
  /// assertions and will apply a specialized tactic if one is supported.
  /// Otherwise the general `(and-then simplify smt)` tactic will be used.
  ///
  /// If the solver is used in an incremental way then the combined solver
  /// will switch to using solver2 (which behaves similarly to the general
  /// "smt" tactic).
  ///
  /// Note however it is possible to set the `solver2_timeout`,
  /// `solver2_unknown`, and `ignore_solver1` parameters of the combined
  /// solver to change its behaviour.
  ///
  /// The function #Z3_solver_get_model retrieves a model if the
  /// assertions is satisfiable (i.e., the result is \c
  /// Z3_L_TRUE) and model construction is enabled.
  /// The function #Z3_solver_get_model can also be used even
  /// if the result is \c Z3_L_UNDEF, but the returned model
  /// is not guaranteed to satisfy quantified assertions.
  ///
  /// \remark User must use #Z3_solver_inc_ref and #Z3_solver_dec_ref to manage solver objects.
  /// Even if the context was created using #Z3_mk_context instead of #Z3_mk_context_rc.
  ///
  /// \sa Z3_mk_simple_solver
  /// \sa Z3_mk_solver_for_logic
  /// \sa Z3_mk_solver_from_tactic
  ///
  /// def_API('Z3_mk_solver', SOLVER, (_in(CONTEXT),))
  Z3_solver mk_solver(
    Z3_context c,
  ) {
    return _mk_solver(
      c,
    );
  }

  late final _mk_solverPtr =
      _lookup<ffi.NativeFunction<Z3_solver Function(Z3_context)>>(
          'Z3_mk_solver');
  late final _mk_solver =
      _mk_solverPtr.asFunction<Z3_solver Function(Z3_context)>();

  /// \brief Create a new incremental solver.
  ///
  /// This is equivalent to applying the "smt" tactic.
  ///
  /// Unlike #Z3_mk_solver() this solver
  /// - Does not attempt to apply any logic specific tactics.
  /// - Does not change its behaviour based on whether it used
  /// incrementally/non-incrementally.
  ///
  /// Note that these differences can result in very different performance
  /// compared to #Z3_mk_solver().
  ///
  /// The function #Z3_solver_get_model retrieves a model if the
  /// assertions is satisfiable (i.e., the result is \c
  /// Z3_L_TRUE) and model construction is enabled.
  /// The function #Z3_solver_get_model can also be used even
  /// if the result is \c Z3_L_UNDEF, but the returned model
  /// is not guaranteed to satisfy quantified assertions.
  ///
  /// \remark User must use #Z3_solver_inc_ref and #Z3_solver_dec_ref to manage solver objects.
  /// Even if the context was created using #Z3_mk_context instead of #Z3_mk_context_rc.
  ///
  /// \sa Z3_mk_solver
  /// \sa Z3_mk_solver_for_logic
  /// \sa Z3_mk_solver_from_tactic
  ///
  /// def_API('Z3_mk_simple_solver', SOLVER, (_in(CONTEXT),))
  Z3_solver mk_simple_solver(
    Z3_context c,
  ) {
    return _mk_simple_solver(
      c,
    );
  }

  late final _mk_simple_solverPtr =
      _lookup<ffi.NativeFunction<Z3_solver Function(Z3_context)>>(
          'Z3_mk_simple_solver');
  late final _mk_simple_solver =
      _mk_simple_solverPtr.asFunction<Z3_solver Function(Z3_context)>();

  /// \brief Create a new solver customized for the given logic.
  /// It behaves like #Z3_mk_solver if the logic is unknown or unsupported.
  ///
  /// \remark User must use #Z3_solver_inc_ref and #Z3_solver_dec_ref to manage solver objects.
  /// Even if the context was created using #Z3_mk_context instead of #Z3_mk_context_rc.
  ///
  /// \sa Z3_mk_solver
  /// \sa Z3_mk_simple_solver
  /// \sa Z3_mk_solver_from_tactic
  ///
  /// def_API('Z3_mk_solver_for_logic', SOLVER, (_in(CONTEXT), _in(SYMBOL)))
  Z3_solver mk_solver_for_logic(
    Z3_context c,
    Z3_symbol logic,
  ) {
    return _mk_solver_for_logic(
      c,
      logic,
    );
  }

  late final _mk_solver_for_logicPtr =
      _lookup<ffi.NativeFunction<Z3_solver Function(Z3_context, Z3_symbol)>>(
          'Z3_mk_solver_for_logic');
  late final _mk_solver_for_logic = _mk_solver_for_logicPtr
      .asFunction<Z3_solver Function(Z3_context, Z3_symbol)>();

  /// \brief Create a new solver that is implemented using the given tactic.
  /// The solver supports the commands #Z3_solver_push and #Z3_solver_pop, but it
  /// will always solve each #Z3_solver_check from scratch.
  ///
  /// \remark User must use #Z3_solver_inc_ref and #Z3_solver_dec_ref to manage solver objects.
  /// Even if the context was created using #Z3_mk_context instead of #Z3_mk_context_rc.
  ///
  /// \sa Z3_mk_solver
  /// \sa Z3_mk_simple_solver
  /// \sa Z3_mk_solver_for_logic
  ///
  /// def_API('Z3_mk_solver_from_tactic', SOLVER, (_in(CONTEXT), _in(TACTIC)))
  Z3_solver mk_solver_from_tactic(
    Z3_context c,
    Z3_tactic t,
  ) {
    return _mk_solver_from_tactic(
      c,
      t,
    );
  }

  late final _mk_solver_from_tacticPtr =
      _lookup<ffi.NativeFunction<Z3_solver Function(Z3_context, Z3_tactic)>>(
          'Z3_mk_solver_from_tactic');
  late final _mk_solver_from_tactic = _mk_solver_from_tacticPtr
      .asFunction<Z3_solver Function(Z3_context, Z3_tactic)>();

  /// \brief Copy a solver \c s from the context \c source to the context \c target.
  ///
  /// def_API('Z3_solver_translate', SOLVER, (_in(CONTEXT), _in(SOLVER), _in(CONTEXT)))
  Z3_solver solver_translate(
    Z3_context source,
    Z3_solver s,
    Z3_context target,
  ) {
    return _solver_translate(
      source,
      s,
      target,
    );
  }

  late final _solver_translatePtr = _lookup<
      ffi.NativeFunction<
          Z3_solver Function(
              Z3_context, Z3_solver, Z3_context)>>('Z3_solver_translate');
  late final _solver_translate = _solver_translatePtr
      .asFunction<Z3_solver Function(Z3_context, Z3_solver, Z3_context)>();

  /// \brief Ad-hoc method for importing model conversion from solver.
  ///
  /// This method is used for scenarios where \c src has been used to solve a set
  /// of formulas and was interrupted. The \c dst solver may be a strengthening of \c src
  /// obtained from cubing (assigning a subset of literals or adding constraints over the
  /// assertions available in \c src). If \c dst ends up being satisfiable, the model for \c dst
  /// may not correspond to a model of the original formula due to inprocessing in \c src.
  /// This method is used to take the side-effect of inprocessing into account when returning
  /// a model for \c dst.
  ///
  /// def_API('Z3_solver_import_model_converter', VOID, (_in(CONTEXT), _in(SOLVER), _in(SOLVER)))
  void solver_import_model_converter(
    Z3_context ctx,
    Z3_solver src,
    Z3_solver dst,
  ) {
    return _solver_import_model_converter(
      ctx,
      src,
      dst,
    );
  }

  late final _solver_import_model_converterPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(Z3_context, Z3_solver, Z3_solver)>>(
      'Z3_solver_import_model_converter');
  late final _solver_import_model_converter = _solver_import_model_converterPtr
      .asFunction<void Function(Z3_context, Z3_solver, Z3_solver)>();

  /// \brief Return a string describing all solver available parameters.
  ///
  /// \sa Z3_solver_get_param_descrs
  /// \sa Z3_solver_set_params
  ///
  /// def_API('Z3_solver_get_help', STRING, (_in(CONTEXT), _in(SOLVER)))
  Z3_string solver_get_help(
    Z3_context c,
    Z3_solver s,
  ) {
    return _solver_get_help(
      c,
      s,
    );
  }

  late final _solver_get_helpPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_solver)>>(
          'Z3_solver_get_help');
  late final _solver_get_help = _solver_get_helpPtr
      .asFunction<Z3_string Function(Z3_context, Z3_solver)>();

  /// \brief Return the parameter description set for the given solver object.
  ///
  /// \sa Z3_solver_get_help
  /// \sa Z3_solver_set_params
  ///
  /// def_API('Z3_solver_get_param_descrs', PARAM_DESCRS, (_in(CONTEXT), _in(SOLVER)))
  Z3_param_descrs solver_get_param_descrs(
    Z3_context c,
    Z3_solver s,
  ) {
    return _solver_get_param_descrs(
      c,
      s,
    );
  }

  late final _solver_get_param_descrsPtr = _lookup<
          ffi.NativeFunction<Z3_param_descrs Function(Z3_context, Z3_solver)>>(
      'Z3_solver_get_param_descrs');
  late final _solver_get_param_descrs = _solver_get_param_descrsPtr
      .asFunction<Z3_param_descrs Function(Z3_context, Z3_solver)>();

  /// \brief Set the given solver using the given parameters.
  ///
  /// \sa Z3_solver_get_help
  /// \sa Z3_solver_get_param_descrs
  ///
  /// def_API('Z3_solver_set_params', VOID, (_in(CONTEXT), _in(SOLVER), _in(PARAMS)))
  void solver_set_params(
    Z3_context c,
    Z3_solver s,
    Z3_params p,
  ) {
    return _solver_set_params(
      c,
      s,
      p,
    );
  }

  late final _solver_set_paramsPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(Z3_context, Z3_solver, Z3_params)>>(
      'Z3_solver_set_params');
  late final _solver_set_params = _solver_set_paramsPtr
      .asFunction<void Function(Z3_context, Z3_solver, Z3_params)>();

  /// \brief Increment the reference counter of the given solver.
  ///
  /// def_API('Z3_solver_inc_ref', VOID, (_in(CONTEXT), _in(SOLVER)))
  void solver_inc_ref(
    Z3_context c,
    Z3_solver s,
  ) {
    return _solver_inc_ref(
      c,
      s,
    );
  }

  late final _solver_inc_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_solver)>>(
          'Z3_solver_inc_ref');
  late final _solver_inc_ref =
      _solver_inc_refPtr.asFunction<void Function(Z3_context, Z3_solver)>();

  /// \brief Decrement the reference counter of the given solver.
  ///
  /// def_API('Z3_solver_dec_ref', VOID, (_in(CONTEXT), _in(SOLVER)))
  void solver_dec_ref(
    Z3_context c,
    Z3_solver s,
  ) {
    return _solver_dec_ref(
      c,
      s,
    );
  }

  late final _solver_dec_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_solver)>>(
          'Z3_solver_dec_ref');
  late final _solver_dec_ref =
      _solver_dec_refPtr.asFunction<void Function(Z3_context, Z3_solver)>();

  /// \brief Solver local interrupt.
  /// Normally you should use Z3_interrupt to cancel solvers because only
  /// one solver is enabled concurrently per context.
  /// However, per GitHub issue #1006, there are use cases where
  /// it is more convenient to cancel a specific solver. Solvers
  /// that are not selected for interrupts are left alone.
  ///
  /// def_API('Z3_solver_interrupt', VOID, (_in(CONTEXT), _in(SOLVER)))
  void solver_interrupt(
    Z3_context c,
    Z3_solver s,
  ) {
    return _solver_interrupt(
      c,
      s,
    );
  }

  late final _solver_interruptPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_solver)>>(
          'Z3_solver_interrupt');
  late final _solver_interrupt =
      _solver_interruptPtr.asFunction<void Function(Z3_context, Z3_solver)>();

  /// \brief Create a backtracking point.
  ///
  /// The solver contains a stack of assertions.
  ///
  /// \sa Z3_solver_get_num_scopes
  /// \sa Z3_solver_pop
  ///
  /// def_API('Z3_solver_push', VOID, (_in(CONTEXT), _in(SOLVER)))
  void solver_push(
    Z3_context c,
    Z3_solver s,
  ) {
    return _solver_push(
      c,
      s,
    );
  }

  late final _solver_pushPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_solver)>>(
          'Z3_solver_push');
  late final _solver_push =
      _solver_pushPtr.asFunction<void Function(Z3_context, Z3_solver)>();

  /// \brief Backtrack \c n backtracking points.
  ///
  /// \sa Z3_solver_get_num_scopes
  /// \sa Z3_solver_push
  ///
  /// \pre n <= Z3_solver_get_num_scopes(c, s)
  ///
  /// def_API('Z3_solver_pop', VOID, (_in(CONTEXT), _in(SOLVER), _in(UINT)))
  void solver_pop(
    Z3_context c,
    Z3_solver s,
    int n,
  ) {
    return _solver_pop(
      c,
      s,
      n,
    );
  }

  late final _solver_popPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context, Z3_solver, ffi.UnsignedInt)>>('Z3_solver_pop');
  late final _solver_pop =
      _solver_popPtr.asFunction<void Function(Z3_context, Z3_solver, int)>();

  /// \brief Remove all assertions from the solver.
  ///
  /// \sa Z3_solver_assert
  /// \sa Z3_solver_assert_and_track
  ///
  /// def_API('Z3_solver_reset', VOID, (_in(CONTEXT), _in(SOLVER)))
  void solver_reset(
    Z3_context c,
    Z3_solver s,
  ) {
    return _solver_reset(
      c,
      s,
    );
  }

  late final _solver_resetPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_solver)>>(
          'Z3_solver_reset');
  late final _solver_reset =
      _solver_resetPtr.asFunction<void Function(Z3_context, Z3_solver)>();

  /// \brief Return the number of backtracking points.
  ///
  /// \sa Z3_solver_push
  /// \sa Z3_solver_pop
  ///
  /// def_API('Z3_solver_get_num_scopes', UINT, (_in(CONTEXT), _in(SOLVER)))
  int solver_get_num_scopes(
    Z3_context c,
    Z3_solver s,
  ) {
    return _solver_get_num_scopes(
      c,
      s,
    );
  }

  late final _solver_get_num_scopesPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_solver)>>(
      'Z3_solver_get_num_scopes');
  late final _solver_get_num_scopes = _solver_get_num_scopesPtr
      .asFunction<int Function(Z3_context, Z3_solver)>();

  /// \brief Assert a constraint into the solver.
  ///
  /// The functions #Z3_solver_check and #Z3_solver_check_assumptions should be
  /// used to check whether the logical context is consistent or not.
  ///
  /// \sa Z3_solver_assert_and_track
  /// \sa Z3_solver_reset
  ///
  /// def_API('Z3_solver_assert', VOID, (_in(CONTEXT), _in(SOLVER), _in(AST)))
  void solver_assert(
    Z3_context c,
    Z3_solver s,
    Z3_ast a,
  ) {
    return _solver_assert(
      c,
      s,
      a,
    );
  }

  late final _solver_assertPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_solver, Z3_ast)>>(
      'Z3_solver_assert');
  late final _solver_assert = _solver_assertPtr
      .asFunction<void Function(Z3_context, Z3_solver, Z3_ast)>();

  /// \brief Assert a constraint \c a into the solver, and track it (in the unsat) core using
  /// the Boolean constant \c p.
  ///
  /// This API is an alternative to #Z3_solver_check_assumptions for extracting unsat cores.
  /// Both APIs can be used in the same solver. The unsat core will contain a combination
  /// of the Boolean variables provided using Z3_solver_assert_and_track and the Boolean literals
  /// provided using #Z3_solver_check_assumptions.
  ///
  /// \pre \c a must be a Boolean expression
  /// \pre \c p must be a Boolean constant (aka variable).
  ///
  /// \sa Z3_solver_assert
  /// \sa Z3_solver_reset
  ///
  /// def_API('Z3_solver_assert_and_track', VOID, (_in(CONTEXT), _in(SOLVER), _in(AST), _in(AST)))
  void solver_assert_and_track(
    Z3_context c,
    Z3_solver s,
    Z3_ast a,
    Z3_ast p,
  ) {
    return _solver_assert_and_track(
      c,
      s,
      a,
      p,
    );
  }

  late final _solver_assert_and_trackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_solver, Z3_ast,
              Z3_ast)>>('Z3_solver_assert_and_track');
  late final _solver_assert_and_track = _solver_assert_and_trackPtr
      .asFunction<void Function(Z3_context, Z3_solver, Z3_ast, Z3_ast)>();

  /// \brief load solver assertions from a file.
  ///
  /// \sa Z3_solver_from_string
  /// \sa Z3_solver_to_string
  ///
  /// def_API('Z3_solver_from_file', VOID, (_in(CONTEXT), _in(SOLVER), _in(STRING)))
  void solver_from_file(
    Z3_context c,
    Z3_solver s,
    Z3_string file_name,
  ) {
    return _solver_from_file(
      c,
      s,
      file_name,
    );
  }

  late final _solver_from_filePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(Z3_context, Z3_solver, Z3_string)>>(
      'Z3_solver_from_file');
  late final _solver_from_file = _solver_from_filePtr
      .asFunction<void Function(Z3_context, Z3_solver, Z3_string)>();

  /// \brief load solver assertions from a string.
  ///
  /// \sa Z3_solver_from_file
  /// \sa Z3_solver_to_string
  ///
  /// def_API('Z3_solver_from_string', VOID, (_in(CONTEXT), _in(SOLVER), _in(STRING)))
  void solver_from_string(
    Z3_context c,
    Z3_solver s,
    Z3_string file_name,
  ) {
    return _solver_from_string(
      c,
      s,
      file_name,
    );
  }

  late final _solver_from_stringPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(Z3_context, Z3_solver, Z3_string)>>(
      'Z3_solver_from_string');
  late final _solver_from_string = _solver_from_stringPtr
      .asFunction<void Function(Z3_context, Z3_solver, Z3_string)>();

  /// \brief Return the set of asserted formulas on the solver.
  ///
  /// def_API('Z3_solver_get_assertions', AST_VECTOR, (_in(CONTEXT), _in(SOLVER)))
  Z3_ast_vector solver_get_assertions(
    Z3_context c,
    Z3_solver s,
  ) {
    return _solver_get_assertions(
      c,
      s,
    );
  }

  late final _solver_get_assertionsPtr = _lookup<
          ffi.NativeFunction<Z3_ast_vector Function(Z3_context, Z3_solver)>>(
      'Z3_solver_get_assertions');
  late final _solver_get_assertions = _solver_get_assertionsPtr
      .asFunction<Z3_ast_vector Function(Z3_context, Z3_solver)>();

  /// \brief Return the set of units modulo model conversion.
  ///
  /// def_API('Z3_solver_get_units', AST_VECTOR, (_in(CONTEXT), _in(SOLVER)))
  Z3_ast_vector solver_get_units(
    Z3_context c,
    Z3_solver s,
  ) {
    return _solver_get_units(
      c,
      s,
    );
  }

  late final _solver_get_unitsPtr = _lookup<
          ffi.NativeFunction<Z3_ast_vector Function(Z3_context, Z3_solver)>>(
      'Z3_solver_get_units');
  late final _solver_get_units = _solver_get_unitsPtr
      .asFunction<Z3_ast_vector Function(Z3_context, Z3_solver)>();

  /// \brief Return the trail modulo model conversion, in order of decision level
  /// The decision level can be retrieved using \c Z3_solver_get_level based on the trail.
  ///
  /// def_API('Z3_solver_get_trail', AST_VECTOR, (_in(CONTEXT), _in(SOLVER)))
  Z3_ast_vector solver_get_trail(
    Z3_context c,
    Z3_solver s,
  ) {
    return _solver_get_trail(
      c,
      s,
    );
  }

  late final _solver_get_trailPtr = _lookup<
          ffi.NativeFunction<Z3_ast_vector Function(Z3_context, Z3_solver)>>(
      'Z3_solver_get_trail');
  late final _solver_get_trail = _solver_get_trailPtr
      .asFunction<Z3_ast_vector Function(Z3_context, Z3_solver)>();

  /// \brief Return the set of non units in the solver state.
  ///
  /// def_API('Z3_solver_get_non_units', AST_VECTOR, (_in(CONTEXT), _in(SOLVER)))
  Z3_ast_vector solver_get_non_units(
    Z3_context c,
    Z3_solver s,
  ) {
    return _solver_get_non_units(
      c,
      s,
    );
  }

  late final _solver_get_non_unitsPtr = _lookup<
          ffi.NativeFunction<Z3_ast_vector Function(Z3_context, Z3_solver)>>(
      'Z3_solver_get_non_units');
  late final _solver_get_non_units = _solver_get_non_unitsPtr
      .asFunction<Z3_ast_vector Function(Z3_context, Z3_solver)>();

  /// \brief retrieve the decision depth of Boolean literals (variables or their negations).
  /// Assumes a check-sat call and no other calls (to extract models) have been invoked.
  ///
  /// def_API('Z3_solver_get_levels', VOID, (_in(CONTEXT), _in(SOLVER), _in(AST_VECTOR), _in(UINT), _in_array(3, UINT)))
  void solver_get_levels(
    Z3_context c,
    Z3_solver s,
    Z3_ast_vector literals,
    int sz,
    ffi.Pointer<ffi.UnsignedInt> levels,
  ) {
    return _solver_get_levels(
      c,
      s,
      literals,
      sz,
      levels,
    );
  }

  late final _solver_get_levelsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context,
              Z3_solver,
              Z3_ast_vector,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.UnsignedInt>)>>('Z3_solver_get_levels');
  late final _solver_get_levels = _solver_get_levelsPtr.asFunction<
      void Function(Z3_context, Z3_solver, Z3_ast_vector, int,
          ffi.Pointer<ffi.UnsignedInt>)>();

  /// \brief retrieve the congruence closure root of an expression.
  /// The root is retrieved relative to the state where the solver was in when it completed.
  /// If it completed during a set of case splits, the congruence roots are relative to these case splits.
  /// That is, the congruences are not consequences but they are true under the current state.
  ///
  /// def_API('Z3_solver_congruence_root', AST, (_in(CONTEXT), _in(SOLVER), _in(AST)))
  Z3_ast solver_congruence_root(
    Z3_context c,
    Z3_solver s,
    Z3_ast a,
  ) {
    return _solver_congruence_root(
      c,
      s,
      a,
    );
  }

  late final _solver_congruence_rootPtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_solver, Z3_ast)>>(
      'Z3_solver_congruence_root');
  late final _solver_congruence_root = _solver_congruence_rootPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_solver, Z3_ast)>();

  /// \brief retrieve the next expression in the congruence class. The set of congruent siblings form a cyclic list.
  /// Repeated calls on the siblings will result in returning to the original expression.
  ///
  /// def_API('Z3_solver_congruence_next', AST, (_in(CONTEXT), _in(SOLVER), _in(AST)))
  Z3_ast solver_congruence_next(
    Z3_context c,
    Z3_solver s,
    Z3_ast a,
  ) {
    return _solver_congruence_next(
      c,
      s,
      a,
    );
  }

  late final _solver_congruence_nextPtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_solver, Z3_ast)>>(
      'Z3_solver_congruence_next');
  late final _solver_congruence_next = _solver_congruence_nextPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_solver, Z3_ast)>();

  /// \brief register a callback to that retrieves assumed, inferred and deleted clauses during search.
  ///
  /// \param c - context.
  /// \param s - solver object.
  /// \param user_context - a context used to maintain state for callbacks.
  /// \param on_clause_eh - a callback that is invoked by when a clause is
  /// - asserted to the CDCL engine (corresponding to an input clause after pre-processing)
  /// - inferred by CDCL(T) using either a SAT or theory conflict/propagation
  /// - deleted by the CDCL(T) engine
  ///
  /// def_API('Z3_solver_register_on_clause', VOID, (_in(CONTEXT), _in(SOLVER), _in(VOID_PTR), _fnptr(Z3_on_clause_eh)))
  void solver_register_on_clause(
    Z3_context c,
    Z3_solver s,
    ffi.Pointer<ffi.Void> user_context,
    ffi.Pointer<Z3_on_clause_eh> on_clause_eh,
  ) {
    return _solver_register_on_clause(
      c,
      s,
      user_context,
      on_clause_eh,
    );
  }

  late final _solver_register_on_clausePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_solver, ffi.Pointer<ffi.Void>,
              ffi.Pointer<Z3_on_clause_eh>)>>('Z3_solver_register_on_clause');
  late final _solver_register_on_clause =
      _solver_register_on_clausePtr.asFunction<
          void Function(Z3_context, Z3_solver, ffi.Pointer<ffi.Void>,
              ffi.Pointer<Z3_on_clause_eh>)>();

  /// \brief register a user-propagator with the solver.
  ///
  /// \param c - context.
  /// \param s - solver object.
  /// \param user_context - a context used to maintain state for callbacks.
  /// \param push_eh - a callback invoked when scopes are pushed
  /// \param pop_eh - a callback invoked when scopes are popped
  /// \param fresh_eh - a solver may spawn new solvers internally. This callback is used to produce a fresh user_context to be associated with fresh solvers.
  ///
  /// def_API('Z3_solver_propagate_init', VOID, (_in(CONTEXT), _in(SOLVER), _in(VOID_PTR), _fnptr(Z3_push_eh), _fnptr(Z3_pop_eh), _fnptr(Z3_fresh_eh)))
  void solver_propagate_init(
    Z3_context c,
    Z3_solver s,
    ffi.Pointer<ffi.Void> user_context,
    ffi.Pointer<Z3_push_eh> push_eh,
    ffi.Pointer<Z3_pop_eh> pop_eh,
    ffi.Pointer<Z3_fresh_eh> fresh_eh,
  ) {
    return _solver_propagate_init(
      c,
      s,
      user_context,
      push_eh,
      pop_eh,
      fresh_eh,
    );
  }

  late final _solver_propagate_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context,
              Z3_solver,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<Z3_push_eh>,
              ffi.Pointer<Z3_pop_eh>,
              ffi.Pointer<Z3_fresh_eh>)>>('Z3_solver_propagate_init');
  late final _solver_propagate_init = _solver_propagate_initPtr.asFunction<
      void Function(
          Z3_context,
          Z3_solver,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<Z3_push_eh>,
          ffi.Pointer<Z3_pop_eh>,
          ffi.Pointer<Z3_fresh_eh>)>();

  /// \brief register a callback for when an expression is bound to a fixed value.
  /// The supported expression types are
  /// - Booleans
  /// - Bit-vectors
  ///
  /// def_API('Z3_solver_propagate_fixed', VOID, (_in(CONTEXT), _in(SOLVER), _fnptr(Z3_fixed_eh)))
  void solver_propagate_fixed(
    Z3_context c,
    Z3_solver s,
    ffi.Pointer<Z3_fixed_eh> fixed_eh,
  ) {
    return _solver_propagate_fixed(
      c,
      s,
      fixed_eh,
    );
  }

  late final _solver_propagate_fixedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_solver,
              ffi.Pointer<Z3_fixed_eh>)>>('Z3_solver_propagate_fixed');
  late final _solver_propagate_fixed = _solver_propagate_fixedPtr.asFunction<
      void Function(Z3_context, Z3_solver, ffi.Pointer<Z3_fixed_eh>)>();

  /// \brief register a callback on final check.
  /// This provides freedom to the propagator to delay actions or implement a branch-and bound solver.
  /// The final check is invoked when all decision variables have been assigned by the solver.
  ///
  /// The \c final_eh callback takes as argument the original user_context that was used
  /// when calling \c Z3_solver_propagate_init, and it takes a callback context with the
  /// opaque type \c Z3_solver_callback.
  /// The callback context is passed as argument to invoke the \c Z3_solver_propagate_consequence function.
  /// The callback context can only be accessed (for propagation and for dynamically registering expressions) within a callback.
  /// If the callback context gets used for propagation or conflicts, those propagations take effect and
  /// may trigger new decision variables to be set.
  ///
  /// def_API('Z3_solver_propagate_final', VOID, (_in(CONTEXT), _in(SOLVER), _fnptr(Z3_final_eh)))
  void solver_propagate_final(
    Z3_context c,
    Z3_solver s,
    ffi.Pointer<Z3_final_eh> final_eh,
  ) {
    return _solver_propagate_final(
      c,
      s,
      final_eh,
    );
  }

  late final _solver_propagate_finalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_solver,
              ffi.Pointer<Z3_final_eh>)>>('Z3_solver_propagate_final');
  late final _solver_propagate_final = _solver_propagate_finalPtr.asFunction<
      void Function(Z3_context, Z3_solver, ffi.Pointer<Z3_final_eh>)>();

  /// \brief register a callback on expression equalities.
  ///
  /// def_API('Z3_solver_propagate_eq', VOID, (_in(CONTEXT), _in(SOLVER), _fnptr(Z3_eq_eh)))
  void solver_propagate_eq(
    Z3_context c,
    Z3_solver s,
    ffi.Pointer<Z3_eq_eh> eq_eh,
  ) {
    return _solver_propagate_eq(
      c,
      s,
      eq_eh,
    );
  }

  late final _solver_propagate_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_solver,
              ffi.Pointer<Z3_eq_eh>)>>('Z3_solver_propagate_eq');
  late final _solver_propagate_eq = _solver_propagate_eqPtr.asFunction<
      void Function(Z3_context, Z3_solver, ffi.Pointer<Z3_eq_eh>)>();

  /// \brief register a callback on expression dis-equalities.
  ///
  /// def_API('Z3_solver_propagate_diseq', VOID, (_in(CONTEXT), _in(SOLVER), _fnptr(Z3_eq_eh)))
  void solver_propagate_diseq(
    Z3_context c,
    Z3_solver s,
    ffi.Pointer<Z3_eq_eh> eq_eh,
  ) {
    return _solver_propagate_diseq(
      c,
      s,
      eq_eh,
    );
  }

  late final _solver_propagate_diseqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_solver,
              ffi.Pointer<Z3_eq_eh>)>>('Z3_solver_propagate_diseq');
  late final _solver_propagate_diseq = _solver_propagate_diseqPtr.asFunction<
      void Function(Z3_context, Z3_solver, ffi.Pointer<Z3_eq_eh>)>();

  /// \brief register a callback when a new expression with a registered function is used by the solver
  /// The registered function appears at the top level and is created using \ref Z3_solver_propagate_declare.
  ///
  /// def_API('Z3_solver_propagate_created', VOID, (_in(CONTEXT), _in(SOLVER), _fnptr(Z3_created_eh)))
  void solver_propagate_created(
    Z3_context c,
    Z3_solver s,
    ffi.Pointer<Z3_created_eh> created_eh,
  ) {
    return _solver_propagate_created(
      c,
      s,
      created_eh,
    );
  }

  late final _solver_propagate_createdPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_solver,
              ffi.Pointer<Z3_created_eh>)>>('Z3_solver_propagate_created');
  late final _solver_propagate_created =
      _solver_propagate_createdPtr.asFunction<
          void Function(Z3_context, Z3_solver, ffi.Pointer<Z3_created_eh>)>();

  /// \brief register a callback when the solver decides to split on a registered expression.
  /// The callback may change the arguments by providing other values by calling \ref Z3_solver_next_split
  ///
  /// def_API('Z3_solver_propagate_decide', VOID, (_in(CONTEXT), _in(SOLVER), _fnptr(Z3_decide_eh)))
  void solver_propagate_decide(
    Z3_context c,
    Z3_solver s,
    ffi.Pointer<Z3_decide_eh> decide_eh,
  ) {
    return _solver_propagate_decide(
      c,
      s,
      decide_eh,
    );
  }

  late final _solver_propagate_decidePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_solver,
              ffi.Pointer<Z3_decide_eh>)>>('Z3_solver_propagate_decide');
  late final _solver_propagate_decide = _solver_propagate_decidePtr.asFunction<
      void Function(Z3_context, Z3_solver, ffi.Pointer<Z3_decide_eh>)>();

  /// Sets the next (registered) expression to split on.
  /// The function returns false and ignores the given expression in case the expression is already assigned internally
  /// (due to relevancy propagation, this assignments might not have been reported yet by the fixed callback).
  /// In case the function is called in the decide callback, it overrides the currently selected variable and phase.
  ///
  /// def_API('Z3_solver_next_split', BOOL, (_in(CONTEXT), _in(SOLVER_CALLBACK), _in(AST), _in(UINT), _in(LBOOL)))
  bool solver_next_split(
    Z3_context c,
    Z3_solver_callback cb,
    Z3_ast t,
    int idx,
    int phase,
  ) {
    return _solver_next_split(
      c,
      cb,
      t,
      idx,
      phase,
    );
  }

  late final _solver_next_splitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(Z3_context, Z3_solver_callback, Z3_ast,
              ffi.UnsignedInt, ffi.Int32)>>('Z3_solver_next_split');
  late final _solver_next_split = _solver_next_splitPtr.asFunction<
      bool Function(Z3_context, Z3_solver_callback, Z3_ast, int, int)>();

  /// Create uninterpreted function declaration for the user propagator.
  /// When expressions using the function are created by the solver invoke a callback
  /// to \ref Z3_solver_propagate_created with arguments
  /// 1. context and callback solve
  /// 2. declared_expr: expression using function that was used as the top-level symbol
  /// 3. declared_id: a unique identifier (unique within the current scope) to track the expression.
  ///
  /// def_API('Z3_solver_propagate_declare', FUNC_DECL, (_in(CONTEXT), _in(SYMBOL), _in(UINT), _in_array(2, SORT), _in(SORT)))
  Z3_func_decl solver_propagate_declare(
    Z3_context c,
    Z3_symbol name,
    int n,
    ffi.Pointer<Z3_sort> domain,
    Z3_sort range,
  ) {
    return _solver_propagate_declare(
      c,
      name,
      n,
      domain,
      range,
    );
  }

  late final _solver_propagate_declarePtr = _lookup<
      ffi.NativeFunction<
          Z3_func_decl Function(Z3_context, Z3_symbol, ffi.UnsignedInt,
              ffi.Pointer<Z3_sort>, Z3_sort)>>('Z3_solver_propagate_declare');
  late final _solver_propagate_declare =
      _solver_propagate_declarePtr.asFunction<
          Z3_func_decl Function(
              Z3_context, Z3_symbol, int, ffi.Pointer<Z3_sort>, Z3_sort)>();

  /// \brief register an expression to propagate on with the solver.
  /// Only expressions of type Bool and type Bit-Vector can be registered for propagation.
  ///
  /// def_API('Z3_solver_propagate_register', VOID, (_in(CONTEXT), _in(SOLVER), _in(AST)))
  void solver_propagate_register(
    Z3_context c,
    Z3_solver s,
    Z3_ast e,
  ) {
    return _solver_propagate_register(
      c,
      s,
      e,
    );
  }

  late final _solver_propagate_registerPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_solver, Z3_ast)>>(
      'Z3_solver_propagate_register');
  late final _solver_propagate_register = _solver_propagate_registerPtr
      .asFunction<void Function(Z3_context, Z3_solver, Z3_ast)>();

  /// \brief register an expression to propagate on with the solver.
  /// Only expressions of type Bool and type Bit-Vector can be registered for propagation.
  /// Unlike \ref Z3_solver_propagate_register, this function takes a solver callback context
  /// as argument. It can be invoked during a callback to register new expressions.
  ///
  /// def_API('Z3_solver_propagate_register_cb', VOID, (_in(CONTEXT), _in(SOLVER_CALLBACK), _in(AST)))
  void solver_propagate_register_cb(
    Z3_context c,
    Z3_solver_callback cb,
    Z3_ast e,
  ) {
    return _solver_propagate_register_cb(
      c,
      cb,
      e,
    );
  }

  late final _solver_propagate_register_cbPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_solver_callback,
              Z3_ast)>>('Z3_solver_propagate_register_cb');
  late final _solver_propagate_register_cb = _solver_propagate_register_cbPtr
      .asFunction<void Function(Z3_context, Z3_solver_callback, Z3_ast)>();

  /// \brief propagate a consequence based on fixed values.
  /// This is a callback a client may invoke during the fixed_eh callback.
  /// The callback adds a propagation consequence based on the fixed values of the
  /// \c ids.
  /// The solver might discard the propagation in case it is true in the current state.
  /// The function returns false in this case; otw. the function returns true.
  /// At least one propagation in the final callback has to return true in order to
  /// prevent the solver from finishing.
  ///
  /// def_API('Z3_solver_propagate_consequence', BOOL, (_in(CONTEXT), _in(SOLVER_CALLBACK), _in(UINT), _in_array(2, AST), _in(UINT), _in_array(4, AST), _in_array(4, AST), _in(AST)))
  bool solver_propagate_consequence(
    Z3_context c,
    Z3_solver_callback cb,
    int num_fixed,
    ffi.Pointer<Z3_ast> fixed,
    int num_eqs,
    ffi.Pointer<Z3_ast> eq_lhs,
    ffi.Pointer<Z3_ast> eq_rhs,
    Z3_ast conseq,
  ) {
    return _solver_propagate_consequence(
      c,
      cb,
      num_fixed,
      fixed,
      num_eqs,
      eq_lhs,
      eq_rhs,
      conseq,
    );
  }

  late final _solver_propagate_consequencePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              Z3_context,
              Z3_solver_callback,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>,
              ffi.Pointer<Z3_ast>,
              Z3_ast)>>('Z3_solver_propagate_consequence');
  late final _solver_propagate_consequence =
      _solver_propagate_consequencePtr.asFunction<
          bool Function(
              Z3_context,
              Z3_solver_callback,
              int,
              ffi.Pointer<Z3_ast>,
              int,
              ffi.Pointer<Z3_ast>,
              ffi.Pointer<Z3_ast>,
              Z3_ast)>();

  /// \brief Check whether the assertions in a given solver are consistent or not.
  ///
  /// The function #Z3_solver_get_model retrieves a model if the
  /// assertions is satisfiable (i.e., the result is \c
  /// Z3_L_TRUE) and model construction is enabled.
  /// Note that if the call returns \c Z3_L_UNDEF, Z3 does not
  /// ensure that calls to #Z3_solver_get_model succeed and any models
  /// produced in this case are not guaranteed to satisfy the assertions.
  ///
  /// The function #Z3_solver_get_proof retrieves a proof if proof
  /// generation was enabled when the context was created, and the
  /// assertions are unsatisfiable (i.e., the result is \c Z3_L_FALSE).
  ///
  /// \sa Z3_solver_check_assumptions
  ///
  /// def_API('Z3_solver_check', LBOOL, (_in(CONTEXT), _in(SOLVER)))
  int solver_check(
    Z3_context c,
    Z3_solver s,
  ) {
    return _solver_check(
      c,
      s,
    );
  }

  late final _solver_checkPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(Z3_context, Z3_solver)>>(
          'Z3_solver_check');
  late final _solver_check =
      _solver_checkPtr.asFunction<int Function(Z3_context, Z3_solver)>();

  /// \brief Check whether the assertions in the given solver and
  /// optional assumptions are consistent or not.
  ///
  /// The function #Z3_solver_get_unsat_core retrieves the subset of the
  /// assumptions used in the unsatisfiability proof produced by Z3.
  ///
  /// \sa Z3_solver_check
  ///
  /// def_API('Z3_solver_check_assumptions', LBOOL, (_in(CONTEXT), _in(SOLVER), _in(UINT), _in_array(2, AST)))
  int solver_check_assumptions(
    Z3_context c,
    Z3_solver s,
    int num_assumptions,
    ffi.Pointer<Z3_ast> assumptions,
  ) {
    return _solver_check_assumptions(
      c,
      s,
      num_assumptions,
      assumptions,
    );
  }

  late final _solver_check_assumptionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(Z3_context, Z3_solver, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_solver_check_assumptions');
  late final _solver_check_assumptions =
      _solver_check_assumptionsPtr.asFunction<
          int Function(Z3_context, Z3_solver, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Retrieve congruence class representatives for terms.
  ///
  /// The function can be used for relying on Z3 to identify equal terms under the current
  /// set of assumptions. The array of terms and array of class identifiers should have
  /// the same length. The class identifiers are numerals that are assigned to the same
  /// value for their corresponding terms if the current context forces the terms to be
  /// equal. You cannot deduce that terms corresponding to different numerals must be all different,
  /// (especially when using non-convex theories).
  /// All implied equalities are returned by this call.
  /// This means that two terms map to the same class identifier if and only if
  /// the current context implies that they are equal.
  ///
  /// A side-effect of the function is a satisfiability check on the assertions on the solver that is passed in.
  /// The function return \c Z3_L_FALSE if the current assertions are not satisfiable.
  ///
  /// def_API('Z3_get_implied_equalities', LBOOL, (_in(CONTEXT), _in(SOLVER), _in(UINT), _in_array(2, AST), _out_array(2, UINT)))
  int get_implied_equalities(
    Z3_context c,
    Z3_solver s,
    int num_terms,
    ffi.Pointer<Z3_ast> terms,
    ffi.Pointer<ffi.UnsignedInt> class_ids,
  ) {
    return _get_implied_equalities(
      c,
      s,
      num_terms,
      terms,
      class_ids,
    );
  }

  late final _get_implied_equalitiesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              Z3_context,
              Z3_solver,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>,
              ffi.Pointer<ffi.UnsignedInt>)>>('Z3_get_implied_equalities');
  late final _get_implied_equalities = _get_implied_equalitiesPtr.asFunction<
      int Function(Z3_context, Z3_solver, int, ffi.Pointer<Z3_ast>,
          ffi.Pointer<ffi.UnsignedInt>)>();

  /// \brief retrieve consequences from solver that determine values of the supplied function symbols.
  ///
  /// def_API('Z3_solver_get_consequences', LBOOL, (_in(CONTEXT), _in(SOLVER), _in(AST_VECTOR), _in(AST_VECTOR), _in(AST_VECTOR)))
  int solver_get_consequences(
    Z3_context c,
    Z3_solver s,
    Z3_ast_vector assumptions,
    Z3_ast_vector variables,
    Z3_ast_vector consequences,
  ) {
    return _solver_get_consequences(
      c,
      s,
      assumptions,
      variables,
      consequences,
    );
  }

  late final _solver_get_consequencesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(Z3_context, Z3_solver, Z3_ast_vector,
              Z3_ast_vector, Z3_ast_vector)>>('Z3_solver_get_consequences');
  late final _solver_get_consequences = _solver_get_consequencesPtr.asFunction<
      int Function(Z3_context, Z3_solver, Z3_ast_vector, Z3_ast_vector,
          Z3_ast_vector)>();

  /// \brief extract a next cube for a solver. The last cube is the constant \c true or \c false.
  /// The number of (non-constant) cubes is by default 1. For the sat solver cubing is controlled
  /// using parameters sat.lookahead.cube.cutoff and sat.lookahead.cube.fraction.
  ///
  /// The third argument is a vector of variables that may be used for cubing.
  /// The contents of the vector is only used in the first call. The initial list of variables
  /// is used in subsequent calls until it returns the unsatisfiable cube.
  /// The vector is modified to contain a set of Autarky variables that occur in clauses that
  /// are affected by the (last literal in the) cube. These variables could be used by a different
  /// cuber (on a different solver object) for further recursive cubing.
  ///
  /// The last argument is a backtracking level. It instructs the cube process to backtrack below
  /// the indicated level for the next cube.
  ///
  /// def_API('Z3_solver_cube', AST_VECTOR, (_in(CONTEXT), _in(SOLVER), _in(AST_VECTOR), _in(UINT)))
  Z3_ast_vector solver_cube(
    Z3_context c,
    Z3_solver s,
    Z3_ast_vector vars,
    int backtrack_level,
  ) {
    return _solver_cube(
      c,
      s,
      vars,
      backtrack_level,
    );
  }

  late final _solver_cubePtr = _lookup<
      ffi.NativeFunction<
          Z3_ast_vector Function(Z3_context, Z3_solver, Z3_ast_vector,
              ffi.UnsignedInt)>>('Z3_solver_cube');
  late final _solver_cube = _solver_cubePtr.asFunction<
      Z3_ast_vector Function(Z3_context, Z3_solver, Z3_ast_vector, int)>();

  /// \brief Retrieve the model for the last #Z3_solver_check or #Z3_solver_check_assumptions
  ///
  /// The error handler is invoked if a model is not available because
  /// the commands above were not invoked for the given solver, or if the result was \c Z3_L_FALSE.
  ///
  /// def_API('Z3_solver_get_model', MODEL, (_in(CONTEXT), _in(SOLVER)))
  Z3_model solver_get_model(
    Z3_context c,
    Z3_solver s,
  ) {
    return _solver_get_model(
      c,
      s,
    );
  }

  late final _solver_get_modelPtr =
      _lookup<ffi.NativeFunction<Z3_model Function(Z3_context, Z3_solver)>>(
          'Z3_solver_get_model');
  late final _solver_get_model = _solver_get_modelPtr
      .asFunction<Z3_model Function(Z3_context, Z3_solver)>();

  /// \brief Retrieve the proof for the last #Z3_solver_check or #Z3_solver_check_assumptions
  ///
  /// The error handler is invoked if proof generation is not enabled,
  /// or if the commands above were not invoked for the given solver,
  /// or if the result was different from \c Z3_L_FALSE.
  ///
  /// def_API('Z3_solver_get_proof', AST, (_in(CONTEXT), _in(SOLVER)))
  Z3_ast solver_get_proof(
    Z3_context c,
    Z3_solver s,
  ) {
    return _solver_get_proof(
      c,
      s,
    );
  }

  late final _solver_get_proofPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_solver)>>(
          'Z3_solver_get_proof');
  late final _solver_get_proof =
      _solver_get_proofPtr.asFunction<Z3_ast Function(Z3_context, Z3_solver)>();

  /// \brief Retrieve the unsat core for the last #Z3_solver_check_assumptions
  /// The unsat core is a subset of the assumptions \c a.
  ///
  /// By default, the unsat core will not be minimized. Generation of a minimized
  /// unsat core can be enabled via the `"sat.core.minimize"` and `"smt.core.minimize"`
  /// settings for SAT and SMT cores respectively. Generation of minimized unsat cores
  /// will be more expensive.
  ///
  /// def_API('Z3_solver_get_unsat_core', AST_VECTOR, (_in(CONTEXT), _in(SOLVER)))
  Z3_ast_vector solver_get_unsat_core(
    Z3_context c,
    Z3_solver s,
  ) {
    return _solver_get_unsat_core(
      c,
      s,
    );
  }

  late final _solver_get_unsat_corePtr = _lookup<
          ffi.NativeFunction<Z3_ast_vector Function(Z3_context, Z3_solver)>>(
      'Z3_solver_get_unsat_core');
  late final _solver_get_unsat_core = _solver_get_unsat_corePtr
      .asFunction<Z3_ast_vector Function(Z3_context, Z3_solver)>();

  /// \brief Return a brief justification for an "unknown" result (i.e., \c Z3_L_UNDEF) for
  /// the commands #Z3_solver_check and #Z3_solver_check_assumptions
  ///
  /// def_API('Z3_solver_get_reason_unknown', STRING, (_in(CONTEXT), _in(SOLVER)))
  Z3_string solver_get_reason_unknown(
    Z3_context c,
    Z3_solver s,
  ) {
    return _solver_get_reason_unknown(
      c,
      s,
    );
  }

  late final _solver_get_reason_unknownPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_solver)>>(
          'Z3_solver_get_reason_unknown');
  late final _solver_get_reason_unknown = _solver_get_reason_unknownPtr
      .asFunction<Z3_string Function(Z3_context, Z3_solver)>();

  /// \brief Return statistics for the given solver.
  ///
  /// \remark User must use #Z3_stats_inc_ref and #Z3_stats_dec_ref to manage Z3_stats objects.
  ///
  /// def_API('Z3_solver_get_statistics', STATS, (_in(CONTEXT), _in(SOLVER)))
  Z3_stats solver_get_statistics(
    Z3_context c,
    Z3_solver s,
  ) {
    return _solver_get_statistics(
      c,
      s,
    );
  }

  late final _solver_get_statisticsPtr =
      _lookup<ffi.NativeFunction<Z3_stats Function(Z3_context, Z3_solver)>>(
          'Z3_solver_get_statistics');
  late final _solver_get_statistics = _solver_get_statisticsPtr
      .asFunction<Z3_stats Function(Z3_context, Z3_solver)>();

  /// \brief Convert a solver into a string.
  ///
  /// \sa Z3_solver_from_file
  /// \sa Z3_solver_from_string
  ///
  /// def_API('Z3_solver_to_string', STRING, (_in(CONTEXT), _in(SOLVER)))
  Z3_string solver_to_string(
    Z3_context c,
    Z3_solver s,
  ) {
    return _solver_to_string(
      c,
      s,
    );
  }

  late final _solver_to_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_solver)>>(
          'Z3_solver_to_string');
  late final _solver_to_string = _solver_to_stringPtr
      .asFunction<Z3_string Function(Z3_context, Z3_solver)>();

  /// \brief Convert a solver into a DIMACS formatted string.
  /// \sa Z3_goal_to_diamcs_string for requirements.
  ///
  /// def_API('Z3_solver_to_dimacs_string', STRING, (_in(CONTEXT), _in(SOLVER), _in(BOOL)))
  Z3_string solver_to_dimacs_string(
    Z3_context c,
    Z3_solver s,
    bool include_names,
  ) {
    return _solver_to_dimacs_string(
      c,
      s,
      include_names,
    );
  }

  late final _solver_to_dimacs_stringPtr = _lookup<
          ffi
          .NativeFunction<Z3_string Function(Z3_context, Z3_solver, ffi.Bool)>>(
      'Z3_solver_to_dimacs_string');
  late final _solver_to_dimacs_string = _solver_to_dimacs_stringPtr
      .asFunction<Z3_string Function(Z3_context, Z3_solver, bool)>();

  /// \brief Convert a statistics into a string.
  ///
  /// def_API('Z3_stats_to_string', STRING, (_in(CONTEXT), _in(STATS)))
  Z3_string stats_to_string(
    Z3_context c,
    Z3_stats s,
  ) {
    return _stats_to_string(
      c,
      s,
    );
  }

  late final _stats_to_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_stats)>>(
          'Z3_stats_to_string');
  late final _stats_to_string = _stats_to_stringPtr
      .asFunction<Z3_string Function(Z3_context, Z3_stats)>();

  /// \brief Increment the reference counter of the given statistics object.
  ///
  /// def_API('Z3_stats_inc_ref', VOID, (_in(CONTEXT), _in(STATS)))
  void stats_inc_ref(
    Z3_context c,
    Z3_stats s,
  ) {
    return _stats_inc_ref(
      c,
      s,
    );
  }

  late final _stats_inc_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_stats)>>(
          'Z3_stats_inc_ref');
  late final _stats_inc_ref =
      _stats_inc_refPtr.asFunction<void Function(Z3_context, Z3_stats)>();

  /// \brief Decrement the reference counter of the given statistics object.
  ///
  /// def_API('Z3_stats_dec_ref', VOID, (_in(CONTEXT), _in(STATS)))
  void stats_dec_ref(
    Z3_context c,
    Z3_stats s,
  ) {
    return _stats_dec_ref(
      c,
      s,
    );
  }

  late final _stats_dec_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_stats)>>(
          'Z3_stats_dec_ref');
  late final _stats_dec_ref =
      _stats_dec_refPtr.asFunction<void Function(Z3_context, Z3_stats)>();

  /// \brief Return the number of statistical data in \c s.
  ///
  /// def_API('Z3_stats_size', UINT, (_in(CONTEXT), _in(STATS)))
  int stats_size(
    Z3_context c,
    Z3_stats s,
  ) {
    return _stats_size(
      c,
      s,
    );
  }

  late final _stats_sizePtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_stats)>>(
      'Z3_stats_size');
  late final _stats_size =
      _stats_sizePtr.asFunction<int Function(Z3_context, Z3_stats)>();

  /// \brief Return the key (a string) for a particular statistical data.
  ///
  /// \pre idx < Z3_stats_size(c, s)
  ///
  /// def_API('Z3_stats_get_key', STRING, (_in(CONTEXT), _in(STATS), _in(UINT)))
  Z3_string stats_get_key(
    Z3_context c,
    Z3_stats s,
    int idx,
  ) {
    return _stats_get_key(
      c,
      s,
      idx,
    );
  }

  late final _stats_get_keyPtr = _lookup<
      ffi.NativeFunction<
          Z3_string Function(
              Z3_context, Z3_stats, ffi.UnsignedInt)>>('Z3_stats_get_key');
  late final _stats_get_key = _stats_get_keyPtr
      .asFunction<Z3_string Function(Z3_context, Z3_stats, int)>();

  /// \brief Return \c true if the given statistical data is a unsigned integer.
  ///
  /// \pre idx < Z3_stats_size(c, s)
  ///
  /// def_API('Z3_stats_is_uint', BOOL, (_in(CONTEXT), _in(STATS), _in(UINT)))
  bool stats_is_uint(
    Z3_context c,
    Z3_stats s,
    int idx,
  ) {
    return _stats_is_uint(
      c,
      s,
      idx,
    );
  }

  late final _stats_is_uintPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              Z3_context, Z3_stats, ffi.UnsignedInt)>>('Z3_stats_is_uint');
  late final _stats_is_uint =
      _stats_is_uintPtr.asFunction<bool Function(Z3_context, Z3_stats, int)>();

  /// \brief Return \c true if the given statistical data is a double.
  ///
  /// \pre idx < Z3_stats_size(c, s)
  ///
  /// def_API('Z3_stats_is_double', BOOL, (_in(CONTEXT), _in(STATS), _in(UINT)))
  bool stats_is_double(
    Z3_context c,
    Z3_stats s,
    int idx,
  ) {
    return _stats_is_double(
      c,
      s,
      idx,
    );
  }

  late final _stats_is_doublePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              Z3_context, Z3_stats, ffi.UnsignedInt)>>('Z3_stats_is_double');
  late final _stats_is_double = _stats_is_doublePtr
      .asFunction<bool Function(Z3_context, Z3_stats, int)>();

  /// \brief Return the unsigned value of the given statistical data.
  ///
  /// \pre idx < Z3_stats_size(c, s) && Z3_stats_is_uint(c, s)
  ///
  /// def_API('Z3_stats_get_uint_value', UINT, (_in(CONTEXT), _in(STATS), _in(UINT)))
  int stats_get_uint_value(
    Z3_context c,
    Z3_stats s,
    int idx,
  ) {
    return _stats_get_uint_value(
      c,
      s,
      idx,
    );
  }

  late final _stats_get_uint_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(Z3_context, Z3_stats,
              ffi.UnsignedInt)>>('Z3_stats_get_uint_value');
  late final _stats_get_uint_value = _stats_get_uint_valuePtr
      .asFunction<int Function(Z3_context, Z3_stats, int)>();

  /// \brief Return the double value of the given statistical data.
  ///
  /// \pre idx < Z3_stats_size(c, s) && Z3_stats_is_double(c, s)
  ///
  /// def_API('Z3_stats_get_double_value', DOUBLE, (_in(CONTEXT), _in(STATS), _in(UINT)))
  double stats_get_double_value(
    Z3_context c,
    Z3_stats s,
    int idx,
  ) {
    return _stats_get_double_value(
      c,
      s,
      idx,
    );
  }

  late final _stats_get_double_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(Z3_context, Z3_stats,
              ffi.UnsignedInt)>>('Z3_stats_get_double_value');
  late final _stats_get_double_value = _stats_get_double_valuePtr
      .asFunction<double Function(Z3_context, Z3_stats, int)>();

  /// \brief Return the estimated allocated memory in bytes.
  ///
  /// def_API('Z3_get_estimated_alloc_size', UINT64, ())
  int get_estimated_alloc_size() {
    return _get_estimated_alloc_size();
  }

  late final _get_estimated_alloc_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function()>>(
          'Z3_get_estimated_alloc_size');
  late final _get_estimated_alloc_size =
      _get_estimated_alloc_sizePtr.asFunction<int Function()>();

  /// @name AST vectors */
  /// /**@{*/
  /// /**
  /// \brief Return an empty AST vector.
  ///
  /// \remark Reference counting must be used to manage AST vectors, even when the Z3_context was
  /// created using #Z3_mk_context instead of #Z3_mk_context_rc.
  ///
  /// def_API('Z3_mk_ast_vector', AST_VECTOR, (_in(CONTEXT),))
  Z3_ast_vector mk_ast_vector(
    Z3_context c,
  ) {
    return _mk_ast_vector(
      c,
    );
  }

  late final _mk_ast_vectorPtr =
      _lookup<ffi.NativeFunction<Z3_ast_vector Function(Z3_context)>>(
          'Z3_mk_ast_vector');
  late final _mk_ast_vector =
      _mk_ast_vectorPtr.asFunction<Z3_ast_vector Function(Z3_context)>();

  /// \brief Increment the reference counter of the given AST vector.
  ///
  /// def_API('Z3_ast_vector_inc_ref', VOID, (_in(CONTEXT), _in(AST_VECTOR)))
  void ast_vector_inc_ref(
    Z3_context c,
    Z3_ast_vector v,
  ) {
    return _ast_vector_inc_ref(
      c,
      v,
    );
  }

  late final _ast_vector_inc_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_ast_vector)>>(
          'Z3_ast_vector_inc_ref');
  late final _ast_vector_inc_ref = _ast_vector_inc_refPtr
      .asFunction<void Function(Z3_context, Z3_ast_vector)>();

  /// \brief Decrement the reference counter of the given AST vector.
  ///
  /// def_API('Z3_ast_vector_dec_ref', VOID, (_in(CONTEXT), _in(AST_VECTOR)))
  void ast_vector_dec_ref(
    Z3_context c,
    Z3_ast_vector v,
  ) {
    return _ast_vector_dec_ref(
      c,
      v,
    );
  }

  late final _ast_vector_dec_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_ast_vector)>>(
          'Z3_ast_vector_dec_ref');
  late final _ast_vector_dec_ref = _ast_vector_dec_refPtr
      .asFunction<void Function(Z3_context, Z3_ast_vector)>();

  /// \brief Return the size of the given AST vector.
  ///
  /// def_API('Z3_ast_vector_size', UINT, (_in(CONTEXT), _in(AST_VECTOR)))
  int ast_vector_size(
    Z3_context c,
    Z3_ast_vector v,
  ) {
    return _ast_vector_size(
      c,
      v,
    );
  }

  late final _ast_vector_sizePtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_ast_vector)>>(
      'Z3_ast_vector_size');
  late final _ast_vector_size =
      _ast_vector_sizePtr.asFunction<int Function(Z3_context, Z3_ast_vector)>();

  /// \brief Return the AST at position \c i in the AST vector \c v.
  ///
  /// \pre i < Z3_ast_vector_size(c, v)
  ///
  /// def_API('Z3_ast_vector_get', AST, (_in(CONTEXT), _in(AST_VECTOR), _in(UINT)))
  Z3_ast ast_vector_get(
    Z3_context c,
    Z3_ast_vector v,
    int i,
  ) {
    return _ast_vector_get(
      c,
      v,
      i,
    );
  }

  late final _ast_vector_getPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast_vector,
              ffi.UnsignedInt)>>('Z3_ast_vector_get');
  late final _ast_vector_get = _ast_vector_getPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast_vector, int)>();

  /// \brief Update position \c i of the AST vector \c v with the AST \c a.
  ///
  /// \pre i < Z3_ast_vector_size(c, v)
  ///
  /// def_API('Z3_ast_vector_set', VOID, (_in(CONTEXT), _in(AST_VECTOR), _in(UINT), _in(AST)))
  void ast_vector_set(
    Z3_context c,
    Z3_ast_vector v,
    int i,
    Z3_ast a,
  ) {
    return _ast_vector_set(
      c,
      v,
      i,
      a,
    );
  }

  late final _ast_vector_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_ast_vector, ffi.UnsignedInt,
              Z3_ast)>>('Z3_ast_vector_set');
  late final _ast_vector_set = _ast_vector_setPtr
      .asFunction<void Function(Z3_context, Z3_ast_vector, int, Z3_ast)>();

  /// \brief Resize the AST vector \c v.
  ///
  /// def_API('Z3_ast_vector_resize', VOID, (_in(CONTEXT), _in(AST_VECTOR), _in(UINT)))
  void ast_vector_resize(
    Z3_context c,
    Z3_ast_vector v,
    int n,
  ) {
    return _ast_vector_resize(
      c,
      v,
      n,
    );
  }

  late final _ast_vector_resizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_ast_vector,
              ffi.UnsignedInt)>>('Z3_ast_vector_resize');
  late final _ast_vector_resize = _ast_vector_resizePtr
      .asFunction<void Function(Z3_context, Z3_ast_vector, int)>();

  /// \brief Add the AST \c a in the end of the AST vector \c v. The size of \c v is increased by one.
  ///
  /// def_API('Z3_ast_vector_push', VOID, (_in(CONTEXT), _in(AST_VECTOR), _in(AST)))
  void ast_vector_push(
    Z3_context c,
    Z3_ast_vector v,
    Z3_ast a,
  ) {
    return _ast_vector_push(
      c,
      v,
      a,
    );
  }

  late final _ast_vector_pushPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context, Z3_ast_vector, Z3_ast)>>('Z3_ast_vector_push');
  late final _ast_vector_push = _ast_vector_pushPtr
      .asFunction<void Function(Z3_context, Z3_ast_vector, Z3_ast)>();

  /// \brief Translate the AST vector \c v from context \c s into an AST vector in context \c t.
  ///
  /// def_API('Z3_ast_vector_translate', AST_VECTOR, (_in(CONTEXT), _in(AST_VECTOR), _in(CONTEXT)))
  Z3_ast_vector ast_vector_translate(
    Z3_context s,
    Z3_ast_vector v,
    Z3_context t,
  ) {
    return _ast_vector_translate(
      s,
      v,
      t,
    );
  }

  late final _ast_vector_translatePtr = _lookup<
      ffi.NativeFunction<
          Z3_ast_vector Function(Z3_context, Z3_ast_vector,
              Z3_context)>>('Z3_ast_vector_translate');
  late final _ast_vector_translate = _ast_vector_translatePtr.asFunction<
      Z3_ast_vector Function(Z3_context, Z3_ast_vector, Z3_context)>();

  /// \brief Convert AST vector into a string.
  ///
  /// def_API('Z3_ast_vector_to_string', STRING, (_in(CONTEXT), _in(AST_VECTOR)))
  Z3_string ast_vector_to_string(
    Z3_context c,
    Z3_ast_vector v,
  ) {
    return _ast_vector_to_string(
      c,
      v,
    );
  }

  late final _ast_vector_to_stringPtr = _lookup<
          ffi.NativeFunction<Z3_string Function(Z3_context, Z3_ast_vector)>>(
      'Z3_ast_vector_to_string');
  late final _ast_vector_to_string = _ast_vector_to_stringPtr
      .asFunction<Z3_string Function(Z3_context, Z3_ast_vector)>();

  /// @name AST maps */
  /// /**@{*/
  /// /**
  /// \brief Return an empty mapping from AST to AST
  ///
  /// \remark Reference counting must be used to manage AST maps, even when the Z3_context was
  /// created using #Z3_mk_context instead of #Z3_mk_context_rc.
  ///
  /// def_API('Z3_mk_ast_map', AST_MAP, (_in(CONTEXT),) )
  Z3_ast_map mk_ast_map(
    Z3_context c,
  ) {
    return _mk_ast_map(
      c,
    );
  }

  late final _mk_ast_mapPtr =
      _lookup<ffi.NativeFunction<Z3_ast_map Function(Z3_context)>>(
          'Z3_mk_ast_map');
  late final _mk_ast_map =
      _mk_ast_mapPtr.asFunction<Z3_ast_map Function(Z3_context)>();

  /// \brief Increment the reference counter of the given AST map.
  ///
  /// def_API('Z3_ast_map_inc_ref', VOID, (_in(CONTEXT), _in(AST_MAP)))
  void ast_map_inc_ref(
    Z3_context c,
    Z3_ast_map m,
  ) {
    return _ast_map_inc_ref(
      c,
      m,
    );
  }

  late final _ast_map_inc_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_ast_map)>>(
          'Z3_ast_map_inc_ref');
  late final _ast_map_inc_ref =
      _ast_map_inc_refPtr.asFunction<void Function(Z3_context, Z3_ast_map)>();

  /// \brief Decrement the reference counter of the given AST map.
  ///
  /// def_API('Z3_ast_map_dec_ref', VOID, (_in(CONTEXT), _in(AST_MAP)))
  void ast_map_dec_ref(
    Z3_context c,
    Z3_ast_map m,
  ) {
    return _ast_map_dec_ref(
      c,
      m,
    );
  }

  late final _ast_map_dec_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_ast_map)>>(
          'Z3_ast_map_dec_ref');
  late final _ast_map_dec_ref =
      _ast_map_dec_refPtr.asFunction<void Function(Z3_context, Z3_ast_map)>();

  /// \brief Return true if the map \c m contains the AST key \c k.
  ///
  /// def_API('Z3_ast_map_contains', BOOL, (_in(CONTEXT), _in(AST_MAP), _in(AST)))
  bool ast_map_contains(
    Z3_context c,
    Z3_ast_map m,
    Z3_ast k,
  ) {
    return _ast_map_contains(
      c,
      m,
      k,
    );
  }

  late final _ast_map_containsPtr = _lookup<
          ffi
          .NativeFunction<ffi.Bool Function(Z3_context, Z3_ast_map, Z3_ast)>>(
      'Z3_ast_map_contains');
  late final _ast_map_contains = _ast_map_containsPtr
      .asFunction<bool Function(Z3_context, Z3_ast_map, Z3_ast)>();

  /// \brief Return the value associated with the key \c k.
  ///
  /// The procedure invokes the error handler if \c k is not in the map.
  ///
  /// def_API('Z3_ast_map_find', AST, (_in(CONTEXT), _in(AST_MAP), _in(AST)))
  Z3_ast ast_map_find(
    Z3_context c,
    Z3_ast_map m,
    Z3_ast k,
  ) {
    return _ast_map_find(
      c,
      m,
      k,
    );
  }

  late final _ast_map_findPtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast_map, Z3_ast)>>(
      'Z3_ast_map_find');
  late final _ast_map_find = _ast_map_findPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast_map, Z3_ast)>();

  /// \brief Store/Replace a new key, value pair in the given map.
  ///
  /// def_API('Z3_ast_map_insert', VOID, (_in(CONTEXT), _in(AST_MAP), _in(AST), _in(AST)))
  void ast_map_insert(
    Z3_context c,
    Z3_ast_map m,
    Z3_ast k,
    Z3_ast v,
  ) {
    return _ast_map_insert(
      c,
      m,
      k,
      v,
    );
  }

  late final _ast_map_insertPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context, Z3_ast_map, Z3_ast, Z3_ast)>>('Z3_ast_map_insert');
  late final _ast_map_insert = _ast_map_insertPtr
      .asFunction<void Function(Z3_context, Z3_ast_map, Z3_ast, Z3_ast)>();

  /// \brief Erase a key from the map.
  ///
  /// def_API('Z3_ast_map_erase', VOID, (_in(CONTEXT), _in(AST_MAP), _in(AST)))
  void ast_map_erase(
    Z3_context c,
    Z3_ast_map m,
    Z3_ast k,
  ) {
    return _ast_map_erase(
      c,
      m,
      k,
    );
  }

  late final _ast_map_erasePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(Z3_context, Z3_ast_map, Z3_ast)>>(
      'Z3_ast_map_erase');
  late final _ast_map_erase = _ast_map_erasePtr
      .asFunction<void Function(Z3_context, Z3_ast_map, Z3_ast)>();

  /// \brief Remove all keys from the given map.
  ///
  /// def_API('Z3_ast_map_reset', VOID, (_in(CONTEXT), _in(AST_MAP)))
  void ast_map_reset(
    Z3_context c,
    Z3_ast_map m,
  ) {
    return _ast_map_reset(
      c,
      m,
    );
  }

  late final _ast_map_resetPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_ast_map)>>(
          'Z3_ast_map_reset');
  late final _ast_map_reset =
      _ast_map_resetPtr.asFunction<void Function(Z3_context, Z3_ast_map)>();

  /// \brief Return the size of the given map.
  ///
  /// def_API('Z3_ast_map_size', UINT, (_in(CONTEXT), _in(AST_MAP)))
  int ast_map_size(
    Z3_context c,
    Z3_ast_map m,
  ) {
    return _ast_map_size(
      c,
      m,
    );
  }

  late final _ast_map_sizePtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_ast_map)>>(
      'Z3_ast_map_size');
  late final _ast_map_size =
      _ast_map_sizePtr.asFunction<int Function(Z3_context, Z3_ast_map)>();

  /// \brief Return the keys stored in the given map.
  ///
  /// def_API('Z3_ast_map_keys', AST_VECTOR, (_in(CONTEXT), _in(AST_MAP)))
  Z3_ast_vector ast_map_keys(
    Z3_context c,
    Z3_ast_map m,
  ) {
    return _ast_map_keys(
      c,
      m,
    );
  }

  late final _ast_map_keysPtr = _lookup<
          ffi.NativeFunction<Z3_ast_vector Function(Z3_context, Z3_ast_map)>>(
      'Z3_ast_map_keys');
  late final _ast_map_keys = _ast_map_keysPtr
      .asFunction<Z3_ast_vector Function(Z3_context, Z3_ast_map)>();

  /// \brief Convert the given map into a string.
  ///
  /// def_API('Z3_ast_map_to_string', STRING, (_in(CONTEXT), _in(AST_MAP)))
  Z3_string ast_map_to_string(
    Z3_context c,
    Z3_ast_map m,
  ) {
    return _ast_map_to_string(
      c,
      m,
    );
  }

  late final _ast_map_to_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_ast_map)>>(
          'Z3_ast_map_to_string');
  late final _ast_map_to_string = _ast_map_to_stringPtr
      .asFunction<Z3_string Function(Z3_context, Z3_ast_map)>();

  /// @name Algebraic Numbers */
  /// /**@{*/
  /// /**
  /// \brief Return \c true if \c a can be used as value in the Z3 real algebraic
  /// number package.
  ///
  /// def_API('Z3_algebraic_is_value', BOOL, (_in(CONTEXT), _in(AST)))
  bool algebraic_is_value(
    Z3_context c,
    Z3_ast a,
  ) {
    return _algebraic_is_value(
      c,
      a,
    );
  }

  late final _algebraic_is_valuePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_ast)>>(
          'Z3_algebraic_is_value');
  late final _algebraic_is_value =
      _algebraic_is_valuePtr.asFunction<bool Function(Z3_context, Z3_ast)>();

  /// \brief Return \c true if \c a is positive, and \c false otherwise.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  ///
  /// def_API('Z3_algebraic_is_pos', BOOL, (_in(CONTEXT), _in(AST)))
  bool algebraic_is_pos(
    Z3_context c,
    Z3_ast a,
  ) {
    return _algebraic_is_pos(
      c,
      a,
    );
  }

  late final _algebraic_is_posPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_ast)>>(
          'Z3_algebraic_is_pos');
  late final _algebraic_is_pos =
      _algebraic_is_posPtr.asFunction<bool Function(Z3_context, Z3_ast)>();

  /// \brief Return \c true if \c a is negative, and \c false otherwise.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  ///
  /// def_API('Z3_algebraic_is_neg', BOOL, (_in(CONTEXT), _in(AST)))
  bool algebraic_is_neg(
    Z3_context c,
    Z3_ast a,
  ) {
    return _algebraic_is_neg(
      c,
      a,
    );
  }

  late final _algebraic_is_negPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_ast)>>(
          'Z3_algebraic_is_neg');
  late final _algebraic_is_neg =
      _algebraic_is_negPtr.asFunction<bool Function(Z3_context, Z3_ast)>();

  /// \brief Return \c true if \c a is zero, and \c false otherwise.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  ///
  /// def_API('Z3_algebraic_is_zero', BOOL, (_in(CONTEXT), _in(AST)))
  bool algebraic_is_zero(
    Z3_context c,
    Z3_ast a,
  ) {
    return _algebraic_is_zero(
      c,
      a,
    );
  }

  late final _algebraic_is_zeroPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_ast)>>(
          'Z3_algebraic_is_zero');
  late final _algebraic_is_zero =
      _algebraic_is_zeroPtr.asFunction<bool Function(Z3_context, Z3_ast)>();

  /// \brief Return 1 if \c a is positive, 0 if \c a is zero, and -1 if \c a is negative.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  ///
  /// def_API('Z3_algebraic_sign', INT, (_in(CONTEXT), _in(AST)))
  int algebraic_sign(
    Z3_context c,
    Z3_ast a,
  ) {
    return _algebraic_sign(
      c,
      a,
    );
  }

  late final _algebraic_signPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(Z3_context, Z3_ast)>>(
          'Z3_algebraic_sign');
  late final _algebraic_sign =
      _algebraic_signPtr.asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Return the value a + b.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  /// \pre Z3_algebraic_is_value(c, b)
  /// \post Z3_algebraic_is_value(c, result)
  ///
  /// def_API('Z3_algebraic_add', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast algebraic_add(
    Z3_context c,
    Z3_ast a,
    Z3_ast b,
  ) {
    return _algebraic_add(
      c,
      a,
      b,
    );
  }

  late final _algebraic_addPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_algebraic_add');
  late final _algebraic_add = _algebraic_addPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Return the value a - b.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  /// \pre Z3_algebraic_is_value(c, b)
  /// \post Z3_algebraic_is_value(c, result)
  ///
  /// def_API('Z3_algebraic_sub', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast algebraic_sub(
    Z3_context c,
    Z3_ast a,
    Z3_ast b,
  ) {
    return _algebraic_sub(
      c,
      a,
      b,
    );
  }

  late final _algebraic_subPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_algebraic_sub');
  late final _algebraic_sub = _algebraic_subPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Return the value a * b.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  /// \pre Z3_algebraic_is_value(c, b)
  /// \post Z3_algebraic_is_value(c, result)
  ///
  /// def_API('Z3_algebraic_mul', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast algebraic_mul(
    Z3_context c,
    Z3_ast a,
    Z3_ast b,
  ) {
    return _algebraic_mul(
      c,
      a,
      b,
    );
  }

  late final _algebraic_mulPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_algebraic_mul');
  late final _algebraic_mul = _algebraic_mulPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Return the value a / b.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  /// \pre Z3_algebraic_is_value(c, b)
  /// \pre !Z3_algebraic_is_zero(c, b)
  /// \post Z3_algebraic_is_value(c, result)
  ///
  /// def_API('Z3_algebraic_div', AST, (_in(CONTEXT), _in(AST), _in(AST)))
  Z3_ast algebraic_div(
    Z3_context c,
    Z3_ast a,
    Z3_ast b,
  ) {
    return _algebraic_div(
      c,
      a,
      b,
    );
  }

  late final _algebraic_divPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_algebraic_div');
  late final _algebraic_div = _algebraic_divPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Return the a^(1/k)
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  /// \pre k is even => !Z3_algebraic_is_neg(c, a)
  /// \post Z3_algebraic_is_value(c, result)
  ///
  /// def_API('Z3_algebraic_root', AST, (_in(CONTEXT), _in(AST), _in(UINT)))
  Z3_ast algebraic_root(
    Z3_context c,
    Z3_ast a,
    int k,
  ) {
    return _algebraic_root(
      c,
      a,
      k,
    );
  }

  late final _algebraic_rootPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, Z3_ast, ffi.UnsignedInt)>>('Z3_algebraic_root');
  late final _algebraic_root =
      _algebraic_rootPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, int)>();

  /// \brief Return the a^k
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  /// \post Z3_algebraic_is_value(c, result)
  ///
  /// def_API('Z3_algebraic_power', AST, (_in(CONTEXT), _in(AST), _in(UINT)))
  Z3_ast algebraic_power(
    Z3_context c,
    Z3_ast a,
    int k,
  ) {
    return _algebraic_power(
      c,
      a,
      k,
    );
  }

  late final _algebraic_powerPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, Z3_ast, ffi.UnsignedInt)>>('Z3_algebraic_power');
  late final _algebraic_power = _algebraic_powerPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, int)>();

  /// \brief Return \c true if a < b, and \c false otherwise.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  /// \pre Z3_algebraic_is_value(c, b)
  ///
  /// def_API('Z3_algebraic_lt', BOOL, (_in(CONTEXT), _in(AST), _in(AST)))
  bool algebraic_lt(
    Z3_context c,
    Z3_ast a,
    Z3_ast b,
  ) {
    return _algebraic_lt(
      c,
      a,
      b,
    );
  }

  late final _algebraic_ltPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_ast, Z3_ast)>>(
      'Z3_algebraic_lt');
  late final _algebraic_lt =
      _algebraic_ltPtr.asFunction<bool Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Return \c true if a > b, and \c false otherwise.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  /// \pre Z3_algebraic_is_value(c, b)
  ///
  /// def_API('Z3_algebraic_gt', BOOL, (_in(CONTEXT), _in(AST), _in(AST)))
  bool algebraic_gt(
    Z3_context c,
    Z3_ast a,
    Z3_ast b,
  ) {
    return _algebraic_gt(
      c,
      a,
      b,
    );
  }

  late final _algebraic_gtPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_ast, Z3_ast)>>(
      'Z3_algebraic_gt');
  late final _algebraic_gt =
      _algebraic_gtPtr.asFunction<bool Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Return \c true if a <= b, and \c false otherwise.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  /// \pre Z3_algebraic_is_value(c, b)
  ///
  /// def_API('Z3_algebraic_le', BOOL, (_in(CONTEXT), _in(AST), _in(AST)))
  bool algebraic_le(
    Z3_context c,
    Z3_ast a,
    Z3_ast b,
  ) {
    return _algebraic_le(
      c,
      a,
      b,
    );
  }

  late final _algebraic_lePtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_ast, Z3_ast)>>(
      'Z3_algebraic_le');
  late final _algebraic_le =
      _algebraic_lePtr.asFunction<bool Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Return \c true if a >= b, and \c false otherwise.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  /// \pre Z3_algebraic_is_value(c, b)
  ///
  /// def_API('Z3_algebraic_ge', BOOL, (_in(CONTEXT), _in(AST), _in(AST)))
  bool algebraic_ge(
    Z3_context c,
    Z3_ast a,
    Z3_ast b,
  ) {
    return _algebraic_ge(
      c,
      a,
      b,
    );
  }

  late final _algebraic_gePtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_ast, Z3_ast)>>(
      'Z3_algebraic_ge');
  late final _algebraic_ge =
      _algebraic_gePtr.asFunction<bool Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Return \c true if a == b, and \c false otherwise.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  /// \pre Z3_algebraic_is_value(c, b)
  ///
  /// def_API('Z3_algebraic_eq', BOOL, (_in(CONTEXT), _in(AST), _in(AST)))
  bool algebraic_eq(
    Z3_context c,
    Z3_ast a,
    Z3_ast b,
  ) {
    return _algebraic_eq(
      c,
      a,
      b,
    );
  }

  late final _algebraic_eqPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_ast, Z3_ast)>>(
      'Z3_algebraic_eq');
  late final _algebraic_eq =
      _algebraic_eqPtr.asFunction<bool Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Return \c true if a != b, and \c false otherwise.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  /// \pre Z3_algebraic_is_value(c, b)
  ///
  /// def_API('Z3_algebraic_neq', BOOL, (_in(CONTEXT), _in(AST), _in(AST)))
  bool algebraic_neq(
    Z3_context c,
    Z3_ast a,
    Z3_ast b,
  ) {
    return _algebraic_neq(
      c,
      a,
      b,
    );
  }

  late final _algebraic_neqPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_ast, Z3_ast)>>(
      'Z3_algebraic_neq');
  late final _algebraic_neq =
      _algebraic_neqPtr.asFunction<bool Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Given a multivariate polynomial p(x_0, ..., x_{n-1}, x_n), returns the
  /// roots of the univariate polynomial p(a[0], ..., a[n-1], x_n).
  ///
  /// \pre p is a Z3 expression that contains only arithmetic terms and free variables.
  /// \pre forall i in [0, n) Z3_algebraic_is_value(c, a[i])
  /// \post forall r in result Z3_algebraic_is_value(c, result)
  ///
  /// def_API('Z3_algebraic_roots', AST_VECTOR, (_in(CONTEXT), _in(AST), _in(UINT), _in_array(2, AST)))
  Z3_ast_vector algebraic_roots(
    Z3_context c,
    Z3_ast p,
    int n,
    ffi.Pointer<Z3_ast> a,
  ) {
    return _algebraic_roots(
      c,
      p,
      n,
      a,
    );
  }

  late final _algebraic_rootsPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast_vector Function(Z3_context, Z3_ast, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_algebraic_roots');
  late final _algebraic_roots = _algebraic_rootsPtr.asFunction<
      Z3_ast_vector Function(Z3_context, Z3_ast, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Given a multivariate polynomial p(x_0, ..., x_{n-1}), return the
  /// sign of p(a[0], ..., a[n-1]).
  ///
  /// \pre p is a Z3 expression that contains only arithmetic terms and free variables.
  /// \pre forall i in [0, n) Z3_algebraic_is_value(c, a[i])
  ///
  /// def_API('Z3_algebraic_eval', INT, (_in(CONTEXT), _in(AST), _in(UINT), _in_array(2, AST)))
  int algebraic_eval(
    Z3_context c,
    Z3_ast p,
    int n,
    ffi.Pointer<Z3_ast> a,
  ) {
    return _algebraic_eval(
      c,
      p,
      n,
      a,
    );
  }

  late final _algebraic_evalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(Z3_context, Z3_ast, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_algebraic_eval');
  late final _algebraic_eval = _algebraic_evalPtr
      .asFunction<int Function(Z3_context, Z3_ast, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Return the coefficients of the defining polynomial.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  ///
  /// def_API('Z3_algebraic_get_poly', AST_VECTOR, (_in(CONTEXT), _in(AST)))
  Z3_ast_vector algebraic_get_poly(
    Z3_context c,
    Z3_ast a,
  ) {
    return _algebraic_get_poly(
      c,
      a,
    );
  }

  late final _algebraic_get_polyPtr =
      _lookup<ffi.NativeFunction<Z3_ast_vector Function(Z3_context, Z3_ast)>>(
          'Z3_algebraic_get_poly');
  late final _algebraic_get_poly = _algebraic_get_polyPtr
      .asFunction<Z3_ast_vector Function(Z3_context, Z3_ast)>();

  /// \brief Return which root of the polynomial the algebraic number represents.
  ///
  /// \pre Z3_algebraic_is_value(c, a)
  ///
  /// def_API('Z3_algebraic_get_i', UINT, (_in(CONTEXT), _in(AST)))
  int algebraic_get_i(
    Z3_context c,
    Z3_ast a,
  ) {
    return _algebraic_get_i(
      c,
      a,
    );
  }

  late final _algebraic_get_iPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_ast)>>(
          'Z3_algebraic_get_i');
  late final _algebraic_get_i =
      _algebraic_get_iPtr.asFunction<int Function(Z3_context, Z3_ast)>();

  /// \brief Return the nonzero subresultants of \c p and \c q with respect to the "variable" \c x.
  ///
  /// \pre \c p, \c q and \c x are Z3 expressions where \c p and \c q are arithmetic terms.
  /// Note that, any subterm that cannot be viewed as a polynomial is assumed to be a variable.
  /// Example: \ccode{f(a)} is a considered to be a variable in the polynomial \ccode{
  /// f(a)*f(a) + 2*f(a) + 1}
  ///
  /// def_API('Z3_polynomial_subresultants', AST_VECTOR, (_in(CONTEXT), _in(AST), _in(AST), _in(AST)))
  Z3_ast_vector polynomial_subresultants(
    Z3_context c,
    Z3_ast p,
    Z3_ast q,
    Z3_ast x,
  ) {
    return _polynomial_subresultants(
      c,
      p,
      q,
      x,
    );
  }

  late final _polynomial_subresultantsPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast_vector Function(Z3_context, Z3_ast, Z3_ast,
              Z3_ast)>>('Z3_polynomial_subresultants');
  late final _polynomial_subresultants = _polynomial_subresultantsPtr
      .asFunction<Z3_ast_vector Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>();

  /// @name Real Closed Fields */
  /// /**@{*/
  /// /**
  /// \brief Delete a RCF numeral created using the RCF API.
  ///
  /// def_API('Z3_rcf_del', VOID, (_in(CONTEXT), _in(RCF_NUM)))
  void rcf_del(
    Z3_context c,
    Z3_rcf_num a,
  ) {
    return _rcf_del(
      c,
      a,
    );
  }

  late final _rcf_delPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_rcf_num)>>(
          'Z3_rcf_del');
  late final _rcf_del =
      _rcf_delPtr.asFunction<void Function(Z3_context, Z3_rcf_num)>();

  /// \brief Return a RCF rational using the given string.
  ///
  /// def_API('Z3_rcf_mk_rational', RCF_NUM, (_in(CONTEXT), _in(STRING)))
  Z3_rcf_num rcf_mk_rational(
    Z3_context c,
    Z3_string val,
  ) {
    return _rcf_mk_rational(
      c,
      val,
    );
  }

  late final _rcf_mk_rationalPtr =
      _lookup<ffi.NativeFunction<Z3_rcf_num Function(Z3_context, Z3_string)>>(
          'Z3_rcf_mk_rational');
  late final _rcf_mk_rational = _rcf_mk_rationalPtr
      .asFunction<Z3_rcf_num Function(Z3_context, Z3_string)>();

  /// \brief Return a RCF small integer.
  ///
  /// def_API('Z3_rcf_mk_small_int', RCF_NUM, (_in(CONTEXT), _in(INT)))
  Z3_rcf_num rcf_mk_small_int(
    Z3_context c,
    int val,
  ) {
    return _rcf_mk_small_int(
      c,
      val,
    );
  }

  late final _rcf_mk_small_intPtr =
      _lookup<ffi.NativeFunction<Z3_rcf_num Function(Z3_context, ffi.Int)>>(
          'Z3_rcf_mk_small_int');
  late final _rcf_mk_small_int =
      _rcf_mk_small_intPtr.asFunction<Z3_rcf_num Function(Z3_context, int)>();

  /// \brief Return Pi
  ///
  /// def_API('Z3_rcf_mk_pi', RCF_NUM, (_in(CONTEXT),))
  Z3_rcf_num rcf_mk_pi(
    Z3_context c,
  ) {
    return _rcf_mk_pi(
      c,
    );
  }

  late final _rcf_mk_piPtr =
      _lookup<ffi.NativeFunction<Z3_rcf_num Function(Z3_context)>>(
          'Z3_rcf_mk_pi');
  late final _rcf_mk_pi =
      _rcf_mk_piPtr.asFunction<Z3_rcf_num Function(Z3_context)>();

  /// \brief Return e (Euler's constant)
  ///
  /// def_API('Z3_rcf_mk_e', RCF_NUM, (_in(CONTEXT),))
  Z3_rcf_num rcf_mk_e(
    Z3_context c,
  ) {
    return _rcf_mk_e(
      c,
    );
  }

  late final _rcf_mk_ePtr =
      _lookup<ffi.NativeFunction<Z3_rcf_num Function(Z3_context)>>(
          'Z3_rcf_mk_e');
  late final _rcf_mk_e =
      _rcf_mk_ePtr.asFunction<Z3_rcf_num Function(Z3_context)>();

  /// \brief Return a new infinitesimal that is smaller than all elements in the Z3 field.
  ///
  /// def_API('Z3_rcf_mk_infinitesimal', RCF_NUM, (_in(CONTEXT),))
  Z3_rcf_num rcf_mk_infinitesimal(
    Z3_context c,
  ) {
    return _rcf_mk_infinitesimal(
      c,
    );
  }

  late final _rcf_mk_infinitesimalPtr =
      _lookup<ffi.NativeFunction<Z3_rcf_num Function(Z3_context)>>(
          'Z3_rcf_mk_infinitesimal');
  late final _rcf_mk_infinitesimal =
      _rcf_mk_infinitesimalPtr.asFunction<Z3_rcf_num Function(Z3_context)>();

  /// \brief Store in roots the roots of the polynomial \ccode{a[n-1]*x^{n-1} + ... + a[0]}.
  /// The output vector \c roots must have size \c n.
  /// It returns the number of roots of the polynomial.
  ///
  /// \pre The input polynomial is not the zero polynomial.
  ///
  /// def_API('Z3_rcf_mk_roots', UINT, (_in(CONTEXT), _in(UINT), _in_array(1, RCF_NUM), _out_array(1, RCF_NUM)))
  int rcf_mk_roots(
    Z3_context c,
    int n,
    ffi.Pointer<Z3_rcf_num> a,
    ffi.Pointer<Z3_rcf_num> roots,
  ) {
    return _rcf_mk_roots(
      c,
      n,
      a,
      roots,
    );
  }

  late final _rcf_mk_rootsPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              Z3_context,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_rcf_num>,
              ffi.Pointer<Z3_rcf_num>)>>('Z3_rcf_mk_roots');
  late final _rcf_mk_roots = _rcf_mk_rootsPtr.asFunction<
      int Function(
          Z3_context, int, ffi.Pointer<Z3_rcf_num>, ffi.Pointer<Z3_rcf_num>)>();

  /// \brief Return the value \ccode{a + b}.
  ///
  /// def_API('Z3_rcf_add', RCF_NUM, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
  Z3_rcf_num rcf_add(
    Z3_context c,
    Z3_rcf_num a,
    Z3_rcf_num b,
  ) {
    return _rcf_add(
      c,
      a,
      b,
    );
  }

  late final _rcf_addPtr = _lookup<
      ffi.NativeFunction<
          Z3_rcf_num Function(
              Z3_context, Z3_rcf_num, Z3_rcf_num)>>('Z3_rcf_add');
  late final _rcf_add = _rcf_addPtr
      .asFunction<Z3_rcf_num Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>();

  /// \brief Return the value \ccode{a - b}.
  ///
  /// def_API('Z3_rcf_sub', RCF_NUM, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
  Z3_rcf_num rcf_sub(
    Z3_context c,
    Z3_rcf_num a,
    Z3_rcf_num b,
  ) {
    return _rcf_sub(
      c,
      a,
      b,
    );
  }

  late final _rcf_subPtr = _lookup<
      ffi.NativeFunction<
          Z3_rcf_num Function(
              Z3_context, Z3_rcf_num, Z3_rcf_num)>>('Z3_rcf_sub');
  late final _rcf_sub = _rcf_subPtr
      .asFunction<Z3_rcf_num Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>();

  /// \brief Return the value \ccode{a * b}.
  ///
  /// def_API('Z3_rcf_mul', RCF_NUM, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
  Z3_rcf_num rcf_mul(
    Z3_context c,
    Z3_rcf_num a,
    Z3_rcf_num b,
  ) {
    return _rcf_mul(
      c,
      a,
      b,
    );
  }

  late final _rcf_mulPtr = _lookup<
      ffi.NativeFunction<
          Z3_rcf_num Function(
              Z3_context, Z3_rcf_num, Z3_rcf_num)>>('Z3_rcf_mul');
  late final _rcf_mul = _rcf_mulPtr
      .asFunction<Z3_rcf_num Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>();

  /// \brief Return the value \ccode{a / b}.
  ///
  /// def_API('Z3_rcf_div', RCF_NUM, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
  Z3_rcf_num rcf_div(
    Z3_context c,
    Z3_rcf_num a,
    Z3_rcf_num b,
  ) {
    return _rcf_div(
      c,
      a,
      b,
    );
  }

  late final _rcf_divPtr = _lookup<
      ffi.NativeFunction<
          Z3_rcf_num Function(
              Z3_context, Z3_rcf_num, Z3_rcf_num)>>('Z3_rcf_div');
  late final _rcf_div = _rcf_divPtr
      .asFunction<Z3_rcf_num Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>();

  /// \brief Return the value \ccode{-a}.
  ///
  /// def_API('Z3_rcf_neg', RCF_NUM, (_in(CONTEXT), _in(RCF_NUM)))
  Z3_rcf_num rcf_neg(
    Z3_context c,
    Z3_rcf_num a,
  ) {
    return _rcf_neg(
      c,
      a,
    );
  }

  late final _rcf_negPtr =
      _lookup<ffi.NativeFunction<Z3_rcf_num Function(Z3_context, Z3_rcf_num)>>(
          'Z3_rcf_neg');
  late final _rcf_neg =
      _rcf_negPtr.asFunction<Z3_rcf_num Function(Z3_context, Z3_rcf_num)>();

  /// \brief Return the value \ccode{1/a}.
  ///
  /// def_API('Z3_rcf_inv', RCF_NUM, (_in(CONTEXT), _in(RCF_NUM)))
  Z3_rcf_num rcf_inv(
    Z3_context c,
    Z3_rcf_num a,
  ) {
    return _rcf_inv(
      c,
      a,
    );
  }

  late final _rcf_invPtr =
      _lookup<ffi.NativeFunction<Z3_rcf_num Function(Z3_context, Z3_rcf_num)>>(
          'Z3_rcf_inv');
  late final _rcf_inv =
      _rcf_invPtr.asFunction<Z3_rcf_num Function(Z3_context, Z3_rcf_num)>();

  /// \brief Return the value \ccode{a^k}.
  ///
  /// def_API('Z3_rcf_power', RCF_NUM, (_in(CONTEXT), _in(RCF_NUM), _in(UINT)))
  Z3_rcf_num rcf_power(
    Z3_context c,
    Z3_rcf_num a,
    int k,
  ) {
    return _rcf_power(
      c,
      a,
      k,
    );
  }

  late final _rcf_powerPtr = _lookup<
      ffi.NativeFunction<
          Z3_rcf_num Function(
              Z3_context, Z3_rcf_num, ffi.UnsignedInt)>>('Z3_rcf_power');
  late final _rcf_power = _rcf_powerPtr
      .asFunction<Z3_rcf_num Function(Z3_context, Z3_rcf_num, int)>();

  /// \brief Return \c true if \ccode{a < b}.
  ///
  /// def_API('Z3_rcf_lt', BOOL, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
  bool rcf_lt(
    Z3_context c,
    Z3_rcf_num a,
    Z3_rcf_num b,
  ) {
    return _rcf_lt(
      c,
      a,
      b,
    );
  }

  late final _rcf_ltPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>>('Z3_rcf_lt');
  late final _rcf_lt = _rcf_ltPtr
      .asFunction<bool Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>();

  /// \brief Return \c true if \ccode{a > b}.
  ///
  /// def_API('Z3_rcf_gt', BOOL, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
  bool rcf_gt(
    Z3_context c,
    Z3_rcf_num a,
    Z3_rcf_num b,
  ) {
    return _rcf_gt(
      c,
      a,
      b,
    );
  }

  late final _rcf_gtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>>('Z3_rcf_gt');
  late final _rcf_gt = _rcf_gtPtr
      .asFunction<bool Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>();

  /// \brief Return \c true if \ccode{a <= b}.
  ///
  /// def_API('Z3_rcf_le', BOOL, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
  bool rcf_le(
    Z3_context c,
    Z3_rcf_num a,
    Z3_rcf_num b,
  ) {
    return _rcf_le(
      c,
      a,
      b,
    );
  }

  late final _rcf_lePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>>('Z3_rcf_le');
  late final _rcf_le = _rcf_lePtr
      .asFunction<bool Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>();

  /// \brief Return \c true if \ccode{a >= b}.
  ///
  /// def_API('Z3_rcf_ge', BOOL, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
  bool rcf_ge(
    Z3_context c,
    Z3_rcf_num a,
    Z3_rcf_num b,
  ) {
    return _rcf_ge(
      c,
      a,
      b,
    );
  }

  late final _rcf_gePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>>('Z3_rcf_ge');
  late final _rcf_ge = _rcf_gePtr
      .asFunction<bool Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>();

  /// \brief Return \c true if \ccode{a == b}.
  ///
  /// def_API('Z3_rcf_eq', BOOL, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
  bool rcf_eq(
    Z3_context c,
    Z3_rcf_num a,
    Z3_rcf_num b,
  ) {
    return _rcf_eq(
      c,
      a,
      b,
    );
  }

  late final _rcf_eqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>>('Z3_rcf_eq');
  late final _rcf_eq = _rcf_eqPtr
      .asFunction<bool Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>();

  /// \brief Return \c true if \ccode{a != b}.
  ///
  /// def_API('Z3_rcf_neq', BOOL, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
  bool rcf_neq(
    Z3_context c,
    Z3_rcf_num a,
    Z3_rcf_num b,
  ) {
    return _rcf_neq(
      c,
      a,
      b,
    );
  }

  late final _rcf_neqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>>('Z3_rcf_neq');
  late final _rcf_neq = _rcf_neqPtr
      .asFunction<bool Function(Z3_context, Z3_rcf_num, Z3_rcf_num)>();

  /// \brief Convert the RCF numeral into a string.
  ///
  /// def_API('Z3_rcf_num_to_string', STRING, (_in(CONTEXT), _in(RCF_NUM), _in(BOOL), _in(BOOL)))
  Z3_string rcf_num_to_string(
    Z3_context c,
    Z3_rcf_num a,
    bool compact,
    bool html,
  ) {
    return _rcf_num_to_string(
      c,
      a,
      compact,
      html,
    );
  }

  late final _rcf_num_to_stringPtr = _lookup<
      ffi.NativeFunction<
          Z3_string Function(Z3_context, Z3_rcf_num, ffi.Bool,
              ffi.Bool)>>('Z3_rcf_num_to_string');
  late final _rcf_num_to_string = _rcf_num_to_stringPtr
      .asFunction<Z3_string Function(Z3_context, Z3_rcf_num, bool, bool)>();

  /// \brief Convert the RCF numeral into a string in decimal notation.
  ///
  /// def_API('Z3_rcf_num_to_decimal_string', STRING, (_in(CONTEXT), _in(RCF_NUM), _in(UINT)))
  Z3_string rcf_num_to_decimal_string(
    Z3_context c,
    Z3_rcf_num a,
    int prec,
  ) {
    return _rcf_num_to_decimal_string(
      c,
      a,
      prec,
    );
  }

  late final _rcf_num_to_decimal_stringPtr = _lookup<
      ffi.NativeFunction<
          Z3_string Function(Z3_context, Z3_rcf_num,
              ffi.UnsignedInt)>>('Z3_rcf_num_to_decimal_string');
  late final _rcf_num_to_decimal_string = _rcf_num_to_decimal_stringPtr
      .asFunction<Z3_string Function(Z3_context, Z3_rcf_num, int)>();

  /// \brief Extract the "numerator" and "denominator" of the given RCF numeral.
  /// We have that \ccode{a = n/d}, moreover \c n and \c d are not represented using rational functions.
  ///
  /// def_API('Z3_rcf_get_numerator_denominator', VOID, (_in(CONTEXT), _in(RCF_NUM), _out(RCF_NUM), _out(RCF_NUM)))
  void rcf_get_numerator_denominator(
    Z3_context c,
    Z3_rcf_num a,
    ffi.Pointer<Z3_rcf_num> n,
    ffi.Pointer<Z3_rcf_num> d,
  ) {
    return _rcf_get_numerator_denominator(
      c,
      a,
      n,
      d,
    );
  }

  late final _rcf_get_numerator_denominatorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_rcf_num, ffi.Pointer<Z3_rcf_num>,
              ffi.Pointer<Z3_rcf_num>)>>('Z3_rcf_get_numerator_denominator');
  late final _rcf_get_numerator_denominator =
      _rcf_get_numerator_denominatorPtr.asFunction<
          void Function(Z3_context, Z3_rcf_num, ffi.Pointer<Z3_rcf_num>,
              ffi.Pointer<Z3_rcf_num>)>();

  /// @name Fixedpoint facilities */
  /// /**@{*/
  /// /**
  /// \brief Create a new fixedpoint context.
  ///
  /// \remark User must use #Z3_fixedpoint_inc_ref and #Z3_fixedpoint_dec_ref to manage fixedpoint objects.
  /// Even if the context was created using #Z3_mk_context instead of #Z3_mk_context_rc.
  ///
  /// def_API('Z3_mk_fixedpoint', FIXEDPOINT, (_in(CONTEXT), ))
  Z3_fixedpoint mk_fixedpoint(
    Z3_context c,
  ) {
    return _mk_fixedpoint(
      c,
    );
  }

  late final _mk_fixedpointPtr =
      _lookup<ffi.NativeFunction<Z3_fixedpoint Function(Z3_context)>>(
          'Z3_mk_fixedpoint');
  late final _mk_fixedpoint =
      _mk_fixedpointPtr.asFunction<Z3_fixedpoint Function(Z3_context)>();

  /// \brief Increment the reference counter of the given fixedpoint context
  ///
  /// def_API('Z3_fixedpoint_inc_ref', VOID, (_in(CONTEXT), _in(FIXEDPOINT)))
  void fixedpoint_inc_ref(
    Z3_context c,
    Z3_fixedpoint d,
  ) {
    return _fixedpoint_inc_ref(
      c,
      d,
    );
  }

  late final _fixedpoint_inc_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_fixedpoint)>>(
          'Z3_fixedpoint_inc_ref');
  late final _fixedpoint_inc_ref = _fixedpoint_inc_refPtr
      .asFunction<void Function(Z3_context, Z3_fixedpoint)>();

  /// \brief Decrement the reference counter of the given fixedpoint context.
  ///
  /// def_API('Z3_fixedpoint_dec_ref', VOID, (_in(CONTEXT), _in(FIXEDPOINT)))
  void fixedpoint_dec_ref(
    Z3_context c,
    Z3_fixedpoint d,
  ) {
    return _fixedpoint_dec_ref(
      c,
      d,
    );
  }

  late final _fixedpoint_dec_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_fixedpoint)>>(
          'Z3_fixedpoint_dec_ref');
  late final _fixedpoint_dec_ref = _fixedpoint_dec_refPtr
      .asFunction<void Function(Z3_context, Z3_fixedpoint)>();

  /// \brief Add a universal Horn clause as a named rule.
  /// The \c horn_rule should be of the form:
  ///
  /// \code
  /// horn_rule ::= (forall (bound-vars) horn_rule)
  /// |  (=> atoms horn_rule)
  /// |  atom
  /// \endcode
  ///
  /// def_API('Z3_fixedpoint_add_rule', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(AST), _in(SYMBOL)))
  void fixedpoint_add_rule(
    Z3_context c,
    Z3_fixedpoint d,
    Z3_ast rule,
    Z3_symbol name,
  ) {
    return _fixedpoint_add_rule(
      c,
      d,
      rule,
      name,
    );
  }

  late final _fixedpoint_add_rulePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_fixedpoint, Z3_ast,
              Z3_symbol)>>('Z3_fixedpoint_add_rule');
  late final _fixedpoint_add_rule = _fixedpoint_add_rulePtr.asFunction<
      void Function(Z3_context, Z3_fixedpoint, Z3_ast, Z3_symbol)>();

  /// \brief Add a Database fact.
  ///
  /// \param c - context
  /// \param d - fixed point context
  /// \param r - relation signature for the row.
  /// \param num_args - number of columns for the given row.
  /// \param args - array of the row elements.
  ///
  /// The number of arguments \c num_args should be equal to the number
  /// of sorts in the domain of \c r. Each sort in the domain should be an integral
  /// (bit-vector, Boolean or or finite domain sort).
  ///
  /// The call has the same effect as adding a rule where \c r is applied to the arguments.
  ///
  /// def_API('Z3_fixedpoint_add_fact', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(FUNC_DECL), _in(UINT), _in_array(3, UINT)))
  void fixedpoint_add_fact(
    Z3_context c,
    Z3_fixedpoint d,
    Z3_func_decl r,
    int num_args,
    ffi.Pointer<ffi.UnsignedInt> args,
  ) {
    return _fixedpoint_add_fact(
      c,
      d,
      r,
      num_args,
      args,
    );
  }

  late final _fixedpoint_add_factPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context,
              Z3_fixedpoint,
              Z3_func_decl,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.UnsignedInt>)>>('Z3_fixedpoint_add_fact');
  late final _fixedpoint_add_fact = _fixedpoint_add_factPtr.asFunction<
      void Function(Z3_context, Z3_fixedpoint, Z3_func_decl, int,
          ffi.Pointer<ffi.UnsignedInt>)>();

  /// \brief Assert a constraint to the fixedpoint context.
  ///
  /// The constraints are used as background axioms when the fixedpoint engine uses the PDR mode.
  /// They are ignored for standard Datalog mode.
  ///
  /// def_API('Z3_fixedpoint_assert', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(AST)))
  void fixedpoint_assert(
    Z3_context c,
    Z3_fixedpoint d,
    Z3_ast axiom,
  ) {
    return _fixedpoint_assert(
      c,
      d,
      axiom,
    );
  }

  late final _fixedpoint_assertPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context, Z3_fixedpoint, Z3_ast)>>('Z3_fixedpoint_assert');
  late final _fixedpoint_assert = _fixedpoint_assertPtr
      .asFunction<void Function(Z3_context, Z3_fixedpoint, Z3_ast)>();

  /// \brief Pose a query against the asserted rules.
  ///
  /// \code
  /// query ::= (exists (bound-vars) query)
  /// |  literals
  /// \endcode
  ///
  /// query returns
  /// - \c Z3_L_FALSE if the query is unsatisfiable.
  /// - \c Z3_L_TRUE if the query is satisfiable. Obtain the answer by calling #Z3_fixedpoint_get_answer.
  /// - \c Z3_L_UNDEF if the query was interrupted, timed out or otherwise failed.
  ///
  /// def_API('Z3_fixedpoint_query', LBOOL, (_in(CONTEXT), _in(FIXEDPOINT), _in(AST)))
  int fixedpoint_query(
    Z3_context c,
    Z3_fixedpoint d,
    Z3_ast query,
  ) {
    return _fixedpoint_query(
      c,
      d,
      query,
    );
  }

  late final _fixedpoint_queryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              Z3_context, Z3_fixedpoint, Z3_ast)>>('Z3_fixedpoint_query');
  late final _fixedpoint_query = _fixedpoint_queryPtr
      .asFunction<int Function(Z3_context, Z3_fixedpoint, Z3_ast)>();

  /// \brief Pose multiple queries against the asserted rules.
  ///
  /// The queries are encoded as relations (function declarations).
  ///
  /// query returns
  /// - \c Z3_L_FALSE if the query is unsatisfiable.
  /// - \c Z3_L_TRUE if the query is satisfiable. Obtain the answer by calling #Z3_fixedpoint_get_answer.
  /// - \c Z3_L_UNDEF if the query was interrupted, timed out or otherwise failed.
  ///
  /// def_API('Z3_fixedpoint_query_relations', LBOOL, (_in(CONTEXT), _in(FIXEDPOINT), _in(UINT), _in_array(2, FUNC_DECL)))
  int fixedpoint_query_relations(
    Z3_context c,
    Z3_fixedpoint d,
    int num_relations,
    ffi.Pointer<Z3_func_decl> relations,
  ) {
    return _fixedpoint_query_relations(
      c,
      d,
      num_relations,
      relations,
    );
  }

  late final _fixedpoint_query_relationsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(Z3_context, Z3_fixedpoint, ffi.UnsignedInt,
              ffi.Pointer<Z3_func_decl>)>>('Z3_fixedpoint_query_relations');
  late final _fixedpoint_query_relations =
      _fixedpoint_query_relationsPtr.asFunction<
          int Function(
              Z3_context, Z3_fixedpoint, int, ffi.Pointer<Z3_func_decl>)>();

  /// \brief Retrieve a formula that encodes satisfying answers to the query.
  ///
  ///
  /// When used in Datalog mode, the returned answer is a disjunction of conjuncts.
  /// Each conjunct encodes values of the bound variables of the query that are satisfied.
  /// In PDR mode, the returned answer is a single conjunction.
  ///
  /// When used in Datalog mode the previous call to #Z3_fixedpoint_query must have returned \c Z3_L_TRUE.
  /// When used with the PDR engine, the previous call must have been either \c Z3_L_TRUE or \c Z3_L_FALSE.
  ///
  /// def_API('Z3_fixedpoint_get_answer', AST, (_in(CONTEXT), _in(FIXEDPOINT)))
  Z3_ast fixedpoint_get_answer(
    Z3_context c,
    Z3_fixedpoint d,
  ) {
    return _fixedpoint_get_answer(
      c,
      d,
    );
  }

  late final _fixedpoint_get_answerPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_fixedpoint)>>(
          'Z3_fixedpoint_get_answer');
  late final _fixedpoint_get_answer = _fixedpoint_get_answerPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_fixedpoint)>();

  /// \brief Retrieve a string that describes the last status returned by #Z3_fixedpoint_query.
  ///
  /// Use this method when #Z3_fixedpoint_query returns \c Z3_L_UNDEF.
  ///
  /// def_API('Z3_fixedpoint_get_reason_unknown', STRING, (_in(CONTEXT), _in(FIXEDPOINT) ))
  Z3_string fixedpoint_get_reason_unknown(
    Z3_context c,
    Z3_fixedpoint d,
  ) {
    return _fixedpoint_get_reason_unknown(
      c,
      d,
    );
  }

  late final _fixedpoint_get_reason_unknownPtr = _lookup<
          ffi.NativeFunction<Z3_string Function(Z3_context, Z3_fixedpoint)>>(
      'Z3_fixedpoint_get_reason_unknown');
  late final _fixedpoint_get_reason_unknown = _fixedpoint_get_reason_unknownPtr
      .asFunction<Z3_string Function(Z3_context, Z3_fixedpoint)>();

  /// \brief Update a named rule.
  /// A rule with the same name must have been previously created.
  ///
  /// def_API('Z3_fixedpoint_update_rule', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(AST), _in(SYMBOL)))
  void fixedpoint_update_rule(
    Z3_context c,
    Z3_fixedpoint d,
    Z3_ast a,
    Z3_symbol name,
  ) {
    return _fixedpoint_update_rule(
      c,
      d,
      a,
      name,
    );
  }

  late final _fixedpoint_update_rulePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_fixedpoint, Z3_ast,
              Z3_symbol)>>('Z3_fixedpoint_update_rule');
  late final _fixedpoint_update_rule = _fixedpoint_update_rulePtr.asFunction<
      void Function(Z3_context, Z3_fixedpoint, Z3_ast, Z3_symbol)>();

  /// \brief Query the PDR engine for the maximal levels properties are known about predicate.
  ///
  /// This call retrieves the maximal number of relevant unfoldings
  /// of \c pred with respect to the current exploration state.
  /// Note: this functionality is PDR specific.
  ///
  /// def_API('Z3_fixedpoint_get_num_levels', UINT, (_in(CONTEXT), _in(FIXEDPOINT), _in(FUNC_DECL)))
  int fixedpoint_get_num_levels(
    Z3_context c,
    Z3_fixedpoint d,
    Z3_func_decl pred,
  ) {
    return _fixedpoint_get_num_levels(
      c,
      d,
      pred,
    );
  }

  late final _fixedpoint_get_num_levelsPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(Z3_context, Z3_fixedpoint,
              Z3_func_decl)>>('Z3_fixedpoint_get_num_levels');
  late final _fixedpoint_get_num_levels = _fixedpoint_get_num_levelsPtr
      .asFunction<int Function(Z3_context, Z3_fixedpoint, Z3_func_decl)>();

  /// Retrieve the current cover of \c pred up to \c level unfoldings.
  /// Return just the delta that is known at \c level. To
  /// obtain the full set of properties of \c pred one should query
  /// at \c level+1 , \c level+2 etc, and include \c level=-1.
  ///
  /// Note: this functionality is PDR specific.
  ///
  /// def_API('Z3_fixedpoint_get_cover_delta', AST, (_in(CONTEXT), _in(FIXEDPOINT), _in(INT), _in(FUNC_DECL)))
  Z3_ast fixedpoint_get_cover_delta(
    Z3_context c,
    Z3_fixedpoint d,
    int level,
    Z3_func_decl pred,
  ) {
    return _fixedpoint_get_cover_delta(
      c,
      d,
      level,
      pred,
    );
  }

  late final _fixedpoint_get_cover_deltaPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_fixedpoint, ffi.Int,
              Z3_func_decl)>>('Z3_fixedpoint_get_cover_delta');
  late final _fixedpoint_get_cover_delta =
      _fixedpoint_get_cover_deltaPtr.asFunction<
          Z3_ast Function(Z3_context, Z3_fixedpoint, int, Z3_func_decl)>();

  /// \brief Add property about the predicate \c pred.
  /// Add a property of predicate \c pred at \c level.
  /// It gets pushed forward when possible.
  ///
  /// Note: level = -1 is treated as the fixedpoint. So passing -1 for the \c level
  /// means that the property is true of the fixed-point unfolding with respect to \c pred.
  ///
  /// Note: this functionality is PDR specific.
  ///
  /// def_API('Z3_fixedpoint_add_cover', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(INT), _in(FUNC_DECL), _in(AST)))
  void fixedpoint_add_cover(
    Z3_context c,
    Z3_fixedpoint d,
    int level,
    Z3_func_decl pred,
    Z3_ast property,
  ) {
    return _fixedpoint_add_cover(
      c,
      d,
      level,
      pred,
      property,
    );
  }

  late final _fixedpoint_add_coverPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_fixedpoint, ffi.Int, Z3_func_decl,
              Z3_ast)>>('Z3_fixedpoint_add_cover');
  late final _fixedpoint_add_cover = _fixedpoint_add_coverPtr.asFunction<
      void Function(Z3_context, Z3_fixedpoint, int, Z3_func_decl, Z3_ast)>();

  /// \brief Retrieve statistics information from the last call to #Z3_fixedpoint_query.
  ///
  /// def_API('Z3_fixedpoint_get_statistics', STATS, (_in(CONTEXT), _in(FIXEDPOINT)))
  Z3_stats fixedpoint_get_statistics(
    Z3_context c,
    Z3_fixedpoint d,
  ) {
    return _fixedpoint_get_statistics(
      c,
      d,
    );
  }

  late final _fixedpoint_get_statisticsPtr =
      _lookup<ffi.NativeFunction<Z3_stats Function(Z3_context, Z3_fixedpoint)>>(
          'Z3_fixedpoint_get_statistics');
  late final _fixedpoint_get_statistics = _fixedpoint_get_statisticsPtr
      .asFunction<Z3_stats Function(Z3_context, Z3_fixedpoint)>();

  /// \brief Register relation as Fixedpoint defined.
  /// Fixedpoint defined relations have least-fixedpoint semantics.
  /// For example, the relation is empty if it does not occur
  /// in a head or a fact.
  ///
  /// def_API('Z3_fixedpoint_register_relation', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(FUNC_DECL)))
  void fixedpoint_register_relation(
    Z3_context c,
    Z3_fixedpoint d,
    Z3_func_decl f,
  ) {
    return _fixedpoint_register_relation(
      c,
      d,
      f,
    );
  }

  late final _fixedpoint_register_relationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_fixedpoint,
              Z3_func_decl)>>('Z3_fixedpoint_register_relation');
  late final _fixedpoint_register_relation = _fixedpoint_register_relationPtr
      .asFunction<void Function(Z3_context, Z3_fixedpoint, Z3_func_decl)>();

  /// \brief Configure the predicate representation.
  ///
  /// It sets the predicate to use a set of domains given by the list of symbols.
  /// The domains given by the list of symbols must belong to a set
  /// of built-in domains.
  ///
  /// def_API('Z3_fixedpoint_set_predicate_representation', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(FUNC_DECL), _in(UINT), _in_array(3, SYMBOL)))
  void fixedpoint_set_predicate_representation(
    Z3_context c,
    Z3_fixedpoint d,
    Z3_func_decl f,
    int num_relations,
    ffi.Pointer<Z3_symbol> relation_kinds,
  ) {
    return _fixedpoint_set_predicate_representation(
      c,
      d,
      f,
      num_relations,
      relation_kinds,
    );
  }

  late final _fixedpoint_set_predicate_representationPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(Z3_context, Z3_fixedpoint, Z3_func_decl,
                  ffi.UnsignedInt, ffi.Pointer<Z3_symbol>)>>(
      'Z3_fixedpoint_set_predicate_representation');
  late final _fixedpoint_set_predicate_representation =
      _fixedpoint_set_predicate_representationPtr.asFunction<
          void Function(Z3_context, Z3_fixedpoint, Z3_func_decl, int,
              ffi.Pointer<Z3_symbol>)>();

  /// \brief Retrieve set of rules from fixedpoint context.
  ///
  /// def_API('Z3_fixedpoint_get_rules', AST_VECTOR, (_in(CONTEXT),_in(FIXEDPOINT)))
  Z3_ast_vector fixedpoint_get_rules(
    Z3_context c,
    Z3_fixedpoint f,
  ) {
    return _fixedpoint_get_rules(
      c,
      f,
    );
  }

  late final _fixedpoint_get_rulesPtr = _lookup<
          ffi
          .NativeFunction<Z3_ast_vector Function(Z3_context, Z3_fixedpoint)>>(
      'Z3_fixedpoint_get_rules');
  late final _fixedpoint_get_rules = _fixedpoint_get_rulesPtr
      .asFunction<Z3_ast_vector Function(Z3_context, Z3_fixedpoint)>();

  /// \brief Retrieve set of background assertions from fixedpoint context.
  ///
  /// def_API('Z3_fixedpoint_get_assertions', AST_VECTOR, (_in(CONTEXT),_in(FIXEDPOINT)))
  Z3_ast_vector fixedpoint_get_assertions(
    Z3_context c,
    Z3_fixedpoint f,
  ) {
    return _fixedpoint_get_assertions(
      c,
      f,
    );
  }

  late final _fixedpoint_get_assertionsPtr = _lookup<
          ffi
          .NativeFunction<Z3_ast_vector Function(Z3_context, Z3_fixedpoint)>>(
      'Z3_fixedpoint_get_assertions');
  late final _fixedpoint_get_assertions = _fixedpoint_get_assertionsPtr
      .asFunction<Z3_ast_vector Function(Z3_context, Z3_fixedpoint)>();

  /// \brief Set parameters on fixedpoint context.
  ///
  /// \sa Z3_fixedpoint_get_help
  /// \sa Z3_fixedpoint_get_param_descrs
  ///
  /// def_API('Z3_fixedpoint_set_params', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(PARAMS)))
  void fixedpoint_set_params(
    Z3_context c,
    Z3_fixedpoint f,
    Z3_params p,
  ) {
    return _fixedpoint_set_params(
      c,
      f,
      p,
    );
  }

  late final _fixedpoint_set_paramsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_fixedpoint,
              Z3_params)>>('Z3_fixedpoint_set_params');
  late final _fixedpoint_set_params = _fixedpoint_set_paramsPtr
      .asFunction<void Function(Z3_context, Z3_fixedpoint, Z3_params)>();

  /// \brief Return a string describing all fixedpoint available parameters.
  ///
  /// \sa Z3_fixedpoint_get_param_descrs
  /// \sa Z3_fixedpoint_set_params
  ///
  /// def_API('Z3_fixedpoint_get_help', STRING, (_in(CONTEXT), _in(FIXEDPOINT)))
  Z3_string fixedpoint_get_help(
    Z3_context c,
    Z3_fixedpoint f,
  ) {
    return _fixedpoint_get_help(
      c,
      f,
    );
  }

  late final _fixedpoint_get_helpPtr = _lookup<
          ffi.NativeFunction<Z3_string Function(Z3_context, Z3_fixedpoint)>>(
      'Z3_fixedpoint_get_help');
  late final _fixedpoint_get_help = _fixedpoint_get_helpPtr
      .asFunction<Z3_string Function(Z3_context, Z3_fixedpoint)>();

  /// \brief Return the parameter description set for the given fixedpoint object.
  ///
  /// \sa Z3_fixedpoint_get_help
  /// \sa Z3_fixedpoint_set_params
  ///
  /// def_API('Z3_fixedpoint_get_param_descrs', PARAM_DESCRS, (_in(CONTEXT), _in(FIXEDPOINT)))
  Z3_param_descrs fixedpoint_get_param_descrs(
    Z3_context c,
    Z3_fixedpoint f,
  ) {
    return _fixedpoint_get_param_descrs(
      c,
      f,
    );
  }

  late final _fixedpoint_get_param_descrsPtr = _lookup<
          ffi
          .NativeFunction<Z3_param_descrs Function(Z3_context, Z3_fixedpoint)>>(
      'Z3_fixedpoint_get_param_descrs');
  late final _fixedpoint_get_param_descrs = _fixedpoint_get_param_descrsPtr
      .asFunction<Z3_param_descrs Function(Z3_context, Z3_fixedpoint)>();

  /// \brief Print the current rules and background axioms as a string.
  /// \param c - context.
  /// \param f - fixedpoint context.
  /// \param num_queries - number of additional queries to print.
  /// \param queries - additional queries.
  ///
  /// \sa Z3_fixedpoint_from_file
  /// \sa Z3_fixedpoint_from_string
  ///
  /// def_API('Z3_fixedpoint_to_string', STRING, (_in(CONTEXT), _in(FIXEDPOINT), _in(UINT), _in_array(2, AST)))
  Z3_string fixedpoint_to_string(
    Z3_context c,
    Z3_fixedpoint f,
    int num_queries,
    ffi.Pointer<Z3_ast> queries,
  ) {
    return _fixedpoint_to_string(
      c,
      f,
      num_queries,
      queries,
    );
  }

  late final _fixedpoint_to_stringPtr = _lookup<
      ffi.NativeFunction<
          Z3_string Function(Z3_context, Z3_fixedpoint, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_fixedpoint_to_string');
  late final _fixedpoint_to_string = _fixedpoint_to_stringPtr.asFunction<
      Z3_string Function(
          Z3_context, Z3_fixedpoint, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Parse an SMT-LIB2 string with fixedpoint rules.
  /// Add the rules to the current fixedpoint context.
  /// Return the set of queries in the string.
  ///
  /// \param c - context.
  /// \param f - fixedpoint context.
  /// \param s - string containing SMT2 specification.
  ///
  /// \sa Z3_fixedpoint_from_file
  /// \sa Z3_fixedpoint_to_string
  ///
  /// def_API('Z3_fixedpoint_from_string', AST_VECTOR, (_in(CONTEXT), _in(FIXEDPOINT), _in(STRING)))
  Z3_ast_vector fixedpoint_from_string(
    Z3_context c,
    Z3_fixedpoint f,
    Z3_string s,
  ) {
    return _fixedpoint_from_string(
      c,
      f,
      s,
    );
  }

  late final _fixedpoint_from_stringPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast_vector Function(Z3_context, Z3_fixedpoint,
              Z3_string)>>('Z3_fixedpoint_from_string');
  late final _fixedpoint_from_string = _fixedpoint_from_stringPtr.asFunction<
      Z3_ast_vector Function(Z3_context, Z3_fixedpoint, Z3_string)>();

  /// \brief Parse an SMT-LIB2 file with fixedpoint rules.
  /// Add the rules to the current fixedpoint context.
  /// Return the set of queries in the file.
  ///
  /// \param c - context.
  /// \param f - fixedpoint context.
  /// \param s - path to file containing SMT2 specification.
  ///
  /// \sa Z3_fixedpoint_from_string
  /// \sa Z3_fixedpoint_to_string
  ///
  /// def_API('Z3_fixedpoint_from_file', AST_VECTOR, (_in(CONTEXT), _in(FIXEDPOINT), _in(STRING)))
  Z3_ast_vector fixedpoint_from_file(
    Z3_context c,
    Z3_fixedpoint f,
    Z3_string s,
  ) {
    return _fixedpoint_from_file(
      c,
      f,
      s,
    );
  }

  late final _fixedpoint_from_filePtr = _lookup<
      ffi.NativeFunction<
          Z3_ast_vector Function(Z3_context, Z3_fixedpoint,
              Z3_string)>>('Z3_fixedpoint_from_file');
  late final _fixedpoint_from_file = _fixedpoint_from_filePtr.asFunction<
      Z3_ast_vector Function(Z3_context, Z3_fixedpoint, Z3_string)>();

  /// \brief Initialize the context with a user-defined state.
  void fixedpoint_init(
    Z3_context c,
    Z3_fixedpoint d,
    ffi.Pointer<ffi.Void> state,
  ) {
    return _fixedpoint_init(
      c,
      d,
      state,
    );
  }

  late final _fixedpoint_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_fixedpoint,
              ffi.Pointer<ffi.Void>)>>('Z3_fixedpoint_init');
  late final _fixedpoint_init = _fixedpoint_initPtr.asFunction<
      void Function(Z3_context, Z3_fixedpoint, ffi.Pointer<ffi.Void>)>();

  /// \brief Register a callback to destructive updates.
  ///
  /// Registers are identified with terms encoded as fresh constants,
  void fixedpoint_set_reduce_assign_callback(
    Z3_context c,
    Z3_fixedpoint d,
    ffi.Pointer<Z3_fixedpoint_reduce_assign_callback_fptr> cb,
  ) {
    return _fixedpoint_set_reduce_assign_callback(
      c,
      d,
      cb,
    );
  }

  late final _fixedpoint_set_reduce_assign_callbackPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(Z3_context, Z3_fixedpoint,
                  ffi.Pointer<Z3_fixedpoint_reduce_assign_callback_fptr>)>>(
      'Z3_fixedpoint_set_reduce_assign_callback');
  late final _fixedpoint_set_reduce_assign_callback =
      _fixedpoint_set_reduce_assign_callbackPtr.asFunction<
          void Function(Z3_context, Z3_fixedpoint,
              ffi.Pointer<Z3_fixedpoint_reduce_assign_callback_fptr>)>();

  /// \brief Register a callback for building terms based on the relational operators.
  void fixedpoint_set_reduce_app_callback(
    Z3_context c,
    Z3_fixedpoint d,
    ffi.Pointer<Z3_fixedpoint_reduce_app_callback_fptr> cb,
  ) {
    return _fixedpoint_set_reduce_app_callback(
      c,
      d,
      cb,
    );
  }

  late final _fixedpoint_set_reduce_app_callbackPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(Z3_context, Z3_fixedpoint,
                  ffi.Pointer<Z3_fixedpoint_reduce_app_callback_fptr>)>>(
      'Z3_fixedpoint_set_reduce_app_callback');
  late final _fixedpoint_set_reduce_app_callback =
      _fixedpoint_set_reduce_app_callbackPtr.asFunction<
          void Function(Z3_context, Z3_fixedpoint,
              ffi.Pointer<Z3_fixedpoint_reduce_app_callback_fptr>)>();

  /// \brief set export callback for lemmas
  void fixedpoint_add_callback(
    Z3_context ctx,
    Z3_fixedpoint f,
    ffi.Pointer<ffi.Void> state,
    Z3_fixedpoint_new_lemma_eh new_lemma_eh,
    Z3_fixedpoint_predecessor_eh predecessor_eh,
    Z3_fixedpoint_unfold_eh unfold_eh,
  ) {
    return _fixedpoint_add_callback(
      ctx,
      f,
      state,
      new_lemma_eh,
      predecessor_eh,
      unfold_eh,
    );
  }

  late final _fixedpoint_add_callbackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context,
              Z3_fixedpoint,
              ffi.Pointer<ffi.Void>,
              Z3_fixedpoint_new_lemma_eh,
              Z3_fixedpoint_predecessor_eh,
              Z3_fixedpoint_unfold_eh)>>('Z3_fixedpoint_add_callback');
  late final _fixedpoint_add_callback = _fixedpoint_add_callbackPtr.asFunction<
      void Function(
          Z3_context,
          Z3_fixedpoint,
          ffi.Pointer<ffi.Void>,
          Z3_fixedpoint_new_lemma_eh,
          Z3_fixedpoint_predecessor_eh,
          Z3_fixedpoint_unfold_eh)>();

  void fixedpoint_add_constraint(
    Z3_context c,
    Z3_fixedpoint d,
    Z3_ast e,
    int lvl,
  ) {
    return _fixedpoint_add_constraint(
      c,
      d,
      e,
      lvl,
    );
  }

  late final _fixedpoint_add_constraintPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_fixedpoint, Z3_ast,
              ffi.UnsignedInt)>>('Z3_fixedpoint_add_constraint');
  late final _fixedpoint_add_constraint = _fixedpoint_add_constraintPtr
      .asFunction<void Function(Z3_context, Z3_fixedpoint, Z3_ast, int)>();

  /// @name Optimization facilities */
  /// /**@{*/
  /// /**
  /// \brief Create a new optimize context.
  ///
  /// \remark User must use #Z3_optimize_inc_ref and #Z3_optimize_dec_ref to manage optimize objects.
  /// Even if the context was created using #Z3_mk_context instead of #Z3_mk_context_rc.
  ///
  /// def_API('Z3_mk_optimize', OPTIMIZE, (_in(CONTEXT), ))
  Z3_optimize mk_optimize(
    Z3_context c,
  ) {
    return _mk_optimize(
      c,
    );
  }

  late final _mk_optimizePtr =
      _lookup<ffi.NativeFunction<Z3_optimize Function(Z3_context)>>(
          'Z3_mk_optimize');
  late final _mk_optimize =
      _mk_optimizePtr.asFunction<Z3_optimize Function(Z3_context)>();

  /// \brief Increment the reference counter of the given optimize context
  ///
  /// def_API('Z3_optimize_inc_ref', VOID, (_in(CONTEXT), _in(OPTIMIZE)))
  void optimize_inc_ref(
    Z3_context c,
    Z3_optimize d,
  ) {
    return _optimize_inc_ref(
      c,
      d,
    );
  }

  late final _optimize_inc_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_optimize)>>(
          'Z3_optimize_inc_ref');
  late final _optimize_inc_ref =
      _optimize_inc_refPtr.asFunction<void Function(Z3_context, Z3_optimize)>();

  /// \brief Decrement the reference counter of the given optimize context.
  ///
  /// def_API('Z3_optimize_dec_ref', VOID, (_in(CONTEXT), _in(OPTIMIZE)))
  void optimize_dec_ref(
    Z3_context c,
    Z3_optimize d,
  ) {
    return _optimize_dec_ref(
      c,
      d,
    );
  }

  late final _optimize_dec_refPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_optimize)>>(
          'Z3_optimize_dec_ref');
  late final _optimize_dec_ref =
      _optimize_dec_refPtr.asFunction<void Function(Z3_context, Z3_optimize)>();

  /// \brief Assert hard constraint to the optimization context.
  ///
  /// \sa Z3_optimize_assert_soft
  /// \sa Z3_optimize_assert_and_track
  ///
  /// def_API('Z3_optimize_assert', VOID, (_in(CONTEXT), _in(OPTIMIZE), _in(AST)))
  void optimize_assert(
    Z3_context c,
    Z3_optimize o,
    Z3_ast a,
  ) {
    return _optimize_assert(
      c,
      o,
      a,
    );
  }

  late final _optimize_assertPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(Z3_context, Z3_optimize, Z3_ast)>>(
      'Z3_optimize_assert');
  late final _optimize_assert = _optimize_assertPtr
      .asFunction<void Function(Z3_context, Z3_optimize, Z3_ast)>();

  /// \brief Assert tracked hard constraint to the optimization context.
  ///
  /// \sa Z3_optimize_assert
  /// \sa Z3_optimize_assert_soft
  ///
  /// def_API('Z3_optimize_assert_and_track', VOID, (_in(CONTEXT), _in(OPTIMIZE), _in(AST), _in(AST)))
  void optimize_assert_and_track(
    Z3_context c,
    Z3_optimize o,
    Z3_ast a,
    Z3_ast t,
  ) {
    return _optimize_assert_and_track(
      c,
      o,
      a,
      t,
    );
  }

  late final _optimize_assert_and_trackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_optimize, Z3_ast,
              Z3_ast)>>('Z3_optimize_assert_and_track');
  late final _optimize_assert_and_track = _optimize_assert_and_trackPtr
      .asFunction<void Function(Z3_context, Z3_optimize, Z3_ast, Z3_ast)>();

  /// \brief Assert soft constraint to the optimization context.
  /// \param c - context
  /// \param o - optimization context
  /// \param a - formula
  /// \param weight - a penalty for violating soft constraint. Negative weights convert into rewards.
  /// \param id - optional identifier to group soft constraints
  ///
  /// \sa Z3_optimize_assert
  /// \sa Z3_optimize_assert_and_track
  ///
  /// def_API('Z3_optimize_assert_soft', UINT, (_in(CONTEXT), _in(OPTIMIZE), _in(AST), _in(STRING), _in(SYMBOL)))
  int optimize_assert_soft(
    Z3_context c,
    Z3_optimize o,
    Z3_ast a,
    Z3_string weight,
    Z3_symbol id,
  ) {
    return _optimize_assert_soft(
      c,
      o,
      a,
      weight,
      id,
    );
  }

  late final _optimize_assert_softPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(Z3_context, Z3_optimize, Z3_ast, Z3_string,
              Z3_symbol)>>('Z3_optimize_assert_soft');
  late final _optimize_assert_soft = _optimize_assert_softPtr.asFunction<
      int Function(Z3_context, Z3_optimize, Z3_ast, Z3_string, Z3_symbol)>();

  /// \brief Add a maximization constraint.
  /// \param c - context
  /// \param o - optimization context
  /// \param t - arithmetical term
  ///
  /// \sa Z3_optimize_minimize
  ///
  /// def_API('Z3_optimize_maximize', UINT, (_in(CONTEXT), _in(OPTIMIZE), _in(AST)))
  int optimize_maximize(
    Z3_context c,
    Z3_optimize o,
    Z3_ast t,
  ) {
    return _optimize_maximize(
      c,
      o,
      t,
    );
  }

  late final _optimize_maximizePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              Z3_context, Z3_optimize, Z3_ast)>>('Z3_optimize_maximize');
  late final _optimize_maximize = _optimize_maximizePtr
      .asFunction<int Function(Z3_context, Z3_optimize, Z3_ast)>();

  /// \brief Add a minimization constraint.
  /// \param c - context
  /// \param o - optimization context
  /// \param t - arithmetical term
  ///
  /// \sa Z3_optimize_maximize
  ///
  /// def_API('Z3_optimize_minimize', UINT, (_in(CONTEXT), _in(OPTIMIZE), _in(AST)))
  int optimize_minimize(
    Z3_context c,
    Z3_optimize o,
    Z3_ast t,
  ) {
    return _optimize_minimize(
      c,
      o,
      t,
    );
  }

  late final _optimize_minimizePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              Z3_context, Z3_optimize, Z3_ast)>>('Z3_optimize_minimize');
  late final _optimize_minimize = _optimize_minimizePtr
      .asFunction<int Function(Z3_context, Z3_optimize, Z3_ast)>();

  /// \brief Create a backtracking point.
  ///
  /// The optimize solver contains a set of rules, added facts and assertions.
  /// The set of rules, facts and assertions are restored upon calling #Z3_optimize_pop.
  ///
  /// \sa Z3_optimize_pop
  ///
  /// def_API('Z3_optimize_push', VOID, (_in(CONTEXT), _in(OPTIMIZE)))
  void optimize_push(
    Z3_context c,
    Z3_optimize d,
  ) {
    return _optimize_push(
      c,
      d,
    );
  }

  late final _optimize_pushPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_optimize)>>(
          'Z3_optimize_push');
  late final _optimize_push =
      _optimize_pushPtr.asFunction<void Function(Z3_context, Z3_optimize)>();

  /// \brief Backtrack one level.
  ///
  /// \sa Z3_optimize_push
  ///
  /// \pre The number of calls to pop cannot exceed calls to push.
  ///
  /// def_API('Z3_optimize_pop', VOID, (_in(CONTEXT), _in(OPTIMIZE)))
  void optimize_pop(
    Z3_context c,
    Z3_optimize d,
  ) {
    return _optimize_pop(
      c,
      d,
    );
  }

  late final _optimize_popPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(Z3_context, Z3_optimize)>>(
          'Z3_optimize_pop');
  late final _optimize_pop =
      _optimize_popPtr.asFunction<void Function(Z3_context, Z3_optimize)>();

  /// \brief Check consistency and produce optimal values.
  /// \param c - context
  /// \param o - optimization context
  /// \param num_assumptions - number of additional assumptions
  /// \param assumptions - the additional assumptions
  ///
  /// \sa Z3_optimize_get_reason_unknown
  /// \sa Z3_optimize_get_model
  /// \sa Z3_optimize_get_statistics
  /// \sa Z3_optimize_get_unsat_core
  ///
  /// def_API('Z3_optimize_check', LBOOL, (_in(CONTEXT), _in(OPTIMIZE), _in(UINT), _in_array(2, AST)))
  int optimize_check(
    Z3_context c,
    Z3_optimize o,
    int num_assumptions,
    ffi.Pointer<Z3_ast> assumptions,
  ) {
    return _optimize_check(
      c,
      o,
      num_assumptions,
      assumptions,
    );
  }

  late final _optimize_checkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(Z3_context, Z3_optimize, ffi.UnsignedInt,
              ffi.Pointer<Z3_ast>)>>('Z3_optimize_check');
  late final _optimize_check = _optimize_checkPtr.asFunction<
      int Function(Z3_context, Z3_optimize, int, ffi.Pointer<Z3_ast>)>();

  /// \brief Retrieve a string that describes the last status returned by #Z3_optimize_check.
  ///
  /// Use this method when #Z3_optimize_check returns \c Z3_L_UNDEF.
  ///
  /// def_API('Z3_optimize_get_reason_unknown', STRING, (_in(CONTEXT), _in(OPTIMIZE) ))
  Z3_string optimize_get_reason_unknown(
    Z3_context c,
    Z3_optimize d,
  ) {
    return _optimize_get_reason_unknown(
      c,
      d,
    );
  }

  late final _optimize_get_reason_unknownPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_optimize)>>(
          'Z3_optimize_get_reason_unknown');
  late final _optimize_get_reason_unknown = _optimize_get_reason_unknownPtr
      .asFunction<Z3_string Function(Z3_context, Z3_optimize)>();

  /// \brief Retrieve the model for the last #Z3_optimize_check
  ///
  /// The error handler is invoked if a model is not available because
  /// the commands above were not invoked for the given optimization
  /// solver, or if the result was \c Z3_L_FALSE.
  ///
  /// def_API('Z3_optimize_get_model', MODEL, (_in(CONTEXT), _in(OPTIMIZE)))
  Z3_model optimize_get_model(
    Z3_context c,
    Z3_optimize o,
  ) {
    return _optimize_get_model(
      c,
      o,
    );
  }

  late final _optimize_get_modelPtr =
      _lookup<ffi.NativeFunction<Z3_model Function(Z3_context, Z3_optimize)>>(
          'Z3_optimize_get_model');
  late final _optimize_get_model = _optimize_get_modelPtr
      .asFunction<Z3_model Function(Z3_context, Z3_optimize)>();

  /// \brief Retrieve the unsat core for the last #Z3_optimize_check
  /// The unsat core is a subset of the assumptions \c a.
  ///
  /// def_API('Z3_optimize_get_unsat_core', AST_VECTOR, (_in(CONTEXT), _in(OPTIMIZE)))
  Z3_ast_vector optimize_get_unsat_core(
    Z3_context c,
    Z3_optimize o,
  ) {
    return _optimize_get_unsat_core(
      c,
      o,
    );
  }

  late final _optimize_get_unsat_corePtr = _lookup<
          ffi.NativeFunction<Z3_ast_vector Function(Z3_context, Z3_optimize)>>(
      'Z3_optimize_get_unsat_core');
  late final _optimize_get_unsat_core = _optimize_get_unsat_corePtr
      .asFunction<Z3_ast_vector Function(Z3_context, Z3_optimize)>();

  /// \brief Set parameters on optimization context.
  ///
  /// \param c - context
  /// \param o - optimization context
  /// \param p - parameters
  ///
  /// \sa Z3_optimize_get_help
  /// \sa Z3_optimize_get_param_descrs
  ///
  /// def_API('Z3_optimize_set_params', VOID, (_in(CONTEXT), _in(OPTIMIZE), _in(PARAMS)))
  void optimize_set_params(
    Z3_context c,
    Z3_optimize o,
    Z3_params p,
  ) {
    return _optimize_set_params(
      c,
      o,
      p,
    );
  }

  late final _optimize_set_paramsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context, Z3_optimize, Z3_params)>>('Z3_optimize_set_params');
  late final _optimize_set_params = _optimize_set_paramsPtr
      .asFunction<void Function(Z3_context, Z3_optimize, Z3_params)>();

  /// \brief Return the parameter description set for the given optimize object.
  ///
  /// \param c - context
  /// \param o - optimization context
  ///
  /// \sa Z3_optimize_get_help
  /// \sa Z3_optimize_set_params
  ///
  /// def_API('Z3_optimize_get_param_descrs', PARAM_DESCRS, (_in(CONTEXT), _in(OPTIMIZE)))
  Z3_param_descrs optimize_get_param_descrs(
    Z3_context c,
    Z3_optimize o,
  ) {
    return _optimize_get_param_descrs(
      c,
      o,
    );
  }

  late final _optimize_get_param_descrsPtr = _lookup<
          ffi
          .NativeFunction<Z3_param_descrs Function(Z3_context, Z3_optimize)>>(
      'Z3_optimize_get_param_descrs');
  late final _optimize_get_param_descrs = _optimize_get_param_descrsPtr
      .asFunction<Z3_param_descrs Function(Z3_context, Z3_optimize)>();

  /// \brief Retrieve lower bound value or approximation for the i'th optimization objective.
  ///
  /// \param c - context
  /// \param o - optimization context
  /// \param idx - index of optimization objective
  ///
  /// \sa Z3_optimize_get_upper
  /// \sa Z3_optimize_get_lower_as_vector
  /// \sa Z3_optimize_get_upper_as_vector
  ///
  /// def_API('Z3_optimize_get_lower', AST, (_in(CONTEXT), _in(OPTIMIZE), _in(UINT)))
  Z3_ast optimize_get_lower(
    Z3_context c,
    Z3_optimize o,
    int idx,
  ) {
    return _optimize_get_lower(
      c,
      o,
      idx,
    );
  }

  late final _optimize_get_lowerPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_optimize,
              ffi.UnsignedInt)>>('Z3_optimize_get_lower');
  late final _optimize_get_lower = _optimize_get_lowerPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_optimize, int)>();

  /// \brief Retrieve upper bound value or approximation for the i'th optimization objective.
  ///
  /// \param c - context
  /// \param o - optimization context
  /// \param idx - index of optimization objective
  ///
  /// \sa Z3_optimize_get_lower
  /// \sa Z3_optimize_get_lower_as_vector
  /// \sa Z3_optimize_get_upper_as_vector
  ///
  /// def_API('Z3_optimize_get_upper', AST, (_in(CONTEXT), _in(OPTIMIZE), _in(UINT)))
  Z3_ast optimize_get_upper(
    Z3_context c,
    Z3_optimize o,
    int idx,
  ) {
    return _optimize_get_upper(
      c,
      o,
      idx,
    );
  }

  late final _optimize_get_upperPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_optimize,
              ffi.UnsignedInt)>>('Z3_optimize_get_upper');
  late final _optimize_get_upper = _optimize_get_upperPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_optimize, int)>();

  /// \brief Retrieve lower bound value or approximation for the i'th optimization objective.
  /// The returned vector is of length 3. It always contains numerals.
  /// The three numerals are coefficients \c a, \c b, \c c and encode the result of
  /// #Z3_optimize_get_lower \ccode{a * infinity + b + c * epsilon}.
  ///
  /// \param c - context
  /// \param o - optimization context
  /// \param idx - index of optimization objective
  ///
  /// \sa Z3_optimize_get_lower
  /// \sa Z3_optimize_get_upper
  /// \sa Z3_optimize_get_upper_as_vector
  ///
  /// def_API('Z3_optimize_get_lower_as_vector', AST_VECTOR, (_in(CONTEXT), _in(OPTIMIZE), _in(UINT)))
  Z3_ast_vector optimize_get_lower_as_vector(
    Z3_context c,
    Z3_optimize o,
    int idx,
  ) {
    return _optimize_get_lower_as_vector(
      c,
      o,
      idx,
    );
  }

  late final _optimize_get_lower_as_vectorPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast_vector Function(Z3_context, Z3_optimize,
              ffi.UnsignedInt)>>('Z3_optimize_get_lower_as_vector');
  late final _optimize_get_lower_as_vector = _optimize_get_lower_as_vectorPtr
      .asFunction<Z3_ast_vector Function(Z3_context, Z3_optimize, int)>();

  /// \brief Retrieve upper bound value or approximation for the i'th optimization objective.
  ///
  /// \param c - context
  /// \param o - optimization context
  /// \param idx - index of optimization objective
  ///
  /// \sa Z3_optimize_get_lower
  /// \sa Z3_optimize_get_upper
  /// \sa Z3_optimize_get_lower_as_vector
  ///
  /// def_API('Z3_optimize_get_upper_as_vector', AST_VECTOR, (_in(CONTEXT), _in(OPTIMIZE), _in(UINT)))
  Z3_ast_vector optimize_get_upper_as_vector(
    Z3_context c,
    Z3_optimize o,
    int idx,
  ) {
    return _optimize_get_upper_as_vector(
      c,
      o,
      idx,
    );
  }

  late final _optimize_get_upper_as_vectorPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast_vector Function(Z3_context, Z3_optimize,
              ffi.UnsignedInt)>>('Z3_optimize_get_upper_as_vector');
  late final _optimize_get_upper_as_vector = _optimize_get_upper_as_vectorPtr
      .asFunction<Z3_ast_vector Function(Z3_context, Z3_optimize, int)>();

  /// \brief Print the current context as a string.
  /// \param c - context.
  /// \param o - optimization context.
  ///
  /// \sa Z3_optimize_from_file
  /// \sa Z3_optimize_from_string
  ///
  /// def_API('Z3_optimize_to_string', STRING, (_in(CONTEXT), _in(OPTIMIZE)))
  Z3_string optimize_to_string(
    Z3_context c,
    Z3_optimize o,
  ) {
    return _optimize_to_string(
      c,
      o,
    );
  }

  late final _optimize_to_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_optimize)>>(
          'Z3_optimize_to_string');
  late final _optimize_to_string = _optimize_to_stringPtr
      .asFunction<Z3_string Function(Z3_context, Z3_optimize)>();

  /// \brief Parse an SMT-LIB2 string with assertions,
  /// soft constraints and optimization objectives.
  /// Add the parsed constraints and objectives to the optimization context.
  ///
  /// \param c - context.
  /// \param o - optimize context.
  /// \param s - string containing SMT2 specification.
  ///
  /// \sa Z3_optimize_from_file
  /// \sa Z3_optimize_to_string
  ///
  /// def_API('Z3_optimize_from_string', VOID, (_in(CONTEXT), _in(OPTIMIZE), _in(STRING)))
  void optimize_from_string(
    Z3_context c,
    Z3_optimize o,
    Z3_string s,
  ) {
    return _optimize_from_string(
      c,
      o,
      s,
    );
  }

  late final _optimize_from_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context, Z3_optimize, Z3_string)>>('Z3_optimize_from_string');
  late final _optimize_from_string = _optimize_from_stringPtr
      .asFunction<void Function(Z3_context, Z3_optimize, Z3_string)>();

  /// \brief Parse an SMT-LIB2 file with assertions,
  /// soft constraints and optimization objectives.
  /// Add the parsed constraints and objectives to the optimization context.
  ///
  /// \param c - context.
  /// \param o - optimize context.
  /// \param s - path to file containing SMT2 specification.
  ///
  /// \sa Z3_optimize_from_string
  /// \sa Z3_optimize_to_string
  ///
  /// def_API('Z3_optimize_from_file', VOID, (_in(CONTEXT), _in(OPTIMIZE), _in(STRING)))
  void optimize_from_file(
    Z3_context c,
    Z3_optimize o,
    Z3_string s,
  ) {
    return _optimize_from_file(
      c,
      o,
      s,
    );
  }

  late final _optimize_from_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context, Z3_optimize, Z3_string)>>('Z3_optimize_from_file');
  late final _optimize_from_file = _optimize_from_filePtr
      .asFunction<void Function(Z3_context, Z3_optimize, Z3_string)>();

  /// \brief Return a string containing a description of parameters accepted by optimize.
  ///
  /// \sa Z3_optimize_get_param_descrs
  /// \sa Z3_optimize_set_params
  ///
  /// def_API('Z3_optimize_get_help', STRING, (_in(CONTEXT), _in(OPTIMIZE)))
  Z3_string optimize_get_help(
    Z3_context c,
    Z3_optimize t,
  ) {
    return _optimize_get_help(
      c,
      t,
    );
  }

  late final _optimize_get_helpPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_optimize)>>(
          'Z3_optimize_get_help');
  late final _optimize_get_help = _optimize_get_helpPtr
      .asFunction<Z3_string Function(Z3_context, Z3_optimize)>();

  /// \brief Retrieve statistics information from the last call to #Z3_optimize_check
  ///
  /// def_API('Z3_optimize_get_statistics', STATS, (_in(CONTEXT), _in(OPTIMIZE)))
  Z3_stats optimize_get_statistics(
    Z3_context c,
    Z3_optimize d,
  ) {
    return _optimize_get_statistics(
      c,
      d,
    );
  }

  late final _optimize_get_statisticsPtr =
      _lookup<ffi.NativeFunction<Z3_stats Function(Z3_context, Z3_optimize)>>(
          'Z3_optimize_get_statistics');
  late final _optimize_get_statistics = _optimize_get_statisticsPtr
      .asFunction<Z3_stats Function(Z3_context, Z3_optimize)>();

  /// \brief Return the set of asserted formulas on the optimization context.
  ///
  /// def_API('Z3_optimize_get_assertions', AST_VECTOR, (_in(CONTEXT), _in(OPTIMIZE)))
  Z3_ast_vector optimize_get_assertions(
    Z3_context c,
    Z3_optimize o,
  ) {
    return _optimize_get_assertions(
      c,
      o,
    );
  }

  late final _optimize_get_assertionsPtr = _lookup<
          ffi.NativeFunction<Z3_ast_vector Function(Z3_context, Z3_optimize)>>(
      'Z3_optimize_get_assertions');
  late final _optimize_get_assertions = _optimize_get_assertionsPtr
      .asFunction<Z3_ast_vector Function(Z3_context, Z3_optimize)>();

  /// \brief Return objectives on the optimization context.
  /// If the objective function is a max-sat objective it is returned
  /// as a Pseudo-Boolean (minimization) sum of the form \ccode{(+ (if f1 w1 0) (if f2 w2 0) ...)}
  /// If the objective function is entered as a maximization objective, then return
  /// the corresponding minimization objective. In this way the resulting objective
  /// function is always returned as a minimization objective.
  ///
  /// def_API('Z3_optimize_get_objectives', AST_VECTOR, (_in(CONTEXT), _in(OPTIMIZE)))
  Z3_ast_vector optimize_get_objectives(
    Z3_context c,
    Z3_optimize o,
  ) {
    return _optimize_get_objectives(
      c,
      o,
    );
  }

  late final _optimize_get_objectivesPtr = _lookup<
          ffi.NativeFunction<Z3_ast_vector Function(Z3_context, Z3_optimize)>>(
      'Z3_optimize_get_objectives');
  late final _optimize_get_objectives = _optimize_get_objectivesPtr
      .asFunction<Z3_ast_vector Function(Z3_context, Z3_optimize)>();

  /// \brief register a model event handler for new models.
  void optimize_register_model_eh(
    Z3_context c,
    Z3_optimize o,
    Z3_model m,
    ffi.Pointer<ffi.Void> ctx,
    ffi.Pointer<Z3_model_eh> model_eh,
  ) {
    return _optimize_register_model_eh(
      c,
      o,
      m,
      ctx,
      model_eh,
    );
  }

  late final _optimize_register_model_ehPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              Z3_context,
              Z3_optimize,
              Z3_model,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<Z3_model_eh>)>>('Z3_optimize_register_model_eh');
  late final _optimize_register_model_eh =
      _optimize_register_model_ehPtr.asFunction<
          void Function(Z3_context, Z3_optimize, Z3_model,
              ffi.Pointer<ffi.Void>, ffi.Pointer<Z3_model_eh>)>();

  /// @name Floating-Point Arithmetic */
  /// /**@{*/
  /// /**
  /// \brief Create the RoundingMode sort.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_rounding_mode_sort', SORT, (_in(CONTEXT),))
  Z3_sort mk_fpa_rounding_mode_sort(
    Z3_context c,
  ) {
    return _mk_fpa_rounding_mode_sort(
      c,
    );
  }

  late final _mk_fpa_rounding_mode_sortPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context)>>(
          'Z3_mk_fpa_rounding_mode_sort');
  late final _mk_fpa_rounding_mode_sort =
      _mk_fpa_rounding_mode_sortPtr.asFunction<Z3_sort Function(Z3_context)>();

  /// \brief Create a numeral of RoundingMode sort which represents the NearestTiesToEven rounding mode.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_round_nearest_ties_to_even', AST, (_in(CONTEXT),))
  Z3_ast mk_fpa_round_nearest_ties_to_even(
    Z3_context c,
  ) {
    return _mk_fpa_round_nearest_ties_to_even(
      c,
    );
  }

  late final _mk_fpa_round_nearest_ties_to_evenPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context)>>(
          'Z3_mk_fpa_round_nearest_ties_to_even');
  late final _mk_fpa_round_nearest_ties_to_even =
      _mk_fpa_round_nearest_ties_to_evenPtr
          .asFunction<Z3_ast Function(Z3_context)>();

  /// \brief Create a numeral of RoundingMode sort which represents the NearestTiesToEven rounding mode.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_rne', AST, (_in(CONTEXT),))
  Z3_ast mk_fpa_rne(
    Z3_context c,
  ) {
    return _mk_fpa_rne(
      c,
    );
  }

  late final _mk_fpa_rnePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context)>>('Z3_mk_fpa_rne');
  late final _mk_fpa_rne =
      _mk_fpa_rnePtr.asFunction<Z3_ast Function(Z3_context)>();

  /// \brief Create a numeral of RoundingMode sort which represents the NearestTiesToAway rounding mode.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_round_nearest_ties_to_away', AST, (_in(CONTEXT),))
  Z3_ast mk_fpa_round_nearest_ties_to_away(
    Z3_context c,
  ) {
    return _mk_fpa_round_nearest_ties_to_away(
      c,
    );
  }

  late final _mk_fpa_round_nearest_ties_to_awayPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context)>>(
          'Z3_mk_fpa_round_nearest_ties_to_away');
  late final _mk_fpa_round_nearest_ties_to_away =
      _mk_fpa_round_nearest_ties_to_awayPtr
          .asFunction<Z3_ast Function(Z3_context)>();

  /// \brief Create a numeral of RoundingMode sort which represents the NearestTiesToAway rounding mode.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_rna', AST, (_in(CONTEXT),))
  Z3_ast mk_fpa_rna(
    Z3_context c,
  ) {
    return _mk_fpa_rna(
      c,
    );
  }

  late final _mk_fpa_rnaPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context)>>('Z3_mk_fpa_rna');
  late final _mk_fpa_rna =
      _mk_fpa_rnaPtr.asFunction<Z3_ast Function(Z3_context)>();

  /// \brief Create a numeral of RoundingMode sort which represents the TowardPositive rounding mode.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_round_toward_positive', AST, (_in(CONTEXT),))
  Z3_ast mk_fpa_round_toward_positive(
    Z3_context c,
  ) {
    return _mk_fpa_round_toward_positive(
      c,
    );
  }

  late final _mk_fpa_round_toward_positivePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context)>>(
          'Z3_mk_fpa_round_toward_positive');
  late final _mk_fpa_round_toward_positive = _mk_fpa_round_toward_positivePtr
      .asFunction<Z3_ast Function(Z3_context)>();

  /// \brief Create a numeral of RoundingMode sort which represents the TowardPositive rounding mode.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_rtp', AST, (_in(CONTEXT),))
  Z3_ast mk_fpa_rtp(
    Z3_context c,
  ) {
    return _mk_fpa_rtp(
      c,
    );
  }

  late final _mk_fpa_rtpPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context)>>('Z3_mk_fpa_rtp');
  late final _mk_fpa_rtp =
      _mk_fpa_rtpPtr.asFunction<Z3_ast Function(Z3_context)>();

  /// \brief Create a numeral of RoundingMode sort which represents the TowardNegative rounding mode.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_round_toward_negative', AST, (_in(CONTEXT),))
  Z3_ast mk_fpa_round_toward_negative(
    Z3_context c,
  ) {
    return _mk_fpa_round_toward_negative(
      c,
    );
  }

  late final _mk_fpa_round_toward_negativePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context)>>(
          'Z3_mk_fpa_round_toward_negative');
  late final _mk_fpa_round_toward_negative = _mk_fpa_round_toward_negativePtr
      .asFunction<Z3_ast Function(Z3_context)>();

  /// \brief Create a numeral of RoundingMode sort which represents the TowardNegative rounding mode.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_rtn', AST, (_in(CONTEXT),))
  Z3_ast mk_fpa_rtn(
    Z3_context c,
  ) {
    return _mk_fpa_rtn(
      c,
    );
  }

  late final _mk_fpa_rtnPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context)>>('Z3_mk_fpa_rtn');
  late final _mk_fpa_rtn =
      _mk_fpa_rtnPtr.asFunction<Z3_ast Function(Z3_context)>();

  /// \brief Create a numeral of RoundingMode sort which represents the TowardZero rounding mode.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_round_toward_zero', AST, (_in(CONTEXT),))
  Z3_ast mk_fpa_round_toward_zero(
    Z3_context c,
  ) {
    return _mk_fpa_round_toward_zero(
      c,
    );
  }

  late final _mk_fpa_round_toward_zeroPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context)>>(
          'Z3_mk_fpa_round_toward_zero');
  late final _mk_fpa_round_toward_zero =
      _mk_fpa_round_toward_zeroPtr.asFunction<Z3_ast Function(Z3_context)>();

  /// \brief Create a numeral of RoundingMode sort which represents the TowardZero rounding mode.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_rtz', AST, (_in(CONTEXT),))
  Z3_ast mk_fpa_rtz(
    Z3_context c,
  ) {
    return _mk_fpa_rtz(
      c,
    );
  }

  late final _mk_fpa_rtzPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context)>>('Z3_mk_fpa_rtz');
  late final _mk_fpa_rtz =
      _mk_fpa_rtzPtr.asFunction<Z3_ast Function(Z3_context)>();

  /// \brief Create a FloatingPoint sort.
  ///
  /// \param c logical context
  /// \param ebits number of exponent bits
  /// \param sbits number of significand bits
  ///
  /// \remark \c ebits must be larger than 1 and \c sbits must be larger than 2.
  ///
  /// def_API('Z3_mk_fpa_sort', SORT, (_in(CONTEXT), _in(UINT), _in(UINT)))
  Z3_sort mk_fpa_sort(
    Z3_context c,
    int ebits,
    int sbits,
  ) {
    return _mk_fpa_sort(
      c,
      ebits,
      sbits,
    );
  }

  late final _mk_fpa_sortPtr = _lookup<
      ffi.NativeFunction<
          Z3_sort Function(
              Z3_context, ffi.UnsignedInt, ffi.UnsignedInt)>>('Z3_mk_fpa_sort');
  late final _mk_fpa_sort =
      _mk_fpa_sortPtr.asFunction<Z3_sort Function(Z3_context, int, int)>();

  /// \brief Create the half-precision (16-bit) FloatingPoint sort.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_sort_half', SORT, (_in(CONTEXT),))
  Z3_sort mk_fpa_sort_half(
    Z3_context c,
  ) {
    return _mk_fpa_sort_half(
      c,
    );
  }

  late final _mk_fpa_sort_halfPtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context)>>(
          'Z3_mk_fpa_sort_half');
  late final _mk_fpa_sort_half =
      _mk_fpa_sort_halfPtr.asFunction<Z3_sort Function(Z3_context)>();

  /// \brief Create the half-precision (16-bit) FloatingPoint sort.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_sort_16', SORT, (_in(CONTEXT),))
  Z3_sort mk_fpa_sort_16(
    Z3_context c,
  ) {
    return _mk_fpa_sort_16(
      c,
    );
  }

  late final _mk_fpa_sort_16Ptr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context)>>(
          'Z3_mk_fpa_sort_16');
  late final _mk_fpa_sort_16 =
      _mk_fpa_sort_16Ptr.asFunction<Z3_sort Function(Z3_context)>();

  /// \brief Create the single-precision (32-bit) FloatingPoint sort.
  ///
  /// \param c logical context.
  ///
  /// def_API('Z3_mk_fpa_sort_single', SORT, (_in(CONTEXT),))
  Z3_sort mk_fpa_sort_single(
    Z3_context c,
  ) {
    return _mk_fpa_sort_single(
      c,
    );
  }

  late final _mk_fpa_sort_singlePtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context)>>(
          'Z3_mk_fpa_sort_single');
  late final _mk_fpa_sort_single =
      _mk_fpa_sort_singlePtr.asFunction<Z3_sort Function(Z3_context)>();

  /// \brief Create the single-precision (32-bit) FloatingPoint sort.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_sort_32', SORT, (_in(CONTEXT),))
  Z3_sort mk_fpa_sort_32(
    Z3_context c,
  ) {
    return _mk_fpa_sort_32(
      c,
    );
  }

  late final _mk_fpa_sort_32Ptr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context)>>(
          'Z3_mk_fpa_sort_32');
  late final _mk_fpa_sort_32 =
      _mk_fpa_sort_32Ptr.asFunction<Z3_sort Function(Z3_context)>();

  /// \brief Create the double-precision (64-bit) FloatingPoint sort.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_sort_double', SORT, (_in(CONTEXT),))
  Z3_sort mk_fpa_sort_double(
    Z3_context c,
  ) {
    return _mk_fpa_sort_double(
      c,
    );
  }

  late final _mk_fpa_sort_doublePtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context)>>(
          'Z3_mk_fpa_sort_double');
  late final _mk_fpa_sort_double =
      _mk_fpa_sort_doublePtr.asFunction<Z3_sort Function(Z3_context)>();

  /// \brief Create the double-precision (64-bit) FloatingPoint sort.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_sort_64', SORT, (_in(CONTEXT),))
  Z3_sort mk_fpa_sort_64(
    Z3_context c,
  ) {
    return _mk_fpa_sort_64(
      c,
    );
  }

  late final _mk_fpa_sort_64Ptr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context)>>(
          'Z3_mk_fpa_sort_64');
  late final _mk_fpa_sort_64 =
      _mk_fpa_sort_64Ptr.asFunction<Z3_sort Function(Z3_context)>();

  /// \brief Create the quadruple-precision (128-bit) FloatingPoint sort.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_sort_quadruple', SORT, (_in(CONTEXT),))
  Z3_sort mk_fpa_sort_quadruple(
    Z3_context c,
  ) {
    return _mk_fpa_sort_quadruple(
      c,
    );
  }

  late final _mk_fpa_sort_quadruplePtr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context)>>(
          'Z3_mk_fpa_sort_quadruple');
  late final _mk_fpa_sort_quadruple =
      _mk_fpa_sort_quadruplePtr.asFunction<Z3_sort Function(Z3_context)>();

  /// \brief Create the quadruple-precision (128-bit) FloatingPoint sort.
  ///
  /// \param c logical context
  ///
  /// def_API('Z3_mk_fpa_sort_128', SORT, (_in(CONTEXT),))
  Z3_sort mk_fpa_sort_128(
    Z3_context c,
  ) {
    return _mk_fpa_sort_128(
      c,
    );
  }

  late final _mk_fpa_sort_128Ptr =
      _lookup<ffi.NativeFunction<Z3_sort Function(Z3_context)>>(
          'Z3_mk_fpa_sort_128');
  late final _mk_fpa_sort_128 =
      _mk_fpa_sort_128Ptr.asFunction<Z3_sort Function(Z3_context)>();

  /// \brief Create a floating-point NaN of sort \c s.
  ///
  /// \param c logical context
  /// \param s target sort
  ///
  /// \sa Z3_mk_fpa_inf
  /// \sa Z3_mk_fpa_zero
  ///
  /// def_API('Z3_mk_fpa_nan', AST, (_in(CONTEXT),_in(SORT)))
  Z3_ast mk_fpa_nan(
    Z3_context c,
    Z3_sort s,
  ) {
    return _mk_fpa_nan(
      c,
      s,
    );
  }

  late final _mk_fpa_nanPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_sort)>>(
          'Z3_mk_fpa_nan');
  late final _mk_fpa_nan =
      _mk_fpa_nanPtr.asFunction<Z3_ast Function(Z3_context, Z3_sort)>();

  /// \brief Create a floating-point infinity of sort \c s.
  ///
  /// \param c logical context
  /// \param s target sort
  /// \param negative indicates whether the result should be negative
  ///
  /// When \c negative is \c true, -oo will be generated instead of +oo.
  ///
  /// \sa Z3_mk_fpa_nan
  /// \sa Z3_mk_fpa_zero
  ///
  /// def_API('Z3_mk_fpa_inf', AST, (_in(CONTEXT),_in(SORT),_in(BOOL)))
  Z3_ast mk_fpa_inf(
    Z3_context c,
    Z3_sort s,
    bool negative,
  ) {
    return _mk_fpa_inf(
      c,
      s,
      negative,
    );
  }

  late final _mk_fpa_infPtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_sort, ffi.Bool)>>(
      'Z3_mk_fpa_inf');
  late final _mk_fpa_inf =
      _mk_fpa_infPtr.asFunction<Z3_ast Function(Z3_context, Z3_sort, bool)>();

  /// \brief Create a floating-point zero of sort \c s.
  ///
  /// \param c logical context
  /// \param s target sort
  /// \param negative indicates whether the result should be negative
  ///
  /// When \c negative is \c true, -zero will be generated instead of +zero.
  ///
  /// \sa Z3_mk_fpa_inf
  /// \sa Z3_mk_fpa_nan
  ///
  /// def_API('Z3_mk_fpa_zero', AST, (_in(CONTEXT),_in(SORT),_in(BOOL)))
  Z3_ast mk_fpa_zero(
    Z3_context c,
    Z3_sort s,
    bool negative,
  ) {
    return _mk_fpa_zero(
      c,
      s,
      negative,
    );
  }

  late final _mk_fpa_zeroPtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_sort, ffi.Bool)>>(
      'Z3_mk_fpa_zero');
  late final _mk_fpa_zero =
      _mk_fpa_zeroPtr.asFunction<Z3_ast Function(Z3_context, Z3_sort, bool)>();

  /// \brief Create an expression of FloatingPoint sort from three bit-vector expressions.
  ///
  /// This is the operator named `fp' in the SMT FP theory definition.
  /// Note that \c sgn is required to be a bit-vector of size 1. Significand and exponent
  /// are required to be longer than 1 and 2 respectively. The FloatingPoint sort
  /// of the resulting expression is automatically determined from the bit-vector sizes
  /// of the arguments. The exponent is assumed to be in IEEE-754 biased representation.
  ///
  /// \param c logical context
  /// \param sgn sign
  /// \param exp exponent
  /// \param sig significand
  ///
  /// \sa Z3_mk_fpa_numeral_double
  /// \sa Z3_mk_fpa_numeral_float
  /// \sa Z3_mk_fpa_numeral_int
  /// \sa Z3_mk_fpa_numeral_int_uint
  /// \sa Z3_mk_fpa_numeral_int64_uint64
  /// \sa Z3_mk_numeral
  ///
  /// def_API('Z3_mk_fpa_fp', AST, (_in(CONTEXT), _in(AST), _in(AST), _in(AST)))
  Z3_ast mk_fpa_fp(
    Z3_context c,
    Z3_ast sgn,
    Z3_ast exp,
    Z3_ast sig,
  ) {
    return _mk_fpa_fp(
      c,
      sgn,
      exp,
      sig,
    );
  }

  late final _mk_fpa_fpPtr = _lookup<
          ffi
          .NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>>(
      'Z3_mk_fpa_fp');
  late final _mk_fpa_fp = _mk_fpa_fpPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>();

  /// \brief Create a numeral of FloatingPoint sort from a float.
  ///
  /// This function is used to create numerals that fit in a float value.
  /// It is slightly faster than #Z3_mk_numeral since it is not necessary to parse a string.
  ///
  /// \param c logical context
  /// \param v value
  /// \param ty sort
  ///
  /// \c ty must be a FloatingPoint sort
  ///
  /// \sa Z3_mk_fpa_fp
  /// \sa Z3_mk_fpa_numeral_double
  /// \sa Z3_mk_fpa_numeral_int
  /// \sa Z3_mk_fpa_numeral_int_uint
  /// \sa Z3_mk_fpa_numeral_int64_uint64
  /// \sa Z3_mk_numeral
  ///
  /// def_API('Z3_mk_fpa_numeral_float', AST, (_in(CONTEXT), _in(FLOAT), _in(SORT)))
  Z3_ast mk_fpa_numeral_float(
    Z3_context c,
    double v,
    Z3_sort ty,
  ) {
    return _mk_fpa_numeral_float(
      c,
      v,
      ty,
    );
  }

  late final _mk_fpa_numeral_floatPtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, ffi.Float, Z3_sort)>>(
      'Z3_mk_fpa_numeral_float');
  late final _mk_fpa_numeral_float = _mk_fpa_numeral_floatPtr
      .asFunction<Z3_ast Function(Z3_context, double, Z3_sort)>();

  /// \brief Create a numeral of FloatingPoint sort from a double.
  ///
  /// This function is used to create numerals that fit in a double value.
  /// It is slightly faster than #Z3_mk_numeral since it is not necessary to parse a string.
  ///
  /// \param c logical context
  /// \param v value
  /// \param ty sort
  ///
  /// \c ty must be a FloatingPoint sort
  ///
  /// \sa Z3_mk_fpa_fp
  /// \sa Z3_mk_fpa_numeral_float
  /// \sa Z3_mk_fpa_numeral_int
  /// \sa Z3_mk_fpa_numeral_int_uint
  /// \sa Z3_mk_fpa_numeral_int64_uint64
  /// \sa Z3_mk_numeral
  ///
  /// def_API('Z3_mk_fpa_numeral_double', AST, (_in(CONTEXT), _in(DOUBLE), _in(SORT)))
  Z3_ast mk_fpa_numeral_double(
    Z3_context c,
    double v,
    Z3_sort ty,
  ) {
    return _mk_fpa_numeral_double(
      c,
      v,
      ty,
    );
  }

  late final _mk_fpa_numeral_doublePtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, ffi.Double, Z3_sort)>>(
      'Z3_mk_fpa_numeral_double');
  late final _mk_fpa_numeral_double = _mk_fpa_numeral_doublePtr
      .asFunction<Z3_ast Function(Z3_context, double, Z3_sort)>();

  /// \brief Create a numeral of FloatingPoint sort from a signed integer.
  ///
  /// \param c logical context
  /// \param v value
  /// \param ty result sort
  ///
  /// \c ty must be a FloatingPoint sort
  ///
  /// \sa Z3_mk_fpa_fp
  /// \sa Z3_mk_fpa_numeral_double
  /// \sa Z3_mk_fpa_numeral_float
  /// \sa Z3_mk_fpa_numeral_int_uint
  /// \sa Z3_mk_fpa_numeral_int64_uint64
  /// \sa Z3_mk_numeral
  ///
  /// def_API('Z3_mk_fpa_numeral_int', AST, (_in(CONTEXT), _in(INT), _in(SORT)))
  Z3_ast mk_fpa_numeral_int(
    Z3_context c,
    int v,
    Z3_sort ty,
  ) {
    return _mk_fpa_numeral_int(
      c,
      v,
      ty,
    );
  }

  late final _mk_fpa_numeral_intPtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, ffi.Int, Z3_sort)>>(
      'Z3_mk_fpa_numeral_int');
  late final _mk_fpa_numeral_int = _mk_fpa_numeral_intPtr
      .asFunction<Z3_ast Function(Z3_context, int, Z3_sort)>();

  /// \brief Create a numeral of FloatingPoint sort from a sign bit and two integers.
  ///
  /// \param c logical context
  /// \param sgn sign bit (true == negative)
  /// \param sig significand
  /// \param exp exponent
  /// \param ty result sort
  ///
  /// \c ty must be a FloatingPoint sort
  ///
  /// \sa Z3_mk_fpa_fp
  /// \sa Z3_mk_fpa_numeral_double
  /// \sa Z3_mk_fpa_numeral_float
  /// \sa Z3_mk_fpa_numeral_int
  /// \sa Z3_mk_fpa_numeral_int64_uint64
  /// \sa Z3_mk_numeral
  ///
  /// def_API('Z3_mk_fpa_numeral_int_uint', AST, (_in(CONTEXT), _in(BOOL), _in(INT), _in(UINT), _in(SORT)))
  Z3_ast mk_fpa_numeral_int_uint(
    Z3_context c,
    bool sgn,
    int exp,
    int sig,
    Z3_sort ty,
  ) {
    return _mk_fpa_numeral_int_uint(
      c,
      sgn,
      exp,
      sig,
      ty,
    );
  }

  late final _mk_fpa_numeral_int_uintPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.Bool, ffi.Int, ffi.UnsignedInt,
              Z3_sort)>>('Z3_mk_fpa_numeral_int_uint');
  late final _mk_fpa_numeral_int_uint = _mk_fpa_numeral_int_uintPtr
      .asFunction<Z3_ast Function(Z3_context, bool, int, int, Z3_sort)>();

  /// \brief Create a numeral of FloatingPoint sort from a sign bit and two 64-bit integers.
  ///
  /// \param c logical context
  /// \param sgn sign bit (true == negative)
  /// \param sig significand
  /// \param exp exponent
  /// \param ty result sort
  ///
  /// \c ty must be a FloatingPoint sort
  ///
  /// \sa Z3_mk_fpa_fp
  /// \sa Z3_mk_fpa_numeral_double
  /// \sa Z3_mk_fpa_numeral_float
  /// \sa Z3_mk_fpa_numeral_int
  /// \sa Z3_mk_fpa_numeral_int_uint
  /// \sa Z3_mk_numeral
  ///
  /// def_API('Z3_mk_fpa_numeral_int64_uint64', AST, (_in(CONTEXT), _in(BOOL), _in(INT64), _in(UINT64), _in(SORT)))
  Z3_ast mk_fpa_numeral_int64_uint64(
    Z3_context c,
    bool sgn,
    int exp,
    int sig,
    Z3_sort ty,
  ) {
    return _mk_fpa_numeral_int64_uint64(
      c,
      sgn,
      exp,
      sig,
      ty,
    );
  }

  late final _mk_fpa_numeral_int64_uint64Ptr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, ffi.Bool, ffi.Int64, ffi.Uint64,
              Z3_sort)>>('Z3_mk_fpa_numeral_int64_uint64');
  late final _mk_fpa_numeral_int64_uint64 = _mk_fpa_numeral_int64_uint64Ptr
      .asFunction<Z3_ast Function(Z3_context, bool, int, int, Z3_sort)>();

  /// \brief Floating-point absolute value
  ///
  /// \param c logical context
  /// \param t term of FloatingPoint sort
  ///
  /// def_API('Z3_mk_fpa_abs', AST, (_in(CONTEXT),_in(AST)))
  Z3_ast mk_fpa_abs(
    Z3_context c,
    Z3_ast t,
  ) {
    return _mk_fpa_abs(
      c,
      t,
    );
  }

  late final _mk_fpa_absPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_fpa_abs');
  late final _mk_fpa_abs =
      _mk_fpa_absPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Floating-point negation
  ///
  /// \param c logical context
  /// \param t term of FloatingPoint sort
  ///
  /// def_API('Z3_mk_fpa_neg', AST, (_in(CONTEXT),_in(AST)))
  Z3_ast mk_fpa_neg(
    Z3_context c,
    Z3_ast t,
  ) {
    return _mk_fpa_neg(
      c,
      t,
    );
  }

  late final _mk_fpa_negPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_fpa_neg');
  late final _mk_fpa_neg =
      _mk_fpa_negPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Floating-point addition
  ///
  /// \param c logical context
  /// \param rm term of RoundingMode sort
  /// \param t1 term of FloatingPoint sort
  /// \param t2 term of FloatingPoint sort
  ///
  /// \c rm must be of RoundingMode sort, \c t1 and \c t2 must have the same FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_add', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(AST)))
  Z3_ast mk_fpa_add(
    Z3_context c,
    Z3_ast rm,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_fpa_add(
      c,
      rm,
      t1,
      t2,
    );
  }

  late final _mk_fpa_addPtr = _lookup<
          ffi
          .NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>>(
      'Z3_mk_fpa_add');
  late final _mk_fpa_add = _mk_fpa_addPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>();

  /// \brief Floating-point subtraction
  ///
  /// \param c logical context
  /// \param rm term of RoundingMode sort
  /// \param t1 term of FloatingPoint sort
  /// \param t2 term of FloatingPoint sort
  ///
  /// \c rm must be of RoundingMode sort, \c t1 and \c t2 must have the same FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_sub', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(AST)))
  Z3_ast mk_fpa_sub(
    Z3_context c,
    Z3_ast rm,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_fpa_sub(
      c,
      rm,
      t1,
      t2,
    );
  }

  late final _mk_fpa_subPtr = _lookup<
          ffi
          .NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>>(
      'Z3_mk_fpa_sub');
  late final _mk_fpa_sub = _mk_fpa_subPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>();

  /// \brief Floating-point multiplication
  ///
  /// \param c logical context
  /// \param rm term of RoundingMode sort
  /// \param t1 term of FloatingPoint sort
  /// \param t2 term of FloatingPoint sort
  ///
  /// \c rm must be of RoundingMode sort, \c t1 and \c t2 must have the same FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_mul', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(AST)))
  Z3_ast mk_fpa_mul(
    Z3_context c,
    Z3_ast rm,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_fpa_mul(
      c,
      rm,
      t1,
      t2,
    );
  }

  late final _mk_fpa_mulPtr = _lookup<
          ffi
          .NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>>(
      'Z3_mk_fpa_mul');
  late final _mk_fpa_mul = _mk_fpa_mulPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>();

  /// \brief Floating-point division
  ///
  /// \param c logical context
  /// \param rm term of RoundingMode sort
  /// \param t1 term of FloatingPoint sort.
  /// \param t2 term of FloatingPoint sort
  ///
  /// The nodes \c rm must be of RoundingMode sort, \c t1 and \c t2 must have the same FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_div', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(AST)))
  Z3_ast mk_fpa_div(
    Z3_context c,
    Z3_ast rm,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_fpa_div(
      c,
      rm,
      t1,
      t2,
    );
  }

  late final _mk_fpa_divPtr = _lookup<
          ffi
          .NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>>(
      'Z3_mk_fpa_div');
  late final _mk_fpa_div = _mk_fpa_divPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast)>();

  /// \brief Floating-point fused multiply-add.
  ///
  /// \param c logical context
  /// \param rm term of RoundingMode sort
  /// \param t1 term of FloatingPoint sort
  /// \param t2 term of FloatingPoint sort
  /// \param t3 term of FloatingPoint sort
  ///
  /// The result is \ccode{round((t1 * t2) + t3)}.
  ///
  /// \c rm must be of RoundingMode sort, \c t1, \c t2, and \c t3 must have the same FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_fma', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(AST),_in(AST)))
  Z3_ast mk_fpa_fma(
    Z3_context c,
    Z3_ast rm,
    Z3_ast t1,
    Z3_ast t2,
    Z3_ast t3,
  ) {
    return _mk_fpa_fma(
      c,
      rm,
      t1,
      t2,
      t3,
    );
  }

  late final _mk_fpa_fmaPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, Z3_ast, Z3_ast, Z3_ast, Z3_ast)>>('Z3_mk_fpa_fma');
  late final _mk_fpa_fma = _mk_fpa_fmaPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast, Z3_ast)>();

  /// \brief Floating-point square root
  ///
  /// \param c logical context
  /// \param rm term of RoundingMode sort
  /// \param t term of FloatingPoint sort
  ///
  /// \c rm must be of RoundingMode sort, \c t must have FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_sqrt', AST, (_in(CONTEXT),_in(AST),_in(AST)))
  Z3_ast mk_fpa_sqrt(
    Z3_context c,
    Z3_ast rm,
    Z3_ast t,
  ) {
    return _mk_fpa_sqrt(
      c,
      rm,
      t,
    );
  }

  late final _mk_fpa_sqrtPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_fpa_sqrt');
  late final _mk_fpa_sqrt =
      _mk_fpa_sqrtPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Floating-point remainder
  ///
  /// \param c logical context
  /// \param t1 term of FloatingPoint sort
  /// \param t2 term of FloatingPoint sort
  ///
  /// \c t1 and \c t2 must have the same FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_rem', AST, (_in(CONTEXT),_in(AST),_in(AST)))
  Z3_ast mk_fpa_rem(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_fpa_rem(
      c,
      t1,
      t2,
    );
  }

  late final _mk_fpa_remPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_fpa_rem');
  late final _mk_fpa_rem =
      _mk_fpa_remPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Floating-point roundToIntegral. Rounds a floating-point number to
  /// the closest integer, again represented as a floating-point number.
  ///
  /// \param c logical context
  /// \param rm term of RoundingMode sort
  /// \param t term of FloatingPoint sort
  ///
  /// \c t must be of FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_round_to_integral', AST, (_in(CONTEXT),_in(AST),_in(AST)))
  Z3_ast mk_fpa_round_to_integral(
    Z3_context c,
    Z3_ast rm,
    Z3_ast t,
  ) {
    return _mk_fpa_round_to_integral(
      c,
      rm,
      t,
    );
  }

  late final _mk_fpa_round_to_integralPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_fpa_round_to_integral');
  late final _mk_fpa_round_to_integral = _mk_fpa_round_to_integralPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Minimum of floating-point numbers.
  ///
  /// \param c logical context
  /// \param t1 term of FloatingPoint sort
  /// \param t2 term of FloatingPoint sort
  ///
  /// \c t1, \c t2 must have the same FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_min', AST, (_in(CONTEXT),_in(AST),_in(AST)))
  Z3_ast mk_fpa_min(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_fpa_min(
      c,
      t1,
      t2,
    );
  }

  late final _mk_fpa_minPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_fpa_min');
  late final _mk_fpa_min =
      _mk_fpa_minPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Maximum of floating-point numbers.
  ///
  /// \param c logical context
  /// \param t1 term of FloatingPoint sort
  /// \param t2 term of FloatingPoint sort
  ///
  /// \c t1, \c t2 must have the same FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_max', AST, (_in(CONTEXT),_in(AST),_in(AST)))
  Z3_ast mk_fpa_max(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_fpa_max(
      c,
      t1,
      t2,
    );
  }

  late final _mk_fpa_maxPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_fpa_max');
  late final _mk_fpa_max =
      _mk_fpa_maxPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Floating-point less than or equal.
  ///
  /// \param c logical context
  /// \param t1 term of FloatingPoint sort
  /// \param t2 term of FloatingPoint sort
  ///
  /// \c t1 and \c t2 must have the same FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_leq', AST, (_in(CONTEXT),_in(AST),_in(AST)))
  Z3_ast mk_fpa_leq(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_fpa_leq(
      c,
      t1,
      t2,
    );
  }

  late final _mk_fpa_leqPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_fpa_leq');
  late final _mk_fpa_leq =
      _mk_fpa_leqPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Floating-point less than.
  ///
  /// \param c logical context
  /// \param t1 term of FloatingPoint sort
  /// \param t2 term of FloatingPoint sort
  ///
  /// \c t1 and \c t2 must have the same FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_lt', AST, (_in(CONTEXT),_in(AST),_in(AST)))
  Z3_ast mk_fpa_lt(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_fpa_lt(
      c,
      t1,
      t2,
    );
  }

  late final _mk_fpa_ltPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_fpa_lt');
  late final _mk_fpa_lt =
      _mk_fpa_ltPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Floating-point greater than or equal.
  ///
  /// \param c logical context
  /// \param t1 term of FloatingPoint sort
  /// \param t2 term of FloatingPoint sort
  ///
  /// \c t1 and \c t2 must have the same FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_geq', AST, (_in(CONTEXT),_in(AST),_in(AST)))
  Z3_ast mk_fpa_geq(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_fpa_geq(
      c,
      t1,
      t2,
    );
  }

  late final _mk_fpa_geqPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_fpa_geq');
  late final _mk_fpa_geq =
      _mk_fpa_geqPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Floating-point greater than.
  ///
  /// \param c logical context
  /// \param t1 term of FloatingPoint sort
  /// \param t2 term of FloatingPoint sort
  ///
  /// \c t1 and \c t2 must have the same FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_gt', AST, (_in(CONTEXT),_in(AST),_in(AST)))
  Z3_ast mk_fpa_gt(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_fpa_gt(
      c,
      t1,
      t2,
    );
  }

  late final _mk_fpa_gtPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_fpa_gt');
  late final _mk_fpa_gt =
      _mk_fpa_gtPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Floating-point equality.
  ///
  /// \param c logical context
  /// \param t1 term of FloatingPoint sort
  /// \param t2 term of FloatingPoint sort
  ///
  /// Note that this is IEEE 754 equality (as opposed to SMT-LIB \ccode{=}).
  ///
  /// \c t1 and \c t2 must have the same FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_eq', AST, (_in(CONTEXT),_in(AST),_in(AST)))
  Z3_ast mk_fpa_eq(
    Z3_context c,
    Z3_ast t1,
    Z3_ast t2,
  ) {
    return _mk_fpa_eq(
      c,
      t1,
      t2,
    );
  }

  late final _mk_fpa_eqPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>>(
          'Z3_mk_fpa_eq');
  late final _mk_fpa_eq =
      _mk_fpa_eqPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast)>();

  /// \brief Predicate indicating whether \c t is a normal floating-point number.
  ///
  /// \param c logical context
  /// \param t term of FloatingPoint sort
  ///
  /// \c t must have FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_is_normal', AST, (_in(CONTEXT),_in(AST)))
  Z3_ast mk_fpa_is_normal(
    Z3_context c,
    Z3_ast t,
  ) {
    return _mk_fpa_is_normal(
      c,
      t,
    );
  }

  late final _mk_fpa_is_normalPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_fpa_is_normal');
  late final _mk_fpa_is_normal =
      _mk_fpa_is_normalPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Predicate indicating whether \c t is a subnormal floating-point number.
  ///
  /// \param c logical context
  /// \param t term of FloatingPoint sort
  ///
  /// \c t must have FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_is_subnormal', AST, (_in(CONTEXT),_in(AST)))
  Z3_ast mk_fpa_is_subnormal(
    Z3_context c,
    Z3_ast t,
  ) {
    return _mk_fpa_is_subnormal(
      c,
      t,
    );
  }

  late final _mk_fpa_is_subnormalPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_fpa_is_subnormal');
  late final _mk_fpa_is_subnormal =
      _mk_fpa_is_subnormalPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Predicate indicating whether \c t is a floating-point number with zero value, i.e., +zero or -zero.
  ///
  /// \param c logical context
  /// \param t term of FloatingPoint sort
  ///
  /// \c t must have FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_is_zero', AST, (_in(CONTEXT),_in(AST)))
  Z3_ast mk_fpa_is_zero(
    Z3_context c,
    Z3_ast t,
  ) {
    return _mk_fpa_is_zero(
      c,
      t,
    );
  }

  late final _mk_fpa_is_zeroPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_fpa_is_zero');
  late final _mk_fpa_is_zero =
      _mk_fpa_is_zeroPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Predicate indicating whether \c t is a floating-point number representing +oo or -oo.
  ///
  /// \param c logical context
  /// \param t term of FloatingPoint sort
  ///
  /// \c t must have FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_is_infinite', AST, (_in(CONTEXT),_in(AST)))
  Z3_ast mk_fpa_is_infinite(
    Z3_context c,
    Z3_ast t,
  ) {
    return _mk_fpa_is_infinite(
      c,
      t,
    );
  }

  late final _mk_fpa_is_infinitePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_fpa_is_infinite');
  late final _mk_fpa_is_infinite =
      _mk_fpa_is_infinitePtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Predicate indicating whether \c t is a NaN.
  ///
  /// \param c logical context
  /// \param t term of FloatingPoint sort
  ///
  /// \c t must have FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_is_nan', AST, (_in(CONTEXT),_in(AST)))
  Z3_ast mk_fpa_is_nan(
    Z3_context c,
    Z3_ast t,
  ) {
    return _mk_fpa_is_nan(
      c,
      t,
    );
  }

  late final _mk_fpa_is_nanPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_fpa_is_nan');
  late final _mk_fpa_is_nan =
      _mk_fpa_is_nanPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Predicate indicating whether \c t is a negative floating-point number.
  ///
  /// \param c logical context
  /// \param t term of FloatingPoint sort
  ///
  /// \c t must have FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_is_negative', AST, (_in(CONTEXT),_in(AST)))
  Z3_ast mk_fpa_is_negative(
    Z3_context c,
    Z3_ast t,
  ) {
    return _mk_fpa_is_negative(
      c,
      t,
    );
  }

  late final _mk_fpa_is_negativePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_fpa_is_negative');
  late final _mk_fpa_is_negative =
      _mk_fpa_is_negativePtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Predicate indicating whether \c t is a positive floating-point number.
  ///
  /// \param c logical context
  /// \param t term of FloatingPoint sort
  ///
  /// \c t must have FloatingPoint sort.
  ///
  /// def_API('Z3_mk_fpa_is_positive', AST, (_in(CONTEXT),_in(AST)))
  Z3_ast mk_fpa_is_positive(
    Z3_context c,
    Z3_ast t,
  ) {
    return _mk_fpa_is_positive(
      c,
      t,
    );
  }

  late final _mk_fpa_is_positivePtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_fpa_is_positive');
  late final _mk_fpa_is_positive =
      _mk_fpa_is_positivePtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Conversion of a single IEEE 754-2008 bit-vector into a floating-point number.
  ///
  /// Produces a term that represents the conversion of a bit-vector term \c bv to a
  /// floating-point term of sort \c s.
  ///
  /// \param c logical context
  /// \param bv a bit-vector term
  /// \param s floating-point sort
  ///
  /// \c s must be a FloatingPoint sort, \c t must be of bit-vector sort, and the bit-vector
  /// size of \c bv must be equal to \ccode{ebits+sbits} of \c s. The format of the bit-vector is
  /// as defined by the IEEE 754-2008 interchange format.
  ///
  /// def_API('Z3_mk_fpa_to_fp_bv', AST, (_in(CONTEXT),_in(AST),_in(SORT)))
  Z3_ast mk_fpa_to_fp_bv(
    Z3_context c,
    Z3_ast bv,
    Z3_sort s,
  ) {
    return _mk_fpa_to_fp_bv(
      c,
      bv,
      s,
    );
  }

  late final _mk_fpa_to_fp_bvPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_sort)>>(
          'Z3_mk_fpa_to_fp_bv');
  late final _mk_fpa_to_fp_bv = _mk_fpa_to_fp_bvPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_sort)>();

  /// \brief Conversion of a FloatingPoint term into another term of different FloatingPoint sort.
  ///
  /// Produces a term that represents the conversion of a floating-point term \c t to a
  /// floating-point term of sort \c s. If necessary, the result will be rounded according
  /// to rounding mode \c rm.
  ///
  /// \param c logical context
  /// \param rm term of RoundingMode sort
  /// \param t term of FloatingPoint sort
  /// \param s floating-point sort
  ///
  /// \c s must be a FloatingPoint sort, \c rm must be of RoundingMode sort, \c t must be of floating-point sort.
  ///
  /// def_API('Z3_mk_fpa_to_fp_float', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(SORT)))
  Z3_ast mk_fpa_to_fp_float(
    Z3_context c,
    Z3_ast rm,
    Z3_ast t,
    Z3_sort s,
  ) {
    return _mk_fpa_to_fp_float(
      c,
      rm,
      t,
      s,
    );
  }

  late final _mk_fpa_to_fp_floatPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, Z3_ast, Z3_ast, Z3_sort)>>('Z3_mk_fpa_to_fp_float');
  late final _mk_fpa_to_fp_float = _mk_fpa_to_fp_floatPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_sort)>();

  /// \brief Conversion of a term of real sort into a term of FloatingPoint sort.
  ///
  /// Produces a term that represents the conversion of term \c t of real sort into a
  /// floating-point term of sort \c s. If necessary, the result will be rounded according
  /// to rounding mode \c rm.
  ///
  /// \param c logical context
  /// \param rm term of RoundingMode sort
  /// \param t term of Real sort
  /// \param s floating-point sort
  ///
  /// \c s must be a FloatingPoint sort, \c rm must be of RoundingMode sort, \c t must be of real sort.
  ///
  /// def_API('Z3_mk_fpa_to_fp_real', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(SORT)))
  Z3_ast mk_fpa_to_fp_real(
    Z3_context c,
    Z3_ast rm,
    Z3_ast t,
    Z3_sort s,
  ) {
    return _mk_fpa_to_fp_real(
      c,
      rm,
      t,
      s,
    );
  }

  late final _mk_fpa_to_fp_realPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, Z3_ast, Z3_ast, Z3_sort)>>('Z3_mk_fpa_to_fp_real');
  late final _mk_fpa_to_fp_real = _mk_fpa_to_fp_realPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_sort)>();

  /// \brief Conversion of a 2's complement signed bit-vector term into a term of FloatingPoint sort.
  ///
  /// Produces a term that represents the conversion of the bit-vector term \c t into a
  /// floating-point term of sort \c s. The bit-vector \c t is taken to be in signed
  /// 2's complement format. If necessary, the result will be rounded according
  /// to rounding mode \c rm.
  ///
  /// \param c logical context
  /// \param rm term of RoundingMode sort
  /// \param t term of bit-vector sort
  /// \param s floating-point sort
  ///
  /// \c s must be a FloatingPoint sort, \c rm must be of RoundingMode sort, \c t must be of bit-vector sort.
  ///
  /// def_API('Z3_mk_fpa_to_fp_signed', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(SORT)))
  Z3_ast mk_fpa_to_fp_signed(
    Z3_context c,
    Z3_ast rm,
    Z3_ast t,
    Z3_sort s,
  ) {
    return _mk_fpa_to_fp_signed(
      c,
      rm,
      t,
      s,
    );
  }

  late final _mk_fpa_to_fp_signedPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context, Z3_ast, Z3_ast, Z3_sort)>>('Z3_mk_fpa_to_fp_signed');
  late final _mk_fpa_to_fp_signed = _mk_fpa_to_fp_signedPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_sort)>();

  /// \brief Conversion of a 2's complement unsigned bit-vector term into a term of FloatingPoint sort.
  ///
  /// Produces a term that represents the conversion of the bit-vector term \c t into a
  /// floating-point term of sort \c s. The bit-vector \c t is taken to be in unsigned
  /// 2's complement format. If necessary, the result will be rounded according
  /// to rounding mode \c rm.
  ///
  /// \param c logical context
  /// \param rm term of RoundingMode sort
  /// \param t term of bit-vector sort
  /// \param s floating-point sort
  ///
  /// \c s must be a FloatingPoint sort, \c rm must be of RoundingMode sort, \c t must be of bit-vector sort.
  ///
  /// def_API('Z3_mk_fpa_to_fp_unsigned', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(SORT)))
  Z3_ast mk_fpa_to_fp_unsigned(
    Z3_context c,
    Z3_ast rm,
    Z3_ast t,
    Z3_sort s,
  ) {
    return _mk_fpa_to_fp_unsigned(
      c,
      rm,
      t,
      s,
    );
  }

  late final _mk_fpa_to_fp_unsignedPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast, Z3_ast,
              Z3_sort)>>('Z3_mk_fpa_to_fp_unsigned');
  late final _mk_fpa_to_fp_unsigned = _mk_fpa_to_fp_unsignedPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_sort)>();

  /// \brief Conversion of a floating-point term into an unsigned bit-vector.
  ///
  /// Produces a term that represents the conversion of the floating-point term \c t into a
  /// bit-vector term of size \c sz in unsigned 2's complement format. If necessary, the result
  /// will be rounded according to rounding mode \c rm.
  ///
  /// \param c logical context
  /// \param rm term of RoundingMode sort
  /// \param t term of FloatingPoint sort
  /// \param sz size of the resulting bit-vector
  ///
  /// def_API('Z3_mk_fpa_to_ubv', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(UINT)))
  Z3_ast mk_fpa_to_ubv(
    Z3_context c,
    Z3_ast rm,
    Z3_ast t,
    int sz,
  ) {
    return _mk_fpa_to_ubv(
      c,
      rm,
      t,
      sz,
    );
  }

  late final _mk_fpa_to_ubvPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast, Z3_ast,
              ffi.UnsignedInt)>>('Z3_mk_fpa_to_ubv');
  late final _mk_fpa_to_ubv = _mk_fpa_to_ubvPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast, int)>();

  /// \brief Conversion of a floating-point term into a signed bit-vector.
  ///
  /// Produces a term that represents the conversion of the floating-point term \c t into a
  /// bit-vector term of size \c sz in signed 2's complement format. If necessary, the result
  /// will be rounded according to rounding mode \c rm.
  ///
  /// \param c logical context
  /// \param rm term of RoundingMode sort
  /// \param t term of FloatingPoint sort
  /// \param sz size of the resulting bit-vector
  ///
  /// def_API('Z3_mk_fpa_to_sbv', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(UINT)))
  Z3_ast mk_fpa_to_sbv(
    Z3_context c,
    Z3_ast rm,
    Z3_ast t,
    int sz,
  ) {
    return _mk_fpa_to_sbv(
      c,
      rm,
      t,
      sz,
    );
  }

  late final _mk_fpa_to_sbvPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast, Z3_ast,
              ffi.UnsignedInt)>>('Z3_mk_fpa_to_sbv');
  late final _mk_fpa_to_sbv = _mk_fpa_to_sbvPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, Z3_ast, int)>();

  /// \brief Conversion of a floating-point term into a real-numbered term.
  ///
  /// Produces a term that represents the conversion of the floating-point term \c t into a
  /// real number. Note that this type of conversion will often result in non-linear
  /// constraints over real terms.
  ///
  /// \param c logical context
  /// \param t term of FloatingPoint sort
  ///
  /// def_API('Z3_mk_fpa_to_real', AST, (_in(CONTEXT),_in(AST)))
  Z3_ast mk_fpa_to_real(
    Z3_context c,
    Z3_ast t,
  ) {
    return _mk_fpa_to_real(
      c,
      t,
    );
  }

  late final _mk_fpa_to_realPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_fpa_to_real');
  late final _mk_fpa_to_real =
      _mk_fpa_to_realPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// @name Z3-specific floating-point extensions */
  /// /**@{*/
  /// /**
  /// \brief Retrieves the number of bits reserved for the exponent in a FloatingPoint sort.
  ///
  /// \param c logical context
  /// \param s FloatingPoint sort
  ///
  /// def_API('Z3_fpa_get_ebits', UINT, (_in(CONTEXT),_in(SORT)))
  int fpa_get_ebits(
    Z3_context c,
    Z3_sort s,
  ) {
    return _fpa_get_ebits(
      c,
      s,
    );
  }

  late final _fpa_get_ebitsPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_sort)>>(
      'Z3_fpa_get_ebits');
  late final _fpa_get_ebits =
      _fpa_get_ebitsPtr.asFunction<int Function(Z3_context, Z3_sort)>();

  /// \brief Retrieves the number of bits reserved for the significand in a FloatingPoint sort.
  ///
  /// \param c logical context
  /// \param s FloatingPoint sort
  ///
  /// def_API('Z3_fpa_get_sbits', UINT, (_in(CONTEXT),_in(SORT)))
  int fpa_get_sbits(
    Z3_context c,
    Z3_sort s,
  ) {
    return _fpa_get_sbits(
      c,
      s,
    );
  }

  late final _fpa_get_sbitsPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(Z3_context, Z3_sort)>>(
      'Z3_fpa_get_sbits');
  late final _fpa_get_sbits =
      _fpa_get_sbitsPtr.asFunction<int Function(Z3_context, Z3_sort)>();

  /// \brief Checks whether a given floating-point numeral is a NaN.
  ///
  /// \param c logical context
  /// \param t a floating-point numeral
  ///
  /// def_API('Z3_fpa_is_numeral_nan', BOOL, (_in(CONTEXT), _in(AST)))
  bool fpa_is_numeral_nan(
    Z3_context c,
    Z3_ast t,
  ) {
    return _fpa_is_numeral_nan(
      c,
      t,
    );
  }

  late final _fpa_is_numeral_nanPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_ast)>>(
          'Z3_fpa_is_numeral_nan');
  late final _fpa_is_numeral_nan =
      _fpa_is_numeral_nanPtr.asFunction<bool Function(Z3_context, Z3_ast)>();

  /// \brief Checks whether a given floating-point numeral is a +oo or -oo.
  ///
  /// \param c logical context
  /// \param t a floating-point numeral
  ///
  /// def_API('Z3_fpa_is_numeral_inf', BOOL, (_in(CONTEXT), _in(AST)))
  bool fpa_is_numeral_inf(
    Z3_context c,
    Z3_ast t,
  ) {
    return _fpa_is_numeral_inf(
      c,
      t,
    );
  }

  late final _fpa_is_numeral_infPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_ast)>>(
          'Z3_fpa_is_numeral_inf');
  late final _fpa_is_numeral_inf =
      _fpa_is_numeral_infPtr.asFunction<bool Function(Z3_context, Z3_ast)>();

  /// \brief Checks whether a given floating-point numeral is +zero or -zero.
  ///
  /// \param c logical context
  /// \param t a floating-point numeral
  ///
  /// def_API('Z3_fpa_is_numeral_zero', BOOL, (_in(CONTEXT), _in(AST)))
  bool fpa_is_numeral_zero(
    Z3_context c,
    Z3_ast t,
  ) {
    return _fpa_is_numeral_zero(
      c,
      t,
    );
  }

  late final _fpa_is_numeral_zeroPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_ast)>>(
          'Z3_fpa_is_numeral_zero');
  late final _fpa_is_numeral_zero =
      _fpa_is_numeral_zeroPtr.asFunction<bool Function(Z3_context, Z3_ast)>();

  /// \brief Checks whether a given floating-point numeral is normal.
  ///
  /// \param c logical context
  /// \param t a floating-point numeral
  ///
  /// def_API('Z3_fpa_is_numeral_normal', BOOL, (_in(CONTEXT), _in(AST)))
  bool fpa_is_numeral_normal(
    Z3_context c,
    Z3_ast t,
  ) {
    return _fpa_is_numeral_normal(
      c,
      t,
    );
  }

  late final _fpa_is_numeral_normalPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_ast)>>(
          'Z3_fpa_is_numeral_normal');
  late final _fpa_is_numeral_normal =
      _fpa_is_numeral_normalPtr.asFunction<bool Function(Z3_context, Z3_ast)>();

  /// \brief Checks whether a given floating-point numeral is subnormal.
  ///
  /// \param c logical context
  /// \param t a floating-point numeral
  ///
  /// def_API('Z3_fpa_is_numeral_subnormal', BOOL, (_in(CONTEXT), _in(AST)))
  bool fpa_is_numeral_subnormal(
    Z3_context c,
    Z3_ast t,
  ) {
    return _fpa_is_numeral_subnormal(
      c,
      t,
    );
  }

  late final _fpa_is_numeral_subnormalPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_ast)>>(
          'Z3_fpa_is_numeral_subnormal');
  late final _fpa_is_numeral_subnormal = _fpa_is_numeral_subnormalPtr
      .asFunction<bool Function(Z3_context, Z3_ast)>();

  /// \brief Checks whether a given floating-point numeral is positive.
  ///
  /// \param c logical context
  /// \param t a floating-point numeral
  ///
  /// def_API('Z3_fpa_is_numeral_positive', BOOL, (_in(CONTEXT), _in(AST)))
  bool fpa_is_numeral_positive(
    Z3_context c,
    Z3_ast t,
  ) {
    return _fpa_is_numeral_positive(
      c,
      t,
    );
  }

  late final _fpa_is_numeral_positivePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_ast)>>(
          'Z3_fpa_is_numeral_positive');
  late final _fpa_is_numeral_positive = _fpa_is_numeral_positivePtr
      .asFunction<bool Function(Z3_context, Z3_ast)>();

  /// \brief Checks whether a given floating-point numeral is negative.
  ///
  /// \param c logical context
  /// \param t a floating-point numeral
  ///
  /// def_API('Z3_fpa_is_numeral_negative', BOOL, (_in(CONTEXT), _in(AST)))
  bool fpa_is_numeral_negative(
    Z3_context c,
    Z3_ast t,
  ) {
    return _fpa_is_numeral_negative(
      c,
      t,
    );
  }

  late final _fpa_is_numeral_negativePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(Z3_context, Z3_ast)>>(
          'Z3_fpa_is_numeral_negative');
  late final _fpa_is_numeral_negative = _fpa_is_numeral_negativePtr
      .asFunction<bool Function(Z3_context, Z3_ast)>();

  /// \brief Retrieves the sign of a floating-point literal as a bit-vector expression.
  ///
  /// \param c logical context
  /// \param t a floating-point numeral
  ///
  /// Remarks: NaN is an invalid argument.
  ///
  /// def_API('Z3_fpa_get_numeral_sign_bv', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast fpa_get_numeral_sign_bv(
    Z3_context c,
    Z3_ast t,
  ) {
    return _fpa_get_numeral_sign_bv(
      c,
      t,
    );
  }

  late final _fpa_get_numeral_sign_bvPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_fpa_get_numeral_sign_bv');
  late final _fpa_get_numeral_sign_bv = _fpa_get_numeral_sign_bvPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Retrieves the significand of a floating-point literal as a bit-vector expression.
  ///
  /// \param c logical context
  /// \param t a floating-point numeral
  ///
  /// Remarks: NaN is an invalid argument.
  ///
  /// def_API('Z3_fpa_get_numeral_significand_bv', AST, (_in(CONTEXT), _in(AST)))
  Z3_ast fpa_get_numeral_significand_bv(
    Z3_context c,
    Z3_ast t,
  ) {
    return _fpa_get_numeral_significand_bv(
      c,
      t,
    );
  }

  late final _fpa_get_numeral_significand_bvPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_fpa_get_numeral_significand_bv');
  late final _fpa_get_numeral_significand_bv =
      _fpa_get_numeral_significand_bvPtr
          .asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Retrieves the sign of a floating-point literal.
  ///
  /// \param c logical context
  /// \param t a floating-point numeral
  /// \param sgn the retrieved sign
  /// \returns true if \c t corresponds to a floating point numeral, otherwise invokes exception handler or returns false
  ///
  /// Remarks: sets \c sgn to 0 if `t' is positive and to 1 otherwise, except for
  /// NaN, which is an invalid argument.
  ///
  /// def_API('Z3_fpa_get_numeral_sign', BOOL, (_in(CONTEXT), _in(AST), _out(INT)))
  bool fpa_get_numeral_sign(
    Z3_context c,
    Z3_ast t,
    ffi.Pointer<ffi.Int> sgn,
  ) {
    return _fpa_get_numeral_sign(
      c,
      t,
      sgn,
    );
  }

  late final _fpa_get_numeral_signPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(Z3_context, Z3_ast,
              ffi.Pointer<ffi.Int>)>>('Z3_fpa_get_numeral_sign');
  late final _fpa_get_numeral_sign = _fpa_get_numeral_signPtr
      .asFunction<bool Function(Z3_context, Z3_ast, ffi.Pointer<ffi.Int>)>();

  /// \brief Return the significand value of a floating-point numeral as a string.
  ///
  /// \param c logical context
  /// \param t a floating-point numeral
  /// \returns true if \c t corresponds to a floating point numeral, otherwise invokes exception handler or returns false
  ///
  /// Remarks: The significand \c s is always \ccode{0.0 <= s < 2.0}; the resulting string is long
  /// enough to represent the real significand precisely.
  ///
  /// def_API('Z3_fpa_get_numeral_significand_string', STRING, (_in(CONTEXT), _in(AST)))
  Z3_string fpa_get_numeral_significand_string(
    Z3_context c,
    Z3_ast t,
  ) {
    return _fpa_get_numeral_significand_string(
      c,
      t,
    );
  }

  late final _fpa_get_numeral_significand_stringPtr =
      _lookup<ffi.NativeFunction<Z3_string Function(Z3_context, Z3_ast)>>(
          'Z3_fpa_get_numeral_significand_string');
  late final _fpa_get_numeral_significand_string =
      _fpa_get_numeral_significand_stringPtr
          .asFunction<Z3_string Function(Z3_context, Z3_ast)>();

  /// \brief Return the significand value of a floating-point numeral as a uint64.
  ///
  /// \param c logical context
  /// \param t a floating-point numeral
  /// \param n pointer to output uint64
  ///
  /// Remarks: This function extracts the significand bits in `t`, without the
  /// hidden bit or normalization. Sets the \c Z3_INVALID_ARG error code if the
  /// significand does not fit into a \c uint64. NaN is an invalid argument.
  ///
  /// def_API('Z3_fpa_get_numeral_significand_uint64', BOOL, (_in(CONTEXT), _in(AST), _out(UINT64)))
  bool fpa_get_numeral_significand_uint64(
    Z3_context c,
    Z3_ast t,
    ffi.Pointer<ffi.Uint64> n,
  ) {
    return _fpa_get_numeral_significand_uint64(
      c,
      t,
      n,
    );
  }

  late final _fpa_get_numeral_significand_uint64Ptr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(Z3_context, Z3_ast, ffi.Pointer<ffi.Uint64>)>>(
      'Z3_fpa_get_numeral_significand_uint64');
  late final _fpa_get_numeral_significand_uint64 =
      _fpa_get_numeral_significand_uint64Ptr.asFunction<
          bool Function(Z3_context, Z3_ast, ffi.Pointer<ffi.Uint64>)>();

  /// \brief Return the exponent value of a floating-point numeral as a string.
  ///
  /// \param c logical context
  /// \param t a floating-point numeral
  /// \param biased flag to indicate whether the result is in biased representation
  /// \returns true if \c t corresponds to a floating point numeral, otherwise invokes exception handler or returns false
  ///
  /// Remarks: This function extracts the exponent in `t`, without normalization.
  /// NaN is an invalid argument.
  ///
  /// def_API('Z3_fpa_get_numeral_exponent_string', STRING, (_in(CONTEXT), _in(AST), _in(BOOL)))
  Z3_string fpa_get_numeral_exponent_string(
    Z3_context c,
    Z3_ast t,
    bool biased,
  ) {
    return _fpa_get_numeral_exponent_string(
      c,
      t,
      biased,
    );
  }

  late final _fpa_get_numeral_exponent_stringPtr = _lookup<
          ffi.NativeFunction<Z3_string Function(Z3_context, Z3_ast, ffi.Bool)>>(
      'Z3_fpa_get_numeral_exponent_string');
  late final _fpa_get_numeral_exponent_string =
      _fpa_get_numeral_exponent_stringPtr
          .asFunction<Z3_string Function(Z3_context, Z3_ast, bool)>();

  /// \brief Return the exponent value of a floating-point numeral as a signed 64-bit integer
  ///
  /// \param c logical context
  /// \param t a floating-point numeral
  /// \param n exponent
  /// \param biased flag to indicate whether the result is in biased representation
  /// \returns true if \c t corresponds to a floating point numeral, otherwise invokes exception handler or returns false
  ///
  /// Remarks: This function extracts the exponent in `t`, without normalization.
  /// NaN is an invalid argument.
  ///
  /// def_API('Z3_fpa_get_numeral_exponent_int64', BOOL, (_in(CONTEXT), _in(AST), _out(INT64), _in(BOOL)))
  bool fpa_get_numeral_exponent_int64(
    Z3_context c,
    Z3_ast t,
    ffi.Pointer<ffi.Int64> n,
    bool biased,
  ) {
    return _fpa_get_numeral_exponent_int64(
      c,
      t,
      n,
      biased,
    );
  }

  late final _fpa_get_numeral_exponent_int64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(Z3_context, Z3_ast, ffi.Pointer<ffi.Int64>,
              ffi.Bool)>>('Z3_fpa_get_numeral_exponent_int64');
  late final _fpa_get_numeral_exponent_int64 =
      _fpa_get_numeral_exponent_int64Ptr.asFunction<
          bool Function(Z3_context, Z3_ast, ffi.Pointer<ffi.Int64>, bool)>();

  /// \brief Retrieves the exponent of a floating-point literal as a bit-vector expression.
  ///
  /// \param c logical context
  /// \param t a floating-point numeral
  /// \param biased flag to indicate whether the result is in biased representation
  ///
  /// Remarks: This function extracts the exponent in `t`, without normalization.
  /// NaN is an invalid arguments.
  ///
  /// def_API('Z3_fpa_get_numeral_exponent_bv', AST, (_in(CONTEXT), _in(AST), _in(BOOL)))
  Z3_ast fpa_get_numeral_exponent_bv(
    Z3_context c,
    Z3_ast t,
    bool biased,
  ) {
    return _fpa_get_numeral_exponent_bv(
      c,
      t,
      biased,
    );
  }

  late final _fpa_get_numeral_exponent_bvPtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast, ffi.Bool)>>(
      'Z3_fpa_get_numeral_exponent_bv');
  late final _fpa_get_numeral_exponent_bv = _fpa_get_numeral_exponent_bvPtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast, bool)>();

  /// \brief Conversion of a floating-point term into a bit-vector term in IEEE 754-2008 format.
  ///
  /// \param c logical context
  /// \param t term of FloatingPoint sort
  ///
  /// \c t must have FloatingPoint sort. The size of the resulting bit-vector is automatically
  /// determined.
  ///
  /// Note that IEEE 754-2008 allows multiple different representations of NaN. This conversion
  /// knows only one NaN and it will always produce the same bit-vector representation of
  /// that NaN.
  ///
  /// def_API('Z3_mk_fpa_to_ieee_bv', AST, (_in(CONTEXT),_in(AST)))
  Z3_ast mk_fpa_to_ieee_bv(
    Z3_context c,
    Z3_ast t,
  ) {
    return _mk_fpa_to_ieee_bv(
      c,
      t,
    );
  }

  late final _mk_fpa_to_ieee_bvPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_ast)>>(
          'Z3_mk_fpa_to_ieee_bv');
  late final _mk_fpa_to_ieee_bv =
      _mk_fpa_to_ieee_bvPtr.asFunction<Z3_ast Function(Z3_context, Z3_ast)>();

  /// \brief Conversion of a real-sorted significand and an integer-sorted exponent into a term of FloatingPoint sort.
  ///
  /// Produces a term that represents the conversion of \ccode{sig * 2^exp} into a
  /// floating-point term of sort \c s. If necessary, the result will be rounded
  /// according to rounding mode \c rm.
  ///
  /// \param c logical context
  /// \param rm term of RoundingMode sort
  /// \param exp exponent term of Int sort
  /// \param sig significand term of Real sort
  /// \param s FloatingPoint sort
  ///
  /// \c s must be a FloatingPoint sort, \c rm must be of RoundingMode sort, \c exp must be of int sort, \c sig must be of real sort.
  ///
  /// def_API('Z3_mk_fpa_to_fp_int_real', AST, (_in(CONTEXT),_in(AST),_in(AST),_in(AST),_in(SORT)))
  Z3_ast mk_fpa_to_fp_int_real(
    Z3_context c,
    Z3_ast rm,
    Z3_ast exp,
    Z3_ast sig,
    Z3_sort s,
  ) {
    return _mk_fpa_to_fp_int_real(
      c,
      rm,
      exp,
      sig,
      s,
    );
  }

  late final _mk_fpa_to_fp_int_realPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast,
              Z3_sort)>>('Z3_mk_fpa_to_fp_int_real');
  late final _mk_fpa_to_fp_int_real = _mk_fpa_to_fp_int_realPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_ast, Z3_ast, Z3_ast, Z3_sort)>();

  /// @name Spacer facilities */
  /// /**@{*/
  /// /**
  /// \brief Pose a query against the asserted rules at the given level.
  ///
  /// \code
  /// query ::= (exists (bound-vars) query)
  /// |  literals
  /// \endcode
  ///
  /// query returns
  /// - \c Z3_L_FALSE if the query is unsatisfiable.
  /// - \c Z3_L_TRUE if the query is satisfiable. Obtain the answer by calling #Z3_fixedpoint_get_answer.
  /// - \c Z3_L_UNDEF if the query was interrupted, timed out or otherwise failed.
  ///
  /// def_API('Z3_fixedpoint_query_from_lvl', LBOOL, (_in(CONTEXT), _in(FIXEDPOINT), _in(AST), _in(UINT)))
  int fixedpoint_query_from_lvl(
    Z3_context c,
    Z3_fixedpoint d,
    Z3_ast query,
    int lvl,
  ) {
    return _fixedpoint_query_from_lvl(
      c,
      d,
      query,
      lvl,
    );
  }

  late final _fixedpoint_query_from_lvlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(Z3_context, Z3_fixedpoint, Z3_ast,
              ffi.UnsignedInt)>>('Z3_fixedpoint_query_from_lvl');
  late final _fixedpoint_query_from_lvl = _fixedpoint_query_from_lvlPtr
      .asFunction<int Function(Z3_context, Z3_fixedpoint, Z3_ast, int)>();

  /// \brief Retrieve a bottom-up (from query) sequence of ground facts
  ///
  /// The previous call to #Z3_fixedpoint_query must have returned \c Z3_L_TRUE.
  ///
  /// def_API('Z3_fixedpoint_get_ground_sat_answer', AST, (_in(CONTEXT), _in(FIXEDPOINT)))
  Z3_ast fixedpoint_get_ground_sat_answer(
    Z3_context c,
    Z3_fixedpoint d,
  ) {
    return _fixedpoint_get_ground_sat_answer(
      c,
      d,
    );
  }

  late final _fixedpoint_get_ground_sat_answerPtr =
      _lookup<ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_fixedpoint)>>(
          'Z3_fixedpoint_get_ground_sat_answer');
  late final _fixedpoint_get_ground_sat_answer =
      _fixedpoint_get_ground_sat_answerPtr
          .asFunction<Z3_ast Function(Z3_context, Z3_fixedpoint)>();

  /// \brief Obtain the list of rules along the counterexample trace.
  ///
  /// def_API('Z3_fixedpoint_get_rules_along_trace', AST_VECTOR, (_in(CONTEXT), _in(FIXEDPOINT)))
  Z3_ast_vector fixedpoint_get_rules_along_trace(
    Z3_context c,
    Z3_fixedpoint d,
  ) {
    return _fixedpoint_get_rules_along_trace(
      c,
      d,
    );
  }

  late final _fixedpoint_get_rules_along_tracePtr = _lookup<
          ffi
          .NativeFunction<Z3_ast_vector Function(Z3_context, Z3_fixedpoint)>>(
      'Z3_fixedpoint_get_rules_along_trace');
  late final _fixedpoint_get_rules_along_trace =
      _fixedpoint_get_rules_along_tracePtr
          .asFunction<Z3_ast_vector Function(Z3_context, Z3_fixedpoint)>();

  /// \brief Obtain the list of rules along the counterexample trace.
  ///
  /// def_API('Z3_fixedpoint_get_rule_names_along_trace', SYMBOL, (_in(CONTEXT), _in(FIXEDPOINT)))
  Z3_symbol fixedpoint_get_rule_names_along_trace(
    Z3_context c,
    Z3_fixedpoint d,
  ) {
    return _fixedpoint_get_rule_names_along_trace(
      c,
      d,
    );
  }

  late final _fixedpoint_get_rule_names_along_tracePtr = _lookup<
          ffi.NativeFunction<Z3_symbol Function(Z3_context, Z3_fixedpoint)>>(
      'Z3_fixedpoint_get_rule_names_along_trace');
  late final _fixedpoint_get_rule_names_along_trace =
      _fixedpoint_get_rule_names_along_tracePtr
          .asFunction<Z3_symbol Function(Z3_context, Z3_fixedpoint)>();

  /// \brief Add an invariant for the predicate \c pred.
  /// Add an assumed invariant of predicate \c pred.
  ///
  /// Note: this functionality is Spacer specific.
  ///
  /// def_API('Z3_fixedpoint_add_invariant', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(FUNC_DECL), _in(AST)))
  void fixedpoint_add_invariant(
    Z3_context c,
    Z3_fixedpoint d,
    Z3_func_decl pred,
    Z3_ast property,
  ) {
    return _fixedpoint_add_invariant(
      c,
      d,
      pred,
      property,
    );
  }

  late final _fixedpoint_add_invariantPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(Z3_context, Z3_fixedpoint, Z3_func_decl,
              Z3_ast)>>('Z3_fixedpoint_add_invariant');
  late final _fixedpoint_add_invariant =
      _fixedpoint_add_invariantPtr.asFunction<
          void Function(Z3_context, Z3_fixedpoint, Z3_func_decl, Z3_ast)>();

  /// Retrieve reachable states of a predicate.
  /// Note: this functionality is Spacer specific.
  ///
  /// def_API('Z3_fixedpoint_get_reachable', AST, (_in(CONTEXT), _in(FIXEDPOINT), _in(FUNC_DECL)))
  Z3_ast fixedpoint_get_reachable(
    Z3_context c,
    Z3_fixedpoint d,
    Z3_func_decl pred,
  ) {
    return _fixedpoint_get_reachable(
      c,
      d,
      pred,
    );
  }

  late final _fixedpoint_get_reachablePtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_fixedpoint,
              Z3_func_decl)>>('Z3_fixedpoint_get_reachable');
  late final _fixedpoint_get_reachable = _fixedpoint_get_reachablePtr
      .asFunction<Z3_ast Function(Z3_context, Z3_fixedpoint, Z3_func_decl)>();

  /// \brief Project variables given a model
  ///
  /// def_API('Z3_qe_model_project', AST, (_in(CONTEXT), _in(MODEL), _in(UINT), _in_array(2, APP), _in(AST)))
  Z3_ast qe_model_project(
    Z3_context c,
    Z3_model m,
    int num_bounds,
    ffi.Pointer<Z3_app> bound,
    Z3_ast body,
  ) {
    return _qe_model_project(
      c,
      m,
      num_bounds,
      bound,
      body,
    );
  }

  late final _qe_model_projectPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(Z3_context, Z3_model, ffi.UnsignedInt,
              ffi.Pointer<Z3_app>, Z3_ast)>>('Z3_qe_model_project');
  late final _qe_model_project = _qe_model_projectPtr.asFunction<
      Z3_ast Function(
          Z3_context, Z3_model, int, ffi.Pointer<Z3_app>, Z3_ast)>();

  /// \brief Project variables given a model
  ///
  /// def_API('Z3_qe_model_project_skolem', AST, (_in(CONTEXT), _in(MODEL), _in(UINT), _in_array(2, APP), _in(AST), _in(AST_MAP)))
  Z3_ast qe_model_project_skolem(
    Z3_context c,
    Z3_model m,
    int num_bounds,
    ffi.Pointer<Z3_app> bound,
    Z3_ast body,
    Z3_ast_map map,
  ) {
    return _qe_model_project_skolem(
      c,
      m,
      num_bounds,
      bound,
      body,
      map,
    );
  }

  late final _qe_model_project_skolemPtr = _lookup<
      ffi.NativeFunction<
          Z3_ast Function(
              Z3_context,
              Z3_model,
              ffi.UnsignedInt,
              ffi.Pointer<Z3_app>,
              Z3_ast,
              Z3_ast_map)>>('Z3_qe_model_project_skolem');
  late final _qe_model_project_skolem = _qe_model_project_skolemPtr.asFunction<
      Z3_ast Function(Z3_context, Z3_model, int, ffi.Pointer<Z3_app>, Z3_ast,
          Z3_ast_map)>();

  /// \brief Extrapolates a model of a formula
  ///
  /// def_API('Z3_model_extrapolate', AST, (_in(CONTEXT), _in(MODEL), _in(AST)))
  Z3_ast model_extrapolate(
    Z3_context c,
    Z3_model m,
    Z3_ast fml,
  ) {
    return _model_extrapolate(
      c,
      m,
      fml,
    );
  }

  late final _model_extrapolatePtr = _lookup<
          ffi.NativeFunction<Z3_ast Function(Z3_context, Z3_model, Z3_ast)>>(
      'Z3_model_extrapolate');
  late final _model_extrapolate = _model_extrapolatePtr
      .asFunction<Z3_ast Function(Z3_context, Z3_model, Z3_ast)>();

  /// \brief Best-effort quantifier elimination
  ///
  /// def_API ('Z3_qe_lite', AST, (_in(CONTEXT), _in(AST_VECTOR), _in(AST)))
  Z3_ast qe_lite(
    Z3_context c,
    Z3_ast_vector vars,
    Z3_ast body,
  ) {
    return _qe_lite(
      c,
      vars,
      body,
    );
  }

  late final _qe_litePtr = _lookup<
          ffi
          .NativeFunction<Z3_ast Function(Z3_context, Z3_ast_vector, Z3_ast)>>(
      'Z3_qe_lite');
  late final _qe_lite = _qe_litePtr
      .asFunction<Z3_ast Function(Z3_context, Z3_ast_vector, Z3_ast)>();

  void enable_assertions(
    bool f,
  ) {
    return _enable_assertions(
      f,
    );
  }

  late final _enable_assertionsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Bool)>>(
          'enable_assertions');
  late final _enable_assertions =
      _enable_assertionsPtr.asFunction<void Function(bool)>();

  bool assertions_enabled() {
    return _assertions_enabled();
  }

  late final _assertions_enabledPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('assertions_enabled');
  late final _assertions_enabled =
      _assertions_enabledPtr.asFunction<bool Function()>();
}

typedef va_list = ffi.Pointer<ffi.Char>;

final class __crt_locale_data_public extends ffi.Struct {
  external ffi.Pointer<ffi.UnsignedShort> _locale_pctype;

  @ffi.Int()
  external int _locale_mb_cur_max;

  @ffi.UnsignedInt()
  external int _locale_lc_codepage;
}

final class __crt_locale_pointers extends ffi.Struct {
  external ffi.Pointer<__crt_locale_data> locinfo;

  external ffi.Pointer<__crt_multibyte_data> mbcinfo;
}

final class __crt_locale_data extends ffi.Opaque {}

final class __crt_multibyte_data extends ffi.Opaque {}

final class _Mbstatet extends ffi.Struct {
  @ffi.UnsignedLong()
  external int _Wchar;

  @ffi.UnsignedShort()
  external int _Byte;

  @ffi.UnsignedShort()
  external int _State;
}

final class _iobuf extends ffi.Struct {
  external ffi.Pointer<ffi.Void> _Placeholder;
}

typedef FILE = _iobuf;
typedef wint_t = ffi.UnsignedShort;
typedef errno_t = ffi.Int;
typedef _locale_t = ffi.Pointer<__crt_locale_pointers>;
typedef rsize_t = ffi.Size;
typedef fpos_t = ffi.LongLong;

final class _Z3_symbol extends ffi.Opaque {}

final class _Z3_config extends ffi.Opaque {}

final class _Z3_context extends ffi.Opaque {}

final class _Z3_sort extends ffi.Opaque {}

final class _Z3_func_decl extends ffi.Opaque {}

final class _Z3_ast extends ffi.Opaque {}

final class _Z3_app extends ffi.Opaque {}

final class _Z3_pattern extends ffi.Opaque {}

final class _Z3_model extends ffi.Opaque {}

final class _Z3_constructor extends ffi.Opaque {}

final class _Z3_constructor_list extends ffi.Opaque {}

final class _Z3_params extends ffi.Opaque {}

final class _Z3_param_descrs extends ffi.Opaque {}

final class _Z3_parser_context extends ffi.Opaque {}

final class _Z3_goal extends ffi.Opaque {}

final class _Z3_tactic extends ffi.Opaque {}

final class _Z3_simplifier extends ffi.Opaque {}

final class _Z3_probe extends ffi.Opaque {}

final class _Z3_stats extends ffi.Opaque {}

final class _Z3_solver extends ffi.Opaque {}

final class _Z3_solver_callback extends ffi.Opaque {}

final class _Z3_ast_vector extends ffi.Opaque {}

final class _Z3_ast_map extends ffi.Opaque {}

final class _Z3_apply_result extends ffi.Opaque {}

final class _Z3_func_interp extends ffi.Opaque {}

final class _Z3_func_entry extends ffi.Opaque {}

final class _Z3_fixedpoint extends ffi.Opaque {}

final class _Z3_optimize extends ffi.Opaque {}

final class _Z3_rcf_num extends ffi.Opaque {}

/// \brief Lifted Boolean type: \c false, \c undefined, \c true.
abstract class Z3_lbool {
  static const int L_FALSE = -1;
  static const int L_UNDEF = 0;
  static const int L_TRUE = 1;
}

/// \brief The different kinds of symbol.
/// In Z3, a symbol can be represented using integers and strings (See #Z3_get_symbol_kind).
///
/// \sa Z3_mk_int_symbol
/// \sa Z3_mk_string_symbol
abstract class Z3_symbol_kind {
  static const int INT_SYMBOL = 0;
  static const int STRING_SYMBOL = 1;
}

/// \brief The different kinds of parameters that can be associated with function symbols.
/// \sa Z3_get_decl_num_parameters
/// \sa Z3_get_decl_parameter_kind
///
/// - Z3_PARAMETER_INT is used for integer parameters.
/// - Z3_PARAMETER_DOUBLE is used for double parameters.
/// - Z3_PARAMETER_RATIONAL is used for parameters that are rational numbers.
/// - Z3_PARAMETER_SYMBOL is used for parameters that are symbols.
/// - Z3_PARAMETER_SORT is used for sort parameters.
/// - Z3_PARAMETER_AST is used for expression parameters.
/// - Z3_PARAMETER_FUNC_DECL is used for function declaration parameters.
abstract class Z3_parameter_kind {
  static const int PARAMETER_INT = 0;
  static const int PARAMETER_DOUBLE = 1;
  static const int PARAMETER_RATIONAL = 2;
  static const int PARAMETER_SYMBOL = 3;
  static const int PARAMETER_SORT = 4;
  static const int PARAMETER_AST = 5;
  static const int PARAMETER_FUNC_DECL = 6;
}

/// \brief The different kinds of Z3 types (See #Z3_get_sort_kind).
abstract class Z3_sort_kind {
  static const int UNINTERPRETED_SORT = 0;
  static const int BOOL_SORT = 1;
  static const int INT_SORT = 2;
  static const int REAL_SORT = 3;
  static const int BV_SORT = 4;
  static const int ARRAY_SORT = 5;
  static const int DATATYPE_SORT = 6;
  static const int RELATION_SORT = 7;
  static const int FINITE_DOMAIN_SORT = 8;
  static const int FLOATING_POINT_SORT = 9;
  static const int ROUNDING_MODE_SORT = 10;
  static const int SEQ_SORT = 11;
  static const int RE_SORT = 12;
  static const int CHAR_SORT = 13;
  static const int TYPE_VAR = 14;
  static const int UNKNOWN_SORT = 1000;
}

/// \brief
/// The different kinds of Z3 AST (abstract syntax trees). That is, terms, formulas and types.
///
/// - Z3_APP_AST:            constant and applications
/// - Z3_NUMERAL_AST:        numeral constants
/// - Z3_VAR_AST:            bound variables
/// - Z3_QUANTIFIER_AST:     quantifiers
/// - Z3_SORT_AST:           sort
/// - Z3_FUNC_DECL_AST:      function declaration
/// - Z3_UNKNOWN_AST:        internal
abstract class Z3_ast_kind {
  static const int NUMERAL_AST = 0;
  static const int APP_AST = 1;
  static const int VAR_AST = 2;
  static const int QUANTIFIER_AST = 3;
  static const int SORT_AST = 4;
  static const int FUNC_DECL_AST = 5;
  static const int UNKNOWN_AST = 1000;
}

/// \brief The different kinds of interpreted function kinds.
///
/// - Z3_OP_TRUE The constant true.
///
/// - Z3_OP_FALSE The constant false.
///
/// - Z3_OP_EQ The equality predicate.
///
/// - Z3_OP_DISTINCT The n-ary distinct predicate (every argument is mutually distinct).
///
/// - Z3_OP_ITE The ternary if-then-else term.
///
/// - Z3_OP_AND n-ary conjunction.
///
/// - Z3_OP_OR n-ary disjunction.
///
/// - Z3_OP_IFF equivalence (binary).
///
/// - Z3_OP_XOR Exclusive or.
///
/// - Z3_OP_NOT Negation.
///
/// - Z3_OP_IMPLIES Implication.
///
/// - Z3_OP_OEQ Binary equivalence modulo namings. This binary predicate is used in proof terms.
/// It captures equisatisfiability and equivalence modulo renamings.
///
/// - Z3_OP_ANUM Arithmetic numeral.
///
/// - Z3_OP_AGNUM Arithmetic algebraic numeral. Algebraic numbers are used to represent irrational numbers in Z3.
///
/// - Z3_OP_LE <=.
///
/// - Z3_OP_GE >=.
///
/// - Z3_OP_LT <.
///
/// - Z3_OP_GT >.
///
/// - Z3_OP_ADD Addition - Binary.
///
/// - Z3_OP_SUB Binary subtraction.
///
/// - Z3_OP_UMINUS Unary minus.
///
/// - Z3_OP_MUL Multiplication - Binary.
///
/// - Z3_OP_DIV Division - Binary.
///
/// - Z3_OP_IDIV Integer division - Binary.
///
/// - Z3_OP_REM Remainder - Binary.
///
/// - Z3_OP_MOD Modulus - Binary.
///
/// - Z3_OP_TO_REAL Coercion of integer to real - Unary.
///
/// - Z3_OP_TO_INT Coercion of real to integer - Unary.
///
/// - Z3_OP_IS_INT Check if real is also an integer - Unary.
///
/// - Z3_OP_POWER Power operator x^y.
///
/// - Z3_OP_STORE Array store. It satisfies select(store(a,i,v),j) = if i = j then v else select(a,j).
/// Array store takes at least 3 arguments.
///
/// - Z3_OP_SELECT Array select.
///
/// - Z3_OP_CONST_ARRAY The constant array. For example, select(const(v),i) = v holds for every v and i. The function is unary.
///
/// - Z3_OP_ARRAY_DEFAULT Default value of arrays. For example default(const(v)) = v. The function is unary.
///
/// - Z3_OP_ARRAY_MAP Array map operator.
/// It satisfies map[f](a1,..,a_n)[i] = f(a1[i],...,a_n[i]) for every i.
///
/// - Z3_OP_SET_UNION Set union between two Boolean arrays (two arrays whose range type is Boolean). The function is binary.
///
/// - Z3_OP_SET_INTERSECT Set intersection between two Boolean arrays. The function is binary.
///
/// - Z3_OP_SET_DIFFERENCE Set difference between two Boolean arrays. The function is binary.
///
/// - Z3_OP_SET_COMPLEMENT Set complement of a Boolean array. The function is unary.
///
/// - Z3_OP_SET_SUBSET Subset predicate between two Boolean arrays. The relation is binary.
///
/// - Z3_OP_AS_ARRAY An array value that behaves as the function graph of the
/// function passed as parameter.
///
/// - Z3_OP_ARRAY_EXT Array extensionality function. It takes two arrays as arguments and produces an index, such that the arrays
/// are different if they are different on the index.
///
/// - Z3_OP_BNUM Bit-vector numeral.
///
/// - Z3_OP_BIT1 One bit bit-vector.
///
/// - Z3_OP_BIT0 Zero bit bit-vector.
///
/// - Z3_OP_BNEG Unary minus.
///
/// - Z3_OP_BADD Binary addition.
///
/// - Z3_OP_BSUB Binary subtraction.
///
/// - Z3_OP_BMUL Binary multiplication.
///
/// - Z3_OP_BSDIV Binary signed division.
///
/// - Z3_OP_BUDIV Binary unsigned division.
///
/// - Z3_OP_BSREM Binary signed remainder.
///
/// - Z3_OP_BUREM Binary unsigned remainder.
///
/// - Z3_OP_BSMOD Binary signed modulus.
///
/// - Z3_OP_BSDIV0 Unary function. bsdiv(x,0) is congruent to bsdiv0(x).
///
/// - Z3_OP_BUDIV0 Unary function. budiv(x,0) is congruent to budiv0(x).
///
/// - Z3_OP_BSREM0 Unary function. bsrem(x,0) is congruent to bsrem0(x).
///
/// - Z3_OP_BUREM0 Unary function. burem(x,0) is congruent to burem0(x).
///
/// - Z3_OP_BSMOD0 Unary function. bsmod(x,0) is congruent to bsmod0(x).
///
/// - Z3_OP_ULEQ Unsigned bit-vector <= - Binary relation.
///
/// - Z3_OP_SLEQ Signed bit-vector  <= - Binary relation.
///
/// - Z3_OP_UGEQ Unsigned bit-vector  >= - Binary relation.
///
/// - Z3_OP_SGEQ Signed bit-vector  >= - Binary relation.
///
/// - Z3_OP_ULT Unsigned bit-vector  < - Binary relation.
///
/// - Z3_OP_SLT Signed bit-vector < - Binary relation.
///
/// - Z3_OP_UGT Unsigned bit-vector > - Binary relation.
///
/// - Z3_OP_SGT Signed bit-vector > - Binary relation.
///
/// - Z3_OP_BAND Bit-wise and - Binary.
///
/// - Z3_OP_BOR Bit-wise or - Binary.
///
/// - Z3_OP_BNOT Bit-wise not - Unary.
///
/// - Z3_OP_BXOR Bit-wise xor - Binary.
///
/// - Z3_OP_BNAND Bit-wise nand - Binary.
///
/// - Z3_OP_BNOR Bit-wise nor - Binary.
///
/// - Z3_OP_BXNOR Bit-wise xnor - Binary.
///
/// - Z3_OP_CONCAT Bit-vector concatenation - Binary.
///
/// - Z3_OP_SIGN_EXT Bit-vector sign extension.
///
/// - Z3_OP_ZERO_EXT Bit-vector zero extension.
///
/// - Z3_OP_EXTRACT Bit-vector extraction.
///
/// - Z3_OP_REPEAT Repeat bit-vector n times.
///
/// - Z3_OP_BREDOR Bit-vector reduce or - Unary.
///
/// - Z3_OP_BREDAND Bit-vector reduce and - Unary.
///
/// - Z3_OP_BCOMP .
///
/// - Z3_OP_BSHL Shift left.
///
/// - Z3_OP_BLSHR Logical shift right.
///
/// - Z3_OP_BASHR Arithmetical shift right.
///
/// - Z3_OP_ROTATE_LEFT Left rotation.
///
/// - Z3_OP_ROTATE_RIGHT Right rotation.
///
/// - Z3_OP_EXT_ROTATE_LEFT (extended) Left rotation. Similar to Z3_OP_ROTATE_LEFT, but it is a binary operator instead of a parametric one.
///
/// - Z3_OP_EXT_ROTATE_RIGHT (extended) Right rotation. Similar to Z3_OP_ROTATE_RIGHT, but it is a binary operator instead of a parametric one.
///
/// - Z3_OP_INT2BV Coerce integer to bit-vector. NB. This function
/// is not supported by the decision procedures. Only the most
/// rudimentary simplification rules are applied to this function.
///
/// - Z3_OP_BV2INT Coerce bit-vector to integer. NB. This function
/// is not supported by the decision procedures. Only the most
/// rudimentary simplification rules are applied to this function.
///
/// - Z3_OP_CARRY Compute the carry bit in a full-adder.
/// The meaning is given by the equivalence
/// (carry l1 l2 l3) <=> (or (and l1 l2) (and l1 l3) (and l2 l3)))
///
/// - Z3_OP_XOR3 Compute ternary XOR.
/// The meaning is given by the equivalence
/// (xor3 l1 l2 l3) <=> (xor (xor l1 l2) l3)
///
/// - Z3_OP_BSMUL_NO_OVFL: a predicate to check that bit-wise signed multiplication does not overflow.
/// Signed multiplication overflows if the operands have the same sign and the result of multiplication
/// does not fit within the available bits. \sa Z3_mk_bvmul_no_overflow.
///
/// - Z3_OP_BUMUL_NO_OVFL: check that bit-wise unsigned multiplication does not overflow.
/// Unsigned multiplication overflows if the result does not fit within the available bits.
/// \sa Z3_mk_bvmul_no_overflow.
///
/// - Z3_OP_BSMUL_NO_UDFL: check that bit-wise signed multiplication does not underflow.
/// Signed multiplication underflows if the operands have opposite signs and the result of multiplication
/// does not fit within the available bits. Z3_mk_bvmul_no_underflow.
///
/// - Z3_OP_BSDIV_I: Binary signed division.
/// It has the same semantics as Z3_OP_BSDIV, but created in a context where the second operand can be assumed to be non-zero.
///
/// - Z3_OP_BUDIV_I: Binary unsigned division.
/// It has the same semantics as Z3_OP_BUDIV, but created in a context where the second operand can be assumed to be non-zero.
///
/// - Z3_OP_BSREM_I: Binary signed remainder.
/// It has the same semantics as Z3_OP_BSREM, but created in a context where the second operand can be assumed to be non-zero.
///
/// - Z3_OP_BUREM_I: Binary unsigned remainder.
/// It has the same semantics as Z3_OP_BUREM, but created in a context where the second operand can be assumed to be non-zero.
///
/// - Z3_OP_BSMOD_I: Binary signed modulus.
/// It has the same semantics as Z3_OP_BSMOD, but created in a context where the second operand can be assumed to be non-zero.
///
/// - Z3_OP_PR_UNDEF: Undef/Null proof object.
///
/// - Z3_OP_PR_TRUE: Proof for the expression 'true'.
///
/// - Z3_OP_PR_ASSERTED: Proof for a fact asserted by the user.
///
/// - Z3_OP_PR_GOAL: Proof for a fact (tagged as goal) asserted by the user.
///
/// - Z3_OP_PR_MODUS_PONENS: Given a proof for p and a proof for (implies p q), produces a proof for q.
///
/// T1: p
/// T2: (implies p q)
/// [mp T1 T2]: q
///
/// The second antecedents may also be a proof for (iff p q).
///
/// - Z3_OP_PR_REFLEXIVITY: A proof for (R t t), where R is a reflexive relation. This proof object has no antecedents.
/// The only reflexive relations that are used are
/// equivalence modulo namings, equality and equivalence.
/// That is, R is either '~', '=' or 'iff'.
///
/// - Z3_OP_PR_SYMMETRY: Given an symmetric relation R and a proof for (R t s), produces a proof for (R s t).
/// \nicebox{
/// T1: (R t s)
/// [symmetry T1]: (R s t)
/// }
/// T1 is the antecedent of this proof object.
///
/// - Z3_OP_PR_TRANSITIVITY: Given a transitive relation R, and proofs for (R t s) and (R s u), produces a proof
/// for (R t u).
/// \nicebox{
/// T1: (R t s)
/// T2: (R s u)
/// [trans T1 T2]: (R t u)
/// }
///
/// - Z3_OP_PR_TRANSITIVITY_STAR: Condensed transitivity proof.
/// It combines several symmetry and transitivity proofs. Example:
/// \nicebox{
/// T1: (R a b)
/// T2: (R c b)
/// T3: (R c d)
/// [trans* T1 T2 T3]: (R a d)
/// }
/// R must be a symmetric and transitive relation.
///
/// Assuming that this proof object is a proof for (R s t), then
/// a proof checker must check if it is possible to prove (R s t)
/// using the antecedents, symmetry and transitivity.  That is,
/// if there is a path from s to t, if we view every
/// antecedent (R a b) as an edge between a and b.
///
/// - Z3_OP_PR_MONOTONICITY: Monotonicity proof object.
///
/// T1: (R t_1 s_1)
/// ...
/// Tn: (R t_n s_n)
/// [monotonicity T1 ... Tn]: (R (f t_1 ... t_n) (f s_1 ... s_n))
///
/// Remark: if t_i == s_i, then the antecedent Ti is suppressed.
/// That is, reflexivity proofs are suppressed to save space.
///
/// - Z3_OP_PR_QUANT_INTRO: Given a proof for (~ p q), produces a proof for (~ (forall (x) p) (forall (x) q)).
///
/// T1: (~ p q)
/// [quant-intro T1]: (~ (forall (x) p) (forall (x) q))
///
/// - Z3_OP_PR_BIND: Given a proof p, produces a proof of lambda x . p, where x are free variables in p.
///
/// T1: f
/// [proof-bind T1] forall (x) f
///
/// - Z3_OP_PR_DISTRIBUTIVITY: Distributivity proof object.
/// Given that f (= or) distributes over g (= and), produces a proof for
/// \nicebox{
/// (= (f a (g c d))
/// (g (f a c) (f a d)))
/// }
/// If f and g are associative, this proof also justifies the following equality:
/// \nicebox{
/// (= (f (g a b) (g c d))
/// (g (f a c) (f a d) (f b c) (f b d)))
/// }
/// where each f and g can have arbitrary number of arguments.
///
/// This proof object has no antecedents.
/// Remark. This rule is used by the CNF conversion pass and
/// instantiated by f = or, and g = and.
///
/// - Z3_OP_PR_AND_ELIM: Given a proof for (and l_1 ... l_n), produces a proof for l_i
///
/// T1: (and l_1 ... l_n)
/// [and-elim T1]: l_i
///
/// - Z3_OP_PR_NOT_OR_ELIM: Given a proof for (not (or l_1 ... l_n)), produces a proof for (not l_i).
///
/// T1: (not (or l_1 ... l_n))
/// [not-or-elim T1]: (not l_i)
///
/// - Z3_OP_PR_REWRITE: A proof for a local rewriting step (= t s).
/// The head function symbol of t is interpreted.
///
/// This proof object has no antecedents.
/// The conclusion of a rewrite rule is either an equality (= t s),
/// an equivalence (iff t s), or equi-satisfiability (~ t s).
/// Remark: if f is bool, then = is iff.
/// Examples:
/// \nicebox{
/// (= (+ x 0) x)
/// (= (+ x 1 2) (+ 3 x))
/// (iff (or x false) x)
/// }
///
/// - Z3_OP_PR_REWRITE_STAR: A proof for rewriting an expression t into an expression s.
/// This proof object can have n antecedents.
/// The antecedents are proofs for equalities used as substitution rules.
/// The proof rule is used in a few cases. The cases are:
/// - When applying contextual simplification (CONTEXT_SIMPLIFIER=true)
/// - When converting bit-vectors to Booleans (BIT2BOOL=true)
///
/// - Z3_OP_PR_PULL_QUANT: A proof for (iff (f (forall (x) q(x)) r) (forall (x) (f (q x) r))). This proof object has no antecedents.
///
/// - Z3_OP_PR_PUSH_QUANT: A proof for:
/// \nicebox{
/// (iff (forall (x_1 ... x_m) (and p_1[x_1 ... x_m] ... p_n[x_1 ... x_m]))
/// (and (forall (x_1 ... x_m) p_1[x_1 ... x_m])
/// ...
/// (forall (x_1 ... x_m) p_n[x_1 ... x_m])))
/// }
/// This proof object has no antecedents.
///
/// - Z3_OP_PR_ELIM_UNUSED_VARS:
/// A proof for (iff (forall (x_1 ... x_n y_1 ... y_m) p[x_1 ... x_n])
/// (forall (x_1 ... x_n) p[x_1 ... x_n]))
///
/// It is used to justify the elimination of unused variables.
/// This proof object has no antecedents.
///
/// - Z3_OP_PR_DER: A proof for destructive equality resolution:
/// (iff (forall (x) (or (not (= x t)) P[x])) P[t])
/// if x does not occur in t.
///
/// This proof object has no antecedents.
///
/// Several variables can be eliminated simultaneously.
///
/// - Z3_OP_PR_QUANT_INST: A proof of (or (not (forall (x) (P x))) (P a))
///
/// - Z3_OP_PR_HYPOTHESIS: Mark a hypothesis in a natural deduction style proof.
///
/// - Z3_OP_PR_LEMMA:
///
/// T1: false
/// [lemma T1]: (or (not l_1) ... (not l_n))
///
/// This proof object has one antecedent: a hypothetical proof for false.
/// It converts the proof in a proof for (or (not l_1) ... (not l_n)),
/// when T1 contains the open hypotheses: l_1, ..., l_n.
/// The hypotheses are closed after an application of a lemma.
/// Furthermore, there are no other open hypotheses in the subtree covered by
/// the lemma.
///
/// - Z3_OP_PR_UNIT_RESOLUTION:
/// \nicebox{
/// T1:      (or l_1 ... l_n l_1' ... l_m')
/// T2:      (not l_1)
/// ...
/// T(n+1):  (not l_n)
/// [unit-resolution T1 ... T(n+1)]: (or l_1' ... l_m')
/// }
///
/// - Z3_OP_PR_IFF_TRUE:
/// \nicebox{
/// T1: p
/// [iff-true T1]: (iff p true)
/// }
///
/// - Z3_OP_PR_IFF_FALSE:
/// \nicebox{
/// T1: (not p)
/// [iff-false T1]: (iff p false)
/// }
///
/// - Z3_OP_PR_COMMUTATIVITY:
///
/// [comm]: (= (f a b) (f b a))
///
/// f is a commutative operator.
///
/// This proof object has no antecedents.
/// Remark: if f is bool, then = is iff.
///
/// - Z3_OP_PR_DEF_AXIOM: Proof object used to justify Tseitin's like axioms:
/// \nicebox{
/// (or (not (and p q)) p)
/// (or (not (and p q)) q)
/// (or (not (and p q r)) p)
/// (or (not (and p q r)) q)
/// (or (not (and p q r)) r)
/// ...
/// (or (and p q) (not p) (not q))
/// (or (not (or p q)) p q)
/// (or (or p q) (not p))
/// (or (or p q) (not q))
/// (or (not (iff p q)) (not p) q)
/// (or (not (iff p q)) p (not q))
/// (or (iff p q) (not p) (not q))
/// (or (iff p q) p q)
/// (or (not (ite a b c)) (not a) b)
/// (or (not (ite a b c)) a c)
/// (or (ite a b c) (not a) (not b))
/// (or (ite a b c) a (not c))
/// (or (not (not a)) (not a))
/// (or (not a) a)
/// }
/// This proof object has no antecedents.
/// Note: all axioms are propositional tautologies.
/// Note also that 'and' and 'or' can take multiple arguments.
/// You can recover the propositional tautologies by
/// unfolding the Boolean connectives in the axioms a small
/// bounded number of steps (=3).
///
/// - Z3_OP_PR_ASSUMPTION_ADD
/// Clausal proof adding axiom
///
/// - Z3_OP_PR_LEMMA_ADD
/// Clausal proof lemma addition
///
/// - Z3_OP_PR_REDUNDANT_DEL
/// Clausal proof lemma deletion
///
/// - Z3_OP_PR_CLAUSE_TRAIL,
/// Clausal proof trail of additions and deletions
///
/// - Z3_OP_PR_DEF_INTRO: Introduces a name for a formula/term.
/// Suppose e is an expression with free variables x, and def-intro
/// introduces the name n(x). The possible cases are:
///
/// When e is of Boolean type:
/// [def-intro]: (and (or n (not e)) (or (not n) e))
///
/// or:
/// [def-intro]: (or (not n) e)
/// when e only occurs positively.
///
/// When e is of the form (ite cond th el):
/// [def-intro]: (and (or (not cond) (= n th)) (or cond (= n el)))
///
/// Otherwise:
/// [def-intro]: (= n e)
///
/// - Z3_OP_PR_APPLY_DEF:
///
/// [apply-def T1]: F ~ n
///
/// F is 'equivalent' to n, given that T1 is a proof that
/// n is a name for F.
///
/// - Z3_OP_PR_IFF_OEQ:
///
/// T1: (iff p q)
/// [iff~ T1]: (~ p q)
///
/// - Z3_OP_PR_NNF_POS: Proof for a (positive) NNF step. Example:
///
/// T1: (not s_1) ~ r_1
/// T2: (not s_2) ~ r_2
/// T3: s_1 ~ r_1'
/// T4: s_2 ~ r_2'
/// [nnf-pos T1 T2 T3 T4]: (~ (iff s_1 s_2) (and (or r_1 r_2') (or r_1' r_2)))
///
/// The negation normal form steps NNF_POS and NNF_NEG are used in the following cases:
/// (a) When creating the NNF of a positive force quantifier.
/// The quantifier is retained (unless the bound variables are eliminated).
/// Example
///
/// T1: q ~ q_new
/// [nnf-pos T1]: (~ (forall (x T) q) (forall (x T) q_new))
///
/// (b) When recursively creating NNF over Boolean formulas, where the top-level
/// connective is changed during NNF conversion. The relevant Boolean connectives
/// for NNF_POS are 'implies', 'iff', 'xor', 'ite'.
/// NNF_NEG furthermore handles the case where negation is pushed
/// over Boolean connectives 'and' and 'or'.
///
///
/// - Z3_OP_PR_NNF_NEG: Proof for a (negative) NNF step. Examples:
///
/// T1: (not s_1) ~ r_1
/// ...
/// Tn: (not s_n) ~ r_n
/// [nnf-neg T1 ... Tn]: (not (and s_1 ... s_n)) ~ (or r_1 ... r_n)
///
/// and
///
/// T1: (not s_1) ~ r_1
/// ...
/// Tn: (not s_n) ~ r_n
/// [nnf-neg T1 ... Tn]: (not (or s_1 ... s_n)) ~ (and r_1 ... r_n)
///
/// and
///
/// T1: (not s_1) ~ r_1
/// T2: (not s_2) ~ r_2
/// T3: s_1 ~ r_1'
/// T4: s_2 ~ r_2'
/// [nnf-neg T1 T2 T3 T4]: (~ (not (iff s_1 s_2))
/// (and (or r_1 r_2) (or r_1' r_2')))
///
/// - Z3_OP_PR_SKOLEMIZE: Proof for:
///
/// [sk]: (~ (not (forall x (p x y))) (not (p (sk y) y)))
/// [sk]: (~ (exists x (p x y)) (p (sk y) y))
///
/// This proof object has no antecedents.
///
/// - Z3_OP_PR_MODUS_PONENS_OEQ: Modus ponens style rule for equi-satisfiability.
///
/// T1: p
/// T2: (~ p q)
/// [mp~ T1 T2]: q
///
/// - Z3_OP_PR_TH_LEMMA: Generic proof for theory lemmas.
/// The theory lemma function comes with one or more parameters.
/// The first parameter indicates the name of the theory.
/// For the theory of arithmetic, additional parameters provide hints for
/// checking the theory lemma.
/// The hints for arithmetic are:
///
/// - farkas - followed by rational coefficients. Multiply the coefficients to the
/// inequalities in the lemma, add the (negated) inequalities and obtain a contradiction.
///
/// - triangle-eq - Indicates a lemma related to the equivalence:
///
/// (iff (= t1 t2) (and (<= t1 t2) (<= t2 t1)))
///
/// - gcd-test - Indicates an integer linear arithmetic lemma that uses a gcd test.
///
///
/// - Z3_OP_PR_HYPER_RESOLVE: Hyper-resolution rule.
///
/// The premises of the rules is a sequence of clauses.
/// The first clause argument is the main clause of the rule.
/// with a literal from the first (main) clause.
///
/// Premises of the rules are of the form
/// \nicebox{
/// (or l0 l1 l2 .. ln)
/// }
/// or
/// \nicebox{
/// (=> (and l1 l2 .. ln) l0)
/// }
/// or in the most general (ground) form:
/// \nicebox{
/// (=> (and ln+1 ln+2 .. ln+m) (or l0 l1 .. ln))
/// }
/// In other words we use the following (Prolog style) convention for Horn
/// implications:
/// The head of a Horn implication is position 0,
/// the first conjunct in the body of an implication is position 1
/// the second conjunct in the body of an implication is position 2
///
/// For general implications where the head is a disjunction, the
/// first n positions correspond to the n disjuncts in the head.
/// The next m positions correspond to the m conjuncts in the body.
///
/// The premises can be universally quantified so that the most
/// general non-ground form is:
///
/// \nicebox{
/// (forall (vars) (=> (and ln+1 ln+2 .. ln+m) (or l0 l1 .. ln)))
/// }
///
/// The hyper-resolution rule takes a sequence of parameters.
/// The parameters are substitutions of bound variables separated by pairs
/// of literal positions from the main clause and side clause.
///
///
/// - Z3_OP_RA_STORE: Insert a record into a relation.
/// The function takes \c n+1 arguments, where the first argument is the relation and the remaining \c n elements
/// correspond to the \c n columns of the relation.
///
/// - Z3_OP_RA_EMPTY: Creates the empty relation.
///
/// - Z3_OP_RA_IS_EMPTY: Tests if the relation is empty.
///
/// - Z3_OP_RA_JOIN: Create the relational join.
///
/// - Z3_OP_RA_UNION: Create the union or convex hull of two relations.
/// The function takes two arguments.
///
/// - Z3_OP_RA_WIDEN: Widen two relations.
/// The function takes two arguments.
///
/// - Z3_OP_RA_PROJECT: Project the columns (provided as numbers in the parameters).
/// The function takes one argument.
///
/// - Z3_OP_RA_FILTER: Filter (restrict) a relation with respect to a predicate.
/// The first argument is a relation.
/// The second argument is a predicate with free de-Bruijn indices
/// corresponding to the columns of the relation.
/// So the first column in the relation has index 0.
///
/// - Z3_OP_RA_NEGATION_FILTER: Intersect the first relation with respect to negation
/// of the second relation (the function takes two arguments).
/// Logically, the specification can be described by a function
///
/// target = filter_by_negation(pos, neg, columns)
///
/// where columns are pairs c1, d1, .., cN, dN of columns from pos and neg, such that
/// target are elements in x in pos, such that there is no y in neg that agrees with
/// x on the columns c1, d1, .., cN, dN.
///
///
/// - Z3_OP_RA_RENAME: rename columns in the relation.
/// The function takes one argument.
/// The parameters contain the renaming as a cycle.
///
/// - Z3_OP_RA_COMPLEMENT: Complement the relation.
///
/// - Z3_OP_RA_SELECT: Check if a record is an element of the relation.
/// The function takes \c n+1 arguments, where the first argument is a relation,
/// and the remaining \c n arguments correspond to a record.
///
/// - Z3_OP_RA_CLONE: Create a fresh copy (clone) of a relation.
/// The function is logically the identity, but
/// in the context of a register machine allows
/// for #Z3_OP_RA_UNION to perform destructive updates to the first argument.
///
///
/// - Z3_OP_FD_LT: A less than predicate over the finite domain Z3_FINITE_DOMAIN_SORT.
///
/// - Z3_OP_LABEL: A label (used by the Boogie Verification condition generator).
/// The label has two parameters, a string and a Boolean polarity.
/// It takes one argument, a formula.
///
/// - Z3_OP_LABEL_LIT: A label literal (used by the Boogie Verification condition generator).
/// A label literal has a set of string parameters. It takes no arguments.
///
/// - Z3_OP_DT_CONSTRUCTOR: datatype constructor.
///
/// - Z3_OP_DT_RECOGNISER: datatype recognizer.
///
/// - Z3_OP_DT_IS: datatype recognizer.
///
/// - Z3_OP_DT_ACCESSOR: datatype accessor.
///
/// - Z3_OP_DT_UPDATE_FIELD: datatype field update.
///
/// - Z3_OP_PB_AT_MOST: Cardinality constraint.
/// E.g., x + y + z <= 2
///
/// - Z3_OP_PB_AT_LEAST: Cardinality constraint.
/// E.g., x + y + z >= 2
///
/// - Z3_OP_PB_LE: Generalized Pseudo-Boolean cardinality constraint.
/// Example  2*x + 3*y <= 4
///
/// - Z3_OP_PB_GE: Generalized Pseudo-Boolean cardinality constraint.
/// Example  2*x + 3*y + 2*z >= 4
///
/// - Z3_OP_PB_EQ: Generalized Pseudo-Boolean equality constraint.
/// Example  2*x + 1*y + 2*z + 1*u = 4
///
/// - Z3_OP_SPECIAL_RELATION_LO: A relation that is a total linear order
///
/// - Z3_OP_SPECIAL_RELATION_PO: A relation that is a partial order
///
/// - Z3_OP_SPECIAL_RELATION_PLO: A relation that is a piecewise linear order
///
/// - Z3_OP_SPECIAL_RELATION_TO: A relation that is a tree order
///
/// - Z3_OP_SPECIAL_RELATION_TC: Transitive closure of a relation
///
/// - Z3_OP_SPECIAL_RELATION_TRC: Transitive reflexive closure of a relation
///
/// - Z3_OP_FPA_RM_NEAREST_TIES_TO_EVEN: Floating-point rounding mode RNE
///
/// - Z3_OP_FPA_RM_NEAREST_TIES_TO_AWAY: Floating-point rounding mode RNA
///
/// - Z3_OP_FPA_RM_TOWARD_POSITIVE: Floating-point rounding mode RTP
///
/// - Z3_OP_FPA_RM_TOWARD_NEGATIVE: Floating-point rounding mode RTN
///
/// - Z3_OP_FPA_RM_TOWARD_ZERO: Floating-point rounding mode RTZ
///
/// - Z3_OP_FPA_NUM: Floating-point value
///
/// - Z3_OP_FPA_PLUS_INF: Floating-point +oo
///
/// - Z3_OP_FPA_MINUS_INF: Floating-point -oo
///
/// - Z3_OP_FPA_NAN: Floating-point NaN
///
/// - Z3_OP_FPA_PLUS_ZERO: Floating-point +zero
///
/// - Z3_OP_FPA_MINUS_ZERO: Floating-point -zero
///
/// - Z3_OP_FPA_ADD: Floating-point addition
///
/// - Z3_OP_FPA_SUB: Floating-point subtraction
///
/// - Z3_OP_FPA_NEG: Floating-point negation
///
/// - Z3_OP_FPA_MUL: Floating-point multiplication
///
/// - Z3_OP_FPA_DIV: Floating-point division
///
/// - Z3_OP_FPA_REM: Floating-point remainder
///
/// - Z3_OP_FPA_ABS: Floating-point absolute value
///
/// - Z3_OP_FPA_MIN: Floating-point minimum
///
/// - Z3_OP_FPA_MAX: Floating-point maximum
///
/// - Z3_OP_FPA_FMA: Floating-point fused multiply-add
///
/// - Z3_OP_FPA_SQRT: Floating-point square root
///
/// - Z3_OP_FPA_ROUND_TO_INTEGRAL: Floating-point round to integral
///
/// - Z3_OP_FPA_EQ: Floating-point equality
///
/// - Z3_OP_FPA_LT: Floating-point less than
///
/// - Z3_OP_FPA_GT: Floating-point greater than
///
/// - Z3_OP_FPA_LE: Floating-point less than or equal
///
/// - Z3_OP_FPA_GE: Floating-point greater than or equal
///
/// - Z3_OP_FPA_IS_NAN: Floating-point isNaN
///
/// - Z3_OP_FPA_IS_INF: Floating-point isInfinite
///
/// - Z3_OP_FPA_IS_ZERO: Floating-point isZero
///
/// - Z3_OP_FPA_IS_NORMAL: Floating-point isNormal
///
/// - Z3_OP_FPA_IS_SUBNORMAL: Floating-point isSubnormal
///
/// - Z3_OP_FPA_IS_NEGATIVE: Floating-point isNegative
///
/// - Z3_OP_FPA_IS_POSITIVE: Floating-point isPositive
///
/// - Z3_OP_FPA_FP: Floating-point constructor from 3 bit-vectors
///
/// - Z3_OP_FPA_TO_FP: Floating-point conversion (various)
///
/// - Z3_OP_FPA_TO_FP_UNSIGNED: Floating-point conversion from unsigned bit-vector
///
/// - Z3_OP_FPA_TO_UBV: Floating-point conversion to unsigned bit-vector
///
/// - Z3_OP_FPA_TO_SBV: Floating-point conversion to signed bit-vector
///
/// - Z3_OP_FPA_TO_REAL: Floating-point conversion to real number
///
/// - Z3_OP_FPA_TO_IEEE_BV: Floating-point conversion to IEEE-754 bit-vector
///
/// - Z3_OP_FPA_BVWRAP: (Implicitly) represents the internal bitvector-
/// representation of a floating-point term (used for the lazy encoding
/// of non-relevant terms in theory_fpa)
///
/// - Z3_OP_FPA_BV2RM: Conversion of a 3-bit bit-vector term to a
/// floating-point rounding-mode term
///
/// The conversion uses the following values:
/// 0 = 000 = Z3_OP_FPA_RM_NEAREST_TIES_TO_EVEN,
/// 1 = 001 = Z3_OP_FPA_RM_NEAREST_TIES_TO_AWAY,
/// 2 = 010 = Z3_OP_FPA_RM_TOWARD_POSITIVE,
/// 3 = 011 = Z3_OP_FPA_RM_TOWARD_NEGATIVE,
/// 4 = 100 = Z3_OP_FPA_RM_TOWARD_ZERO.
///
/// - Z3_OP_INTERNAL: internal (often interpreted) symbol, but no additional
/// information is exposed. Tools may use the string representation of the
/// function declaration to obtain more information.
///
/// - Z3_OP_RECURSIVE: function declared as recursive
///
/// - Z3_OP_UNINTERPRETED: kind used for uninterpreted symbols.
abstract class Z3_decl_kind {
  static const int OP_TRUE = 256;
  static const int OP_FALSE = 257;
  static const int OP_EQ = 258;
  static const int OP_DISTINCT = 259;
  static const int OP_ITE = 260;
  static const int OP_AND = 261;
  static const int OP_OR = 262;
  static const int OP_IFF = 263;
  static const int OP_XOR = 264;
  static const int OP_NOT = 265;
  static const int OP_IMPLIES = 266;
  static const int OP_OEQ = 267;
  static const int OP_ANUM = 512;
  static const int OP_AGNUM = 513;
  static const int OP_LE = 514;
  static const int OP_GE = 515;
  static const int OP_LT = 516;
  static const int OP_GT = 517;
  static const int OP_ADD = 518;
  static const int OP_SUB = 519;
  static const int OP_UMINUS = 520;
  static const int OP_MUL = 521;
  static const int OP_DIV = 522;
  static const int OP_IDIV = 523;
  static const int OP_REM = 524;
  static const int OP_MOD = 525;
  static const int OP_TO_REAL = 526;
  static const int OP_TO_INT = 527;
  static const int OP_IS_INT = 528;
  static const int OP_POWER = 529;
  static const int OP_STORE = 768;
  static const int OP_SELECT = 769;
  static const int OP_CONST_ARRAY = 770;
  static const int OP_ARRAY_MAP = 771;
  static const int OP_ARRAY_DEFAULT = 772;
  static const int OP_SET_UNION = 773;
  static const int OP_SET_INTERSECT = 774;
  static const int OP_SET_DIFFERENCE = 775;
  static const int OP_SET_COMPLEMENT = 776;
  static const int OP_SET_SUBSET = 777;
  static const int OP_AS_ARRAY = 778;
  static const int OP_ARRAY_EXT = 779;
  static const int OP_SET_HAS_SIZE = 780;
  static const int OP_SET_CARD = 781;
  static const int OP_BNUM = 1024;
  static const int OP_BIT1 = 1025;
  static const int OP_BIT0 = 1026;
  static const int OP_BNEG = 1027;
  static const int OP_BADD = 1028;
  static const int OP_BSUB = 1029;
  static const int OP_BMUL = 1030;
  static const int OP_BSDIV = 1031;
  static const int OP_BUDIV = 1032;
  static const int OP_BSREM = 1033;
  static const int OP_BUREM = 1034;
  static const int OP_BSMOD = 1035;
  static const int OP_BSDIV0 = 1036;
  static const int OP_BUDIV0 = 1037;
  static const int OP_BSREM0 = 1038;
  static const int OP_BUREM0 = 1039;
  static const int OP_BSMOD0 = 1040;
  static const int OP_ULEQ = 1041;
  static const int OP_SLEQ = 1042;
  static const int OP_UGEQ = 1043;
  static const int OP_SGEQ = 1044;
  static const int OP_ULT = 1045;
  static const int OP_SLT = 1046;
  static const int OP_UGT = 1047;
  static const int OP_SGT = 1048;
  static const int OP_BAND = 1049;
  static const int OP_BOR = 1050;
  static const int OP_BNOT = 1051;
  static const int OP_BXOR = 1052;
  static const int OP_BNAND = 1053;
  static const int OP_BNOR = 1054;
  static const int OP_BXNOR = 1055;
  static const int OP_CONCAT = 1056;
  static const int OP_SIGN_EXT = 1057;
  static const int OP_ZERO_EXT = 1058;
  static const int OP_EXTRACT = 1059;
  static const int OP_REPEAT = 1060;
  static const int OP_BREDOR = 1061;
  static const int OP_BREDAND = 1062;
  static const int OP_BCOMP = 1063;
  static const int OP_BSHL = 1064;
  static const int OP_BLSHR = 1065;
  static const int OP_BASHR = 1066;
  static const int OP_ROTATE_LEFT = 1067;
  static const int OP_ROTATE_RIGHT = 1068;
  static const int OP_EXT_ROTATE_LEFT = 1069;
  static const int OP_EXT_ROTATE_RIGHT = 1070;
  static const int OP_BIT2BOOL = 1071;
  static const int OP_INT2BV = 1072;
  static const int OP_BV2INT = 1073;
  static const int OP_CARRY = 1074;
  static const int OP_XOR3 = 1075;
  static const int OP_BSMUL_NO_OVFL = 1076;
  static const int OP_BUMUL_NO_OVFL = 1077;
  static const int OP_BSMUL_NO_UDFL = 1078;
  static const int OP_BSDIV_I = 1079;
  static const int OP_BUDIV_I = 1080;
  static const int OP_BSREM_I = 1081;
  static const int OP_BUREM_I = 1082;
  static const int OP_BSMOD_I = 1083;
  static const int OP_PR_UNDEF = 1280;
  static const int OP_PR_TRUE = 1281;
  static const int OP_PR_ASSERTED = 1282;
  static const int OP_PR_GOAL = 1283;
  static const int OP_PR_MODUS_PONENS = 1284;
  static const int OP_PR_REFLEXIVITY = 1285;
  static const int OP_PR_SYMMETRY = 1286;
  static const int OP_PR_TRANSITIVITY = 1287;
  static const int OP_PR_TRANSITIVITY_STAR = 1288;
  static const int OP_PR_MONOTONICITY = 1289;
  static const int OP_PR_QUANT_INTRO = 1290;
  static const int OP_PR_BIND = 1291;
  static const int OP_PR_DISTRIBUTIVITY = 1292;
  static const int OP_PR_AND_ELIM = 1293;
  static const int OP_PR_NOT_OR_ELIM = 1294;
  static const int OP_PR_REWRITE = 1295;
  static const int OP_PR_REWRITE_STAR = 1296;
  static const int OP_PR_PULL_QUANT = 1297;
  static const int OP_PR_PUSH_QUANT = 1298;
  static const int OP_PR_ELIM_UNUSED_VARS = 1299;
  static const int OP_PR_DER = 1300;
  static const int OP_PR_QUANT_INST = 1301;
  static const int OP_PR_HYPOTHESIS = 1302;
  static const int OP_PR_LEMMA = 1303;
  static const int OP_PR_UNIT_RESOLUTION = 1304;
  static const int OP_PR_IFF_TRUE = 1305;
  static const int OP_PR_IFF_FALSE = 1306;
  static const int OP_PR_COMMUTATIVITY = 1307;
  static const int OP_PR_DEF_AXIOM = 1308;
  static const int OP_PR_ASSUMPTION_ADD = 1309;
  static const int OP_PR_LEMMA_ADD = 1310;
  static const int OP_PR_REDUNDANT_DEL = 1311;
  static const int OP_PR_CLAUSE_TRAIL = 1312;
  static const int OP_PR_DEF_INTRO = 1313;
  static const int OP_PR_APPLY_DEF = 1314;
  static const int OP_PR_IFF_OEQ = 1315;
  static const int OP_PR_NNF_POS = 1316;
  static const int OP_PR_NNF_NEG = 1317;
  static const int OP_PR_SKOLEMIZE = 1318;
  static const int OP_PR_MODUS_PONENS_OEQ = 1319;
  static const int OP_PR_TH_LEMMA = 1320;
  static const int OP_PR_HYPER_RESOLVE = 1321;
  static const int OP_RA_STORE = 1536;
  static const int OP_RA_EMPTY = 1537;
  static const int OP_RA_IS_EMPTY = 1538;
  static const int OP_RA_JOIN = 1539;
  static const int OP_RA_UNION = 1540;
  static const int OP_RA_WIDEN = 1541;
  static const int OP_RA_PROJECT = 1542;
  static const int OP_RA_FILTER = 1543;
  static const int OP_RA_NEGATION_FILTER = 1544;
  static const int OP_RA_RENAME = 1545;
  static const int OP_RA_COMPLEMENT = 1546;
  static const int OP_RA_SELECT = 1547;
  static const int OP_RA_CLONE = 1548;
  static const int OP_FD_CONSTANT = 1549;
  static const int OP_FD_LT = 1550;
  static const int OP_SEQ_UNIT = 1551;
  static const int OP_SEQ_EMPTY = 1552;
  static const int OP_SEQ_CONCAT = 1553;
  static const int OP_SEQ_PREFIX = 1554;
  static const int OP_SEQ_SUFFIX = 1555;
  static const int OP_SEQ_CONTAINS = 1556;
  static const int OP_SEQ_EXTRACT = 1557;
  static const int OP_SEQ_REPLACE = 1558;
  static const int OP_SEQ_REPLACE_RE = 1559;
  static const int OP_SEQ_REPLACE_RE_ALL = 1560;
  static const int OP_SEQ_REPLACE_ALL = 1561;
  static const int OP_SEQ_AT = 1562;
  static const int OP_SEQ_NTH = 1563;
  static const int OP_SEQ_LENGTH = 1564;
  static const int OP_SEQ_INDEX = 1565;
  static const int OP_SEQ_LAST_INDEX = 1566;
  static const int OP_SEQ_TO_RE = 1567;
  static const int OP_SEQ_IN_RE = 1568;
  static const int OP_STR_TO_INT = 1569;
  static const int OP_INT_TO_STR = 1570;
  static const int OP_UBV_TO_STR = 1571;
  static const int OP_SBV_TO_STR = 1572;
  static const int OP_STR_TO_CODE = 1573;
  static const int OP_STR_FROM_CODE = 1574;
  static const int OP_STRING_LT = 1575;
  static const int OP_STRING_LE = 1576;
  static const int OP_RE_PLUS = 1577;
  static const int OP_RE_STAR = 1578;
  static const int OP_RE_OPTION = 1579;
  static const int OP_RE_CONCAT = 1580;
  static const int OP_RE_UNION = 1581;
  static const int OP_RE_RANGE = 1582;
  static const int OP_RE_DIFF = 1583;
  static const int OP_RE_INTERSECT = 1584;
  static const int OP_RE_LOOP = 1585;
  static const int OP_RE_POWER = 1586;
  static const int OP_RE_COMPLEMENT = 1587;
  static const int OP_RE_EMPTY_SET = 1588;
  static const int OP_RE_FULL_SET = 1589;
  static const int OP_RE_FULL_CHAR_SET = 1590;
  static const int OP_RE_OF_PRED = 1591;
  static const int OP_RE_REVERSE = 1592;
  static const int OP_RE_DERIVATIVE = 1593;
  static const int OP_CHAR_CONST = 1594;
  static const int OP_CHAR_LE = 1595;
  static const int OP_CHAR_TO_INT = 1596;
  static const int OP_CHAR_TO_BV = 1597;
  static const int OP_CHAR_FROM_BV = 1598;
  static const int OP_CHAR_IS_DIGIT = 1599;
  static const int OP_LABEL = 1792;
  static const int OP_LABEL_LIT = 1793;
  static const int OP_DT_CONSTRUCTOR = 2048;
  static const int OP_DT_RECOGNISER = 2049;
  static const int OP_DT_IS = 2050;
  static const int OP_DT_ACCESSOR = 2051;
  static const int OP_DT_UPDATE_FIELD = 2052;
  static const int OP_PB_AT_MOST = 2304;
  static const int OP_PB_AT_LEAST = 2305;
  static const int OP_PB_LE = 2306;
  static const int OP_PB_GE = 2307;
  static const int OP_PB_EQ = 2308;
  static const int OP_SPECIAL_RELATION_LO = 40960;
  static const int OP_SPECIAL_RELATION_PO = 40961;
  static const int OP_SPECIAL_RELATION_PLO = 40962;
  static const int OP_SPECIAL_RELATION_TO = 40963;
  static const int OP_SPECIAL_RELATION_TC = 40964;
  static const int OP_SPECIAL_RELATION_TRC = 40965;
  static const int OP_FPA_RM_NEAREST_TIES_TO_EVEN = 45056;
  static const int OP_FPA_RM_NEAREST_TIES_TO_AWAY = 45057;
  static const int OP_FPA_RM_TOWARD_POSITIVE = 45058;
  static const int OP_FPA_RM_TOWARD_NEGATIVE = 45059;
  static const int OP_FPA_RM_TOWARD_ZERO = 45060;
  static const int OP_FPA_NUM = 45061;
  static const int OP_FPA_PLUS_INF = 45062;
  static const int OP_FPA_MINUS_INF = 45063;
  static const int OP_FPA_NAN = 45064;
  static const int OP_FPA_PLUS_ZERO = 45065;
  static const int OP_FPA_MINUS_ZERO = 45066;
  static const int OP_FPA_ADD = 45067;
  static const int OP_FPA_SUB = 45068;
  static const int OP_FPA_NEG = 45069;
  static const int OP_FPA_MUL = 45070;
  static const int OP_FPA_DIV = 45071;
  static const int OP_FPA_REM = 45072;
  static const int OP_FPA_ABS = 45073;
  static const int OP_FPA_MIN = 45074;
  static const int OP_FPA_MAX = 45075;
  static const int OP_FPA_FMA = 45076;
  static const int OP_FPA_SQRT = 45077;
  static const int OP_FPA_ROUND_TO_INTEGRAL = 45078;
  static const int OP_FPA_EQ = 45079;
  static const int OP_FPA_LT = 45080;
  static const int OP_FPA_GT = 45081;
  static const int OP_FPA_LE = 45082;
  static const int OP_FPA_GE = 45083;
  static const int OP_FPA_IS_NAN = 45084;
  static const int OP_FPA_IS_INF = 45085;
  static const int OP_FPA_IS_ZERO = 45086;
  static const int OP_FPA_IS_NORMAL = 45087;
  static const int OP_FPA_IS_SUBNORMAL = 45088;
  static const int OP_FPA_IS_NEGATIVE = 45089;
  static const int OP_FPA_IS_POSITIVE = 45090;
  static const int OP_FPA_FP = 45091;
  static const int OP_FPA_TO_FP = 45092;
  static const int OP_FPA_TO_FP_UNSIGNED = 45093;
  static const int OP_FPA_TO_UBV = 45094;
  static const int OP_FPA_TO_SBV = 45095;
  static const int OP_FPA_TO_REAL = 45096;
  static const int OP_FPA_TO_IEEE_BV = 45097;
  static const int OP_FPA_BVWRAP = 45098;
  static const int OP_FPA_BV2RM = 45099;
  static const int OP_INTERNAL = 45100;
  static const int OP_RECURSIVE = 45101;
  static const int OP_UNINTERPRETED = 45102;
}

/// \brief The different kinds of parameters that can be associated with parameter sets.
/// (see #Z3_mk_params).
///
/// - Z3_PK_UINT integer parameters.
/// - Z3_PK_BOOL boolean parameters.
/// - Z3_PK_DOUBLE double parameters.
/// - Z3_PK_SYMBOL symbol parameters.
/// - Z3_PK_STRING string parameters.
/// - Z3_PK_OTHER all internal parameter kinds which are not exposed in the API.
/// - Z3_PK_INVALID invalid parameter.
abstract class Z3_param_kind {
  static const int PK_UINT = 0;
  static const int PK_BOOL = 1;
  static const int PK_DOUBLE = 2;
  static const int PK_SYMBOL = 3;
  static const int PK_STRING = 4;
  static const int PK_OTHER = 5;
  static const int PK_INVALID = 6;
}

/// \brief Z3 pretty printing modes (See #Z3_set_ast_print_mode).
///
/// - Z3_PRINT_SMTLIB_FULL:   Print AST nodes in SMTLIB verbose format.
/// - Z3_PRINT_LOW_LEVEL:     Print AST nodes using a low-level format.
/// - Z3_PRINT_SMTLIB2_COMPLIANT: Print AST nodes in SMTLIB 2.x compliant format.
abstract class Z3_ast_print_mode {
  static const int PRINT_SMTLIB_FULL = 0;
  static const int PRINT_LOW_LEVEL = 1;
  static const int PRINT_SMTLIB2_COMPLIANT = 2;
}

/// \brief Z3 error codes (See #Z3_get_error_code).
///
/// - Z3_OK:            No error.
/// - Z3_SORT_ERROR:    User tried to build an invalid (type incorrect) AST.
/// - Z3_IOB:           Index out of bounds.
/// - Z3_INVALID_ARG:   Invalid argument was provided.
/// - Z3_PARSER_ERROR:  An error occurred when parsing a string or file.
/// - Z3_NO_PARSER:     Parser output is not available, that is, user didn't invoke #Z3_parse_smtlib2_string or #Z3_parse_smtlib2_file.
/// - Z3_INVALID_PATTERN: Invalid pattern was used to build a quantifier.
/// - Z3_MEMOUT_FAIL:   A memory allocation failure was encountered.
/// - Z3_FILE_ACCESS_ERRROR: A file could not be accessed.
/// - Z3_INVALID_USAGE:   API call is invalid in the current state.
/// - Z3_INTERNAL_FATAL: An error internal to Z3 occurred.
/// - Z3_DEC_REF_ERROR: Trying to decrement the reference counter of an AST that was deleted or the reference counter was not initialized with #Z3_inc_ref.
/// - Z3_EXCEPTION:     Internal Z3 exception. Additional details can be retrieved using #Z3_get_error_msg.
abstract class Z3_error_code {
  static const int OK = 0;
  static const int SORT_ERROR = 1;
  static const int IOB = 2;
  static const int INVALID_ARG = 3;
  static const int PARSER_ERROR = 4;
  static const int NO_PARSER = 5;
  static const int INVALID_PATTERN = 6;
  static const int MEMOUT_FAIL = 7;
  static const int FILE_ACCESS_ERROR = 8;
  static const int INTERNAL_FATAL = 9;
  static const int INVALID_USAGE = 10;
  static const int DEC_REF_ERROR = 11;
  static const int EXCEPTION = 12;
}

/// \brief A Goal is essentially a set of formulas.
/// Z3 provide APIs for building strategies/tactics for solving and transforming Goals.
/// Some of these transformations apply under/over approximations.
///
/// - Z3_GOAL_PRECISE:    Approximations/Relaxations were not applied on the goal (sat and unsat answers were preserved).
/// - Z3_GOAL_UNDER:      Goal is the product of a under-approximation (sat answers are preserved).
/// - Z3_GOAL_OVER:       Goal is the product of an over-approximation (unsat answers are preserved).
/// - Z3_GOAL_UNDER_OVER: Goal is garbage (it is the product of over- and under-approximations, sat and unsat answers are not preserved).
abstract class Z3_goal_prec {
  static const int GOAL_PRECISE = 0;
  static const int GOAL_UNDER = 1;
  static const int GOAL_OVER = 2;
  static const int GOAL_UNDER_OVER = 3;
}

/// \brief Z3 string type. It is just an alias for \ccode{const char *}.
typedef Z3_string = ffi.Pointer<ffi.Char>;
typedef Z3_string_ptr = ffi.Pointer<Z3_string>;
typedef Z3_config = ffi.Pointer<_Z3_config>;
typedef Z3_context = ffi.Pointer<_Z3_context>;
typedef Z3_ast = ffi.Pointer<_Z3_ast>;
typedef Z3_param_descrs = ffi.Pointer<_Z3_param_descrs>;
typedef Z3_params = ffi.Pointer<_Z3_params>;
typedef Z3_symbol = ffi.Pointer<_Z3_symbol>;
typedef Z3_sort = ffi.Pointer<_Z3_sort>;
typedef Z3_func_decl = ffi.Pointer<_Z3_func_decl>;
typedef Z3_constructor = ffi.Pointer<_Z3_constructor>;
typedef Z3_constructor_list = ffi.Pointer<_Z3_constructor_list>;
typedef Z3_char_ptr = ffi.Pointer<ffi.Char>;
typedef Z3_pattern = ffi.Pointer<_Z3_pattern>;
typedef Z3_app = ffi.Pointer<_Z3_app>;
typedef Z3_model = ffi.Pointer<_Z3_model>;
typedef Z3_func_interp = ffi.Pointer<_Z3_func_interp>;
typedef Z3_ast_vector = ffi.Pointer<_Z3_ast_vector>;
typedef Z3_func_entry = ffi.Pointer<_Z3_func_entry>;
typedef Z3_parser_context = ffi.Pointer<_Z3_parser_context>;
typedef Z3_error_handler
    = ffi.NativeFunction<ffi.Void Function(Z3_context c, ffi.Int32 e)>;
typedef Z3_goal = ffi.Pointer<_Z3_goal>;
typedef Z3_tactic = ffi.Pointer<_Z3_tactic>;
typedef Z3_probe = ffi.Pointer<_Z3_probe>;
typedef Z3_simplifier = ffi.Pointer<_Z3_simplifier>;
typedef Z3_solver = ffi.Pointer<_Z3_solver>;
typedef Z3_apply_result = ffi.Pointer<_Z3_apply_result>;
typedef Z3_on_clause_eh = ffi.NativeFunction<
    ffi.Void Function(
        ffi.Pointer<ffi.Void> ctx,
        Z3_ast proof_hint,
        ffi.UnsignedInt n,
        ffi.Pointer<ffi.UnsignedInt> deps,
        Z3_ast_vector literals)>;
typedef Z3_push_eh = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<ffi.Void> ctx, Z3_solver_callback cb)>;
typedef Z3_solver_callback = ffi.Pointer<_Z3_solver_callback>;
typedef Z3_pop_eh = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<ffi.Void> ctx, Z3_solver_callback cb,
        ffi.UnsignedInt num_scopes)>;
typedef Z3_fresh_eh = ffi.NativeFunction<
    ffi.Pointer<ffi.Void> Function(
        ffi.Pointer<ffi.Void> ctx, Z3_context new_context)>;
typedef Z3_fixed_eh = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<ffi.Void> ctx, Z3_solver_callback cb,
        Z3_ast t, Z3_ast value)>;
typedef Z3_final_eh = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<ffi.Void> ctx, Z3_solver_callback cb)>;
typedef Z3_eq_eh = ffi.NativeFunction<
    ffi.Void Function(
        ffi.Pointer<ffi.Void> ctx, Z3_solver_callback cb, Z3_ast s, Z3_ast t)>;
typedef Z3_created_eh = ffi.NativeFunction<
    ffi.Void Function(
        ffi.Pointer<ffi.Void> ctx, Z3_solver_callback cb, Z3_ast t)>;
typedef Z3_decide_eh = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<ffi.Void> ctx, Z3_solver_callback cb,
        Z3_ast t, ffi.UnsignedInt idx, ffi.Bool phase)>;
typedef Z3_stats = ffi.Pointer<_Z3_stats>;
typedef Z3_ast_map = ffi.Pointer<_Z3_ast_map>;
typedef Z3_rcf_num = ffi.Pointer<_Z3_rcf_num>;
typedef Z3_fixedpoint = ffi.Pointer<_Z3_fixedpoint>;

/// \brief The following utilities allows adding user-defined domains.
typedef Z3_fixedpoint_reduce_assign_callback_fptr = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<ffi.Void>, Z3_func_decl, ffi.UnsignedInt,
        ffi.Pointer<Z3_ast>, ffi.UnsignedInt, ffi.Pointer<Z3_ast>)>;
typedef Z3_fixedpoint_reduce_app_callback_fptr = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<ffi.Void>, Z3_func_decl, ffi.UnsignedInt,
        ffi.Pointer<Z3_ast>, ffi.Pointer<Z3_ast>)>;
typedef Z3_fixedpoint_new_lemma_eh = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(
            ffi.Pointer<ffi.Void> state, Z3_ast lemma, ffi.UnsignedInt level)>>;
typedef Z3_fixedpoint_predecessor_eh = ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> state)>>;
typedef Z3_fixedpoint_unfold_eh = ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> state)>>;
typedef Z3_optimize = ffi.Pointer<_Z3_optimize>;

/// \brief callback functions for models.
typedef Z3_model_eh
    = ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> ctx)>;

const int _VCRT_COMPILER_PREPROCESSOR = 1;

const int _SAL_VERSION = 20;

const int __SAL_H_VERSION = 180000000;

const int _USE_DECLSPECS_FOR_SAL = 0;

const int _USE_ATTRIBUTES_FOR_SAL = 0;

const int _CRT_PACKING = 8;

const int _VCRUNTIME_DISABLED_WARNINGS = 4514;

const int _HAS_EXCEPTIONS = 1;

const int _WCHAR_T_DEFINED = 1;

const int NULL = 0;

const int _HAS_CXX17 = 0;

const int _HAS_CXX20 = 0;

const int _HAS_NODISCARD = 1;

const int _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE = 1;

const int _CRT_BUILD_DESKTOP_APP = 1;

const int _UCRT_DISABLED_WARNINGS = 4324;

const int _ARGMAX = 100;

const int _TRUNCATE = -1;

const int _CRT_INT_MAX = 2147483647;

const int _CRT_SIZE_MAX = -1;

const String __FILEW__ = 'C';

const int _CRT_FUNCTIONS_REQUIRED = 1;

const int _CRT_HAS_CXX17 = 0;

const int _CRT_HAS_C11 = 0;

const int _CRT_INTERNAL_NONSTDC_NAMES = 1;

const int __STDC_SECURE_LIB__ = 200411;

const int __GOT_SECURE_LIB__ = 200411;

const int __STDC_WANT_SECURE_LIB__ = 1;

const int _SECURECRT_FILL_BUFFER_PATTERN = 254;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES = 0;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT = 0;

const int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES = 1;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY = 0;

const int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY = 0;

const String _CRT_INTERNAL_STDIO_SYMBOL_PREFIX = '';

const int _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION = 1;

const int _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR = 2;

const int _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS = 4;

const int _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY = 8;

const int _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS = 16;

const int _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING = 32;

const int _CRT_INTERNAL_SCANF_SECURECRT = 1;

const int _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS = 2;

const int _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY = 4;

const int WEOF = 65535;

const int BUFSIZ = 512;

const int _NFILE = 512;

const int _NSTREAM_ = 512;

const int _IOB_ENTRIES = 3;

const int EOF = -1;

const int _IOFBF = 0;

const int _IOLBF = 64;

const int _IONBF = 4;

const int L_tmpnam = 260;

const int L_tmpnam_s = 260;

const int SEEK_CUR = 1;

const int SEEK_END = 2;

const int SEEK_SET = 0;

const int FILENAME_MAX = 260;

const int FOPEN_MAX = 20;

const int _SYS_OPEN = 20;

const int TMP_MAX = 2147483647;

const int TMP_MAX_S = 2147483647;

const int _TMP_MAX_S = 2147483647;

const int SYS_OPEN = 20;

const int __bool_true_false_are_defined = 1;

const int false1 = 0;

const int true1 = 1;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -2147483648;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 2147483647;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 4294967295;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MIN = -9223372036854775808;

const int INTPTR_MAX = 9223372036854775807;

const int UINTPTR_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIZE_MAX = -1;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int WCHAR_MIN = 0;

const int WCHAR_MAX = 65535;

const int WINT_MIN = 0;

const int WINT_MAX = 65535;
